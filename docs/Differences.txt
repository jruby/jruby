
How JRuby differs from the original Ruby
----------------------------------------

Speed:

    JRuby is slower than 'ruby' for many reasons. It uses real objects
    for numbers, have more memory overhead and Java is in many cases
    slower than C.
    Once JRuby gets a bytecode compiler the difference should be less
    obvious.

Object ids and finalizers:

    JRuby doesn't guarantee that integers returned by Object#id are
    unique. This also prevents the implementation of finalizers.

Threading:

    JRuby uses Java's threads, which are usually the native threads of
    the operating system, while 'ruby' uses it's own "green" thread
    implementation.
    Because Java does not provide a pthreads-compatible threading
    library, some thread operations are simulated. When told to stop,
    sleep, wait, criticalize, or wakeup, JRuby threads' behavior will
    differ slightly from pthreads.
    Threads will also act according to the thread scheduling semantics
    of the JVM and the host system rather than according to the
    semantics of ruby's internal scheduler. This can mean that new bugs
    will appear in multithreaded programs because assumptions made under
    ruby's thread scheduler do not hold under JVM threading or
    platform-native thread schedulers. In general, threads provided by
    JRuby will act just like Java threads.
    
Character encoding:

    JRuby uses Java's Unicode support for strings. [Something on what
    this affects.]

