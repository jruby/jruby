/******************************************************************************/
/* This file is generated by the templates/template.rb script and should not  */
/* be modified manually. See                                                  */
/* templates/java/org/yarp/Nodes.java.erb                                     */
/* if you are looking to modify the                                           */
/* template                                                                   */
/******************************************************************************/
package org.yarp;

import java.lang.Override;
import java.lang.String;
import java.lang.StringBuilder;
import java.util.ArrayList;
import java.util.Arrays;

// GENERATED BY Nodes.java.erb
// @formatter:off
public abstract class Nodes {

    public static final byte[][] EMPTY_BYTE_ARRAY_ARRAY = {};

    public static final class Location {

        public static final Location[] EMPTY_ARRAY = {};

        public final int startOffset;
        public final int length;

        public Location(int startOffset, int length) {
            this.startOffset = startOffset;
            this.length = length;
        }

        public int endOffset() {
            return startOffset + length;
        }
    }

    public static final class Source {
        public final byte[] bytes;
        private final int[] lineOffsets;

        public Source(byte[] bytes) {
            this(bytes, computeLineOffsets(bytes));
        }

        public Source(byte[] bytes, int[] lineOffsets) {
            assert lineOffsets[0] == 0;
            this.bytes = bytes;
            this.lineOffsets = lineOffsets;
        }

        public static int[] computeLineOffsets(byte[] bytes) {
            int[] lineOffsets = new int[8];
            int lineOffsetsSize = 0;
            lineOffsets[lineOffsetsSize++] = 0;

            for (int i = 0; i < bytes.length; i++) {
                if (bytes[i] == '\n') {
                    if (lineOffsetsSize == lineOffsets.length) {
                        lineOffsets = Arrays.copyOf(lineOffsets, lineOffsets.length * 2);
                    }
                    lineOffsets[lineOffsetsSize++] = i + 1;
                }
            }
            return Arrays.copyOf(lineOffsets, lineOffsetsSize);
        }

        public int line(int byteOffset) {
            assert byteOffset >= 0 && byteOffset < bytes.length : byteOffset;
            int index = Arrays.binarySearch(lineOffsets, byteOffset);
            int line;
            if (index < 0) {
                line = -index - 1;
            } else {
                line = index + 1;
            }
            assert line >= 1 && line <= getLineCount() : line;
            return line;
        }

        public int getLineCount() {
            return lineOffsets.length;
        }
    }

    public static abstract class Node {

        public static final Node[] EMPTY_ARRAY = {};

        public final int startOffset;
        public final int length;
        private boolean newLineFlag = false;

        public Node(int startOffset, int length) {
            this.startOffset = startOffset;
            this.length = length;
        }

        public final int endOffset() {
            return startOffset + length;
        }

        public final boolean hasNewLineFlag() {
            return newLineFlag;
        }

        public void setNewLineFlag(Source source, boolean[] newlineMarked) {
            int line = source.line(this.startOffset);
            if (!newlineMarked[line]) {
                newlineMarked[line] = true;
                this.newLineFlag = true;
            }
        }

        public abstract <T> T accept(AbstractNodeVisitor<T> visitor);

        public abstract <T> void visitChildNodes(AbstractNodeVisitor<T> visitor);

        public abstract Node[] childNodes();

        @Override
        public String toString() {
            return toString("");
        }

        private String toString(String indent) {
            StringBuilder builder = new StringBuilder();
            builder.append(indent).append(this.getClass().getSimpleName());
            if (hasNewLineFlag()) {
                builder.append("[Li]");
            }
            builder.append('\n');
            for (Node child : childNodes()) {
                if (child != null) {
                    builder.append(child.toString(indent + "  "));
                }
            }
            return builder.toString();
        }
    }

    public static final class CallNodeFlags implements Comparable<CallNodeFlags> {

        // &. operator
        public static final short SAFE_NAVIGATION = 1 << 0;

        // a call that could have been a local variable
        public static final short VARIABLE_CALL = 1 << 1;

        public static boolean isSafeNavigation(short flags) {
            return (flags & SAFE_NAVIGATION) != 0;
        }

        public static boolean isVariableCall(short flags) {
            return (flags & VARIABLE_CALL) != 0;
        }

        private final short flags;

        public CallNodeFlags(short flags) {
            this.flags = flags;
        }

        @Override
        public int hashCode() {
            return flags;
        }

        @Override
        public boolean equals(Object other) {
            if (!(other instanceof CallNodeFlags)) {
                return false;
            }

            return flags == ((CallNodeFlags) other).flags;
        }

        @Override
        public int compareTo(CallNodeFlags other) {
            return flags - other.flags;
        }

        public boolean isSafeNavigation() {
            return (flags & SAFE_NAVIGATION) != 0;
        }

        public boolean isVariableCall() {
            return (flags & VARIABLE_CALL) != 0;
        }

    }

    public static final class LoopFlags implements Comparable<LoopFlags> {

        // a loop after a begin statement, so the body is executed first before the condition
        public static final short BEGIN_MODIFIER = 1 << 0;

        public static boolean isBeginModifier(short flags) {
            return (flags & BEGIN_MODIFIER) != 0;
        }

        private final short flags;

        public LoopFlags(short flags) {
            this.flags = flags;
        }

        @Override
        public int hashCode() {
            return flags;
        }

        @Override
        public boolean equals(Object other) {
            if (!(other instanceof LoopFlags)) {
                return false;
            }

            return flags == ((LoopFlags) other).flags;
        }

        @Override
        public int compareTo(LoopFlags other) {
            return flags - other.flags;
        }

        public boolean isBeginModifier() {
            return (flags & BEGIN_MODIFIER) != 0;
        }

    }

    public static final class RangeFlags implements Comparable<RangeFlags> {

        // ... operator
        public static final short EXCLUDE_END = 1 << 0;

        public static boolean isExcludeEnd(short flags) {
            return (flags & EXCLUDE_END) != 0;
        }

        private final short flags;

        public RangeFlags(short flags) {
            this.flags = flags;
        }

        @Override
        public int hashCode() {
            return flags;
        }

        @Override
        public boolean equals(Object other) {
            if (!(other instanceof RangeFlags)) {
                return false;
            }

            return flags == ((RangeFlags) other).flags;
        }

        @Override
        public int compareTo(RangeFlags other) {
            return flags - other.flags;
        }

        public boolean isExcludeEnd() {
            return (flags & EXCLUDE_END) != 0;
        }

    }

    public static final class RegularExpressionFlags implements Comparable<RegularExpressionFlags> {

        // i - ignores the case of characters when matching
        public static final short IGNORE_CASE = 1 << 0;

        // m - allows $ to match the end of lines within strings
        public static final short MULTI_LINE = 1 << 1;

        // x - ignores whitespace and allows comments in regular expressions
        public static final short EXTENDED = 1 << 2;

        // e - forces the EUC-JP encoding
        public static final short EUC_JP = 1 << 3;

        // n - forces the ASCII-8BIT encoding
        public static final short ASCII_8BIT = 1 << 4;

        // s - forces the Windows-31J encoding
        public static final short WINDOWS_31J = 1 << 5;

        // u - forces the UTF-8 encoding
        public static final short UTF_8 = 1 << 6;

        // o - only interpolates values into the regular expression once
        public static final short ONCE = 1 << 7;

        public static boolean isIgnoreCase(short flags) {
            return (flags & IGNORE_CASE) != 0;
        }

        public static boolean isMultiLine(short flags) {
            return (flags & MULTI_LINE) != 0;
        }

        public static boolean isExtended(short flags) {
            return (flags & EXTENDED) != 0;
        }

        public static boolean isEucJp(short flags) {
            return (flags & EUC_JP) != 0;
        }

        public static boolean isAscii8bit(short flags) {
            return (flags & ASCII_8BIT) != 0;
        }

        public static boolean isWindows31j(short flags) {
            return (flags & WINDOWS_31J) != 0;
        }

        public static boolean isUtf8(short flags) {
            return (flags & UTF_8) != 0;
        }

        public static boolean isOnce(short flags) {
            return (flags & ONCE) != 0;
        }

        private final short flags;

        public RegularExpressionFlags(short flags) {
            this.flags = flags;
        }

        @Override
        public int hashCode() {
            return flags;
        }

        @Override
        public boolean equals(Object other) {
            if (!(other instanceof RegularExpressionFlags)) {
                return false;
            }

            return flags == ((RegularExpressionFlags) other).flags;
        }

        @Override
        public int compareTo(RegularExpressionFlags other) {
            return flags - other.flags;
        }

        public boolean isIgnoreCase() {
            return (flags & IGNORE_CASE) != 0;
        }

        public boolean isMultiLine() {
            return (flags & MULTI_LINE) != 0;
        }

        public boolean isExtended() {
            return (flags & EXTENDED) != 0;
        }

        public boolean isEucJp() {
            return (flags & EUC_JP) != 0;
        }

        public boolean isAscii8bit() {
            return (flags & ASCII_8BIT) != 0;
        }

        public boolean isWindows31j() {
            return (flags & WINDOWS_31J) != 0;
        }

        public boolean isUtf8() {
            return (flags & UTF_8) != 0;
        }

        public boolean isOnce() {
            return (flags & ONCE) != 0;
        }

    }

    // Represents the use of the `alias` keyword.
    // 
    //     alias foo bar
    //     ^^^^^^^^^^^^^
    public static final class AliasNode extends Node {
        public final Node new_name;
        public final Node old_name;
        public final Location keyword_loc;

        public AliasNode(Node new_name, Node old_name, Location keyword_loc, int startOffset, int length) {
            super(startOffset, length);
            this.new_name = new_name;
            this.old_name = old_name;
            this.keyword_loc = keyword_loc;
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
            this.new_name.accept(visitor);
            this.old_name.accept(visitor);
        }

        public Node[] childNodes() {
            return new Node[] { this.new_name, this.old_name };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitAliasNode(this);
        }
    }

    // Represents an alternation pattern in pattern matching.
    // 
    //     foo => bar | baz
    //            ^^^^^^^^^
    public static final class AlternationPatternNode extends Node {
        public final Node left;
        public final Node right;
        public final Location operator_loc;

        public AlternationPatternNode(Node left, Node right, Location operator_loc, int startOffset, int length) {
            super(startOffset, length);
            this.left = left;
            this.right = right;
            this.operator_loc = operator_loc;
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
            this.left.accept(visitor);
            this.right.accept(visitor);
        }

        public Node[] childNodes() {
            return new Node[] { this.left, this.right };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitAlternationPatternNode(this);
        }
    }

    // Represents the use of the `&&` operator or the `and` keyword.
    // 
    //     left and right
    //     ^^^^^^^^^^^^^^
    public static final class AndNode extends Node {
        public final Node left;
        public final Node right;
        public final Location operator_loc;

        public AndNode(Node left, Node right, Location operator_loc, int startOffset, int length) {
            super(startOffset, length);
            this.left = left;
            this.right = right;
            this.operator_loc = operator_loc;
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
            this.left.accept(visitor);
            this.right.accept(visitor);
        }

        public Node[] childNodes() {
            return new Node[] { this.left, this.right };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitAndNode(this);
        }
    }

    // Represents a set of arguments to a method or a keyword.
    // 
    //     return foo, bar, baz
    //            ^^^^^^^^^^^^^
    public static final class ArgumentsNode extends Node {
        public final Node[] arguments;

        public ArgumentsNode(Node[] arguments, int startOffset, int length) {
            super(startOffset, length);
            this.arguments = arguments;
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
            for (Nodes.Node child : this.arguments) {
                child.accept(visitor);
            }
        }

        public Node[] childNodes() {
            return this.arguments;
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitArgumentsNode(this);
        }
    }

    // Represents an array literal. This can be a regular array using brackets or
    // a special array using % like %w or %i.
    // 
    //     [1, 2, 3]
    //     ^^^^^^^^^
    public static final class ArrayNode extends Node {
        public final Node[] elements;
        public final Location opening_loc; // optional
        public final Location closing_loc; // optional

        public ArrayNode(Node[] elements, Location opening_loc, Location closing_loc, int startOffset, int length) {
            super(startOffset, length);
            this.elements = elements;
            this.opening_loc = opening_loc;
            this.closing_loc = closing_loc;
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
            for (Nodes.Node child : this.elements) {
                child.accept(visitor);
            }
        }

        public Node[] childNodes() {
            return this.elements;
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitArrayNode(this);
        }
    }

    // Represents an array pattern in pattern matching.
    // 
    //     foo in 1, 2
    //     ^^^^^^^^^^^
    // 
    //     foo in [1, 2]
    //     ^^^^^^^^^^^^^
    // 
    //     foo in *1
    //     ^^^^^^^^^
    // 
    //     foo in Bar[]
    //     ^^^^^^^^^^^^
    // 
    //     foo in Bar[1, 2, 3]
    //     ^^^^^^^^^^^^^^^^^^^
    public static final class ArrayPatternNode extends Node {
        public final Node constant; // optional
        public final Node[] requireds;
        public final Node rest; // optional
        public final Node[] posts;
        public final Location opening_loc; // optional
        public final Location closing_loc; // optional

        public ArrayPatternNode(Node constant, Node[] requireds, Node rest, Node[] posts, Location opening_loc, Location closing_loc, int startOffset, int length) {
            super(startOffset, length);
            this.constant = constant;
            this.requireds = requireds;
            this.rest = rest;
            this.posts = posts;
            this.opening_loc = opening_loc;
            this.closing_loc = closing_loc;
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
            if (this.constant != null) {
                this.constant.accept(visitor);
            }
            for (Nodes.Node child : this.requireds) {
                child.accept(visitor);
            }
            if (this.rest != null) {
                this.rest.accept(visitor);
            }
            for (Nodes.Node child : this.posts) {
                child.accept(visitor);
            }
        }

        public Node[] childNodes() {
            ArrayList<Node> childNodes = new ArrayList<>();
            childNodes.add(this.constant);
            childNodes.addAll(Arrays.asList(this.requireds));
            childNodes.add(this.rest);
            childNodes.addAll(Arrays.asList(this.posts));
            return childNodes.toArray(EMPTY_ARRAY);
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitArrayPatternNode(this);
        }
    }

    // Represents a hash key/value pair.
    // 
    //     { a => b }
    //       ^^^^^^
    public static final class AssocNode extends Node {
        public final Node key;
        public final Node value; // optional
        public final Location operator_loc; // optional

        public AssocNode(Node key, Node value, Location operator_loc, int startOffset, int length) {
            super(startOffset, length);
            this.key = key;
            this.value = value;
            this.operator_loc = operator_loc;
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
            this.key.accept(visitor);
            if (this.value != null) {
                this.value.accept(visitor);
            }
        }

        public Node[] childNodes() {
            return new Node[] { this.key, this.value };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitAssocNode(this);
        }
    }

    // Represents a splat in a hash literal.
    // 
    //     { **foo }
    //       ^^^^^
    public static final class AssocSplatNode extends Node {
        public final Node value; // optional
        public final Location operator_loc;

        public AssocSplatNode(Node value, Location operator_loc, int startOffset, int length) {
            super(startOffset, length);
            this.value = value;
            this.operator_loc = operator_loc;
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
            if (this.value != null) {
                this.value.accept(visitor);
            }
        }

        public Node[] childNodes() {
            return new Node[] { this.value };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitAssocSplatNode(this);
        }
    }

    // Represents reading a reference to a field in the previous match.
    // 
    //     $'
    //     ^^
    public static final class BackReferenceReadNode extends Node {

        public BackReferenceReadNode(int startOffset, int length) {
            super(startOffset, length);
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
        }

        public Node[] childNodes() {
            return EMPTY_ARRAY;
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitBackReferenceReadNode(this);
        }
    }

    // Represents a begin statement.
    // 
    //     begin
    //       foo
    //     end
    //     ^^^^^
    public static final class BeginNode extends Node {
        public final Location begin_keyword_loc; // optional
        public final StatementsNode statements; // optional
        public final RescueNode rescue_clause; // optional
        public final ElseNode else_clause; // optional
        public final EnsureNode ensure_clause; // optional
        public final Location end_keyword_loc; // optional

        public BeginNode(Location begin_keyword_loc, StatementsNode statements, RescueNode rescue_clause, ElseNode else_clause, EnsureNode ensure_clause, Location end_keyword_loc, int startOffset, int length) {
            super(startOffset, length);
            this.begin_keyword_loc = begin_keyword_loc;
            this.statements = statements;
            this.rescue_clause = rescue_clause;
            this.else_clause = else_clause;
            this.ensure_clause = ensure_clause;
            this.end_keyword_loc = end_keyword_loc;
        }
                
        @Override
        public void setNewLineFlag(Source source, boolean[] newlineMarked) {
            // Never mark BeginNode with a newline flag, mark children instead
        }

        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
            if (this.statements != null) {
                this.statements.accept(visitor);
            }
            if (this.rescue_clause != null) {
                this.rescue_clause.accept(visitor);
            }
            if (this.else_clause != null) {
                this.else_clause.accept(visitor);
            }
            if (this.ensure_clause != null) {
                this.ensure_clause.accept(visitor);
            }
        }

        public Node[] childNodes() {
            return new Node[] { this.statements, this.rescue_clause, this.else_clause, this.ensure_clause };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitBeginNode(this);
        }
    }

    // Represents block method arguments.
    // 
    //     bar(&args)
    //     ^^^^^^^^^^
    public static final class BlockArgumentNode extends Node {
        public final Node expression; // optional
        public final Location operator_loc;

        public BlockArgumentNode(Node expression, Location operator_loc, int startOffset, int length) {
            super(startOffset, length);
            this.expression = expression;
            this.operator_loc = operator_loc;
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
            if (this.expression != null) {
                this.expression.accept(visitor);
            }
        }

        public Node[] childNodes() {
            return new Node[] { this.expression };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitBlockArgumentNode(this);
        }
    }

    // Represents a block of ruby code.
    // 
    // [1, 2, 3].each { |i| puts x }
    //                ^^^^^^^^^^^^^^
    public static final class BlockNode extends Node {
        public final byte[][] locals;
        public final BlockParametersNode parameters; // optional
        public final Node body; // optional
        public final Location opening_loc;
        public final Location closing_loc;

        public BlockNode(byte[][] locals, BlockParametersNode parameters, Node body, Location opening_loc, Location closing_loc, int startOffset, int length) {
            super(startOffset, length);
            this.locals = locals;
            this.parameters = parameters;
            this.body = body;
            this.opening_loc = opening_loc;
            this.closing_loc = closing_loc;
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
            if (this.parameters != null) {
                this.parameters.accept(visitor);
            }
            if (this.body != null) {
                this.body.accept(visitor);
            }
        }

        public Node[] childNodes() {
            return new Node[] { this.parameters, this.body };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitBlockNode(this);
        }
    }

    // Represents a block parameter to a method, block, or lambda definition.
    // 
    //     def a(&b)
    //           ^^
    //     end
    public static final class BlockParameterNode extends Node {
        public final Location name_loc; // optional
        public final Location operator_loc;

        public BlockParameterNode(Location name_loc, Location operator_loc, int startOffset, int length) {
            super(startOffset, length);
            this.name_loc = name_loc;
            this.operator_loc = operator_loc;
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
        }

        public Node[] childNodes() {
            return EMPTY_ARRAY;
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitBlockParameterNode(this);
        }
    }

    // Represents a block's parameters declaration.
    // 
    //     -> (a, b = 1; local) { }
    //        ^^^^^^^^^^^^^^^^^
    // 
    //     foo do |a, b = 1; local|
    //            ^^^^^^^^^^^^^^^^^
    //     end
    public static final class BlockParametersNode extends Node {
        public final ParametersNode parameters; // optional
        public final Location[] locals;
        public final Location opening_loc; // optional
        public final Location closing_loc; // optional

        public BlockParametersNode(ParametersNode parameters, Location[] locals, Location opening_loc, Location closing_loc, int startOffset, int length) {
            super(startOffset, length);
            this.parameters = parameters;
            this.locals = locals;
            this.opening_loc = opening_loc;
            this.closing_loc = closing_loc;
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
            if (this.parameters != null) {
                this.parameters.accept(visitor);
            }
        }

        public Node[] childNodes() {
            return new Node[] { this.parameters };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitBlockParametersNode(this);
        }
    }

    // Represents the use of the `break` keyword.
    // 
    //     break foo
    //     ^^^^^^^^^
    public static final class BreakNode extends Node {
        public final ArgumentsNode arguments; // optional
        public final Location keyword_loc;

        public BreakNode(ArgumentsNode arguments, Location keyword_loc, int startOffset, int length) {
            super(startOffset, length);
            this.arguments = arguments;
            this.keyword_loc = keyword_loc;
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
            if (this.arguments != null) {
                this.arguments.accept(visitor);
            }
        }

        public Node[] childNodes() {
            return new Node[] { this.arguments };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitBreakNode(this);
        }
    }

    // Represents a method call, in all of the various forms that can take.
    // 
    //     foo
    //     ^^^
    // 
    //     foo()
    //     ^^^^^
    // 
    //     +foo
    //     ^^^^
    // 
    //     foo + bar
    //     ^^^^^^^^^
    // 
    //     foo.bar
    //     ^^^^^^^
    // 
    //     foo&.bar
    //     ^^^^^^^^
    public static final class CallNode extends Node {
        public final Node receiver; // optional
        public final Location operator_loc; // optional
        public final Location message_loc; // optional
        public final Location opening_loc; // optional
        public final ArgumentsNode arguments; // optional
        public final Location closing_loc; // optional
        public final BlockNode block; // optional
        public final short flags;
        public final byte[] name;

        public CallNode(Node receiver, Location operator_loc, Location message_loc, Location opening_loc, ArgumentsNode arguments, Location closing_loc, BlockNode block, short flags, byte[] name, int startOffset, int length) {
            super(startOffset, length);
            this.receiver = receiver;
            this.operator_loc = operator_loc;
            this.message_loc = message_loc;
            this.opening_loc = opening_loc;
            this.arguments = arguments;
            this.closing_loc = closing_loc;
            this.block = block;
            this.flags = flags;
            this.name = name;
        }
        
        public boolean isSafeNavigation() {
            return CallNodeFlags.isSafeNavigation(this.flags);
        }

        public boolean isVariableCall() {
            return CallNodeFlags.isVariableCall(this.flags);
        }
        
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
            if (this.receiver != null) {
                this.receiver.accept(visitor);
            }
            if (this.arguments != null) {
                this.arguments.accept(visitor);
            }
            if (this.block != null) {
                this.block.accept(visitor);
            }
        }

        public Node[] childNodes() {
            return new Node[] { this.receiver, this.arguments, this.block };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitCallNode(this);
        }
    }

    // Represents the use of the `&&=` operator on a call.
    // 
    //     foo.bar &&= value
    //     ^^^^^^^^^^^^^^^^^
    public static final class CallOperatorAndWriteNode extends Node {
        public final CallNode target;
        public final Location operator_loc;
        public final Node value;

        public CallOperatorAndWriteNode(CallNode target, Location operator_loc, Node value, int startOffset, int length) {
            super(startOffset, length);
            this.target = target;
            this.operator_loc = operator_loc;
            this.value = value;
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
            this.target.accept(visitor);
            this.value.accept(visitor);
        }

        public Node[] childNodes() {
            return new Node[] { this.target, this.value };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitCallOperatorAndWriteNode(this);
        }
    }

    // Represents the use of the `||=` operator on a call.
    // 
    //     foo.bar ||= value
    //     ^^^^^^^^^^^^^^^^^
    public static final class CallOperatorOrWriteNode extends Node {
        public final CallNode target;
        public final Node value;
        public final Location operator_loc;

        public CallOperatorOrWriteNode(CallNode target, Node value, Location operator_loc, int startOffset, int length) {
            super(startOffset, length);
            this.target = target;
            this.value = value;
            this.operator_loc = operator_loc;
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
            this.target.accept(visitor);
            this.value.accept(visitor);
        }

        public Node[] childNodes() {
            return new Node[] { this.target, this.value };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitCallOperatorOrWriteNode(this);
        }
    }

    // Represents the use of an assignment operator on a call.
    // 
    //     foo.bar += baz
    //     ^^^^^^^^^^^^^^
    public static final class CallOperatorWriteNode extends Node {
        public final CallNode target;
        public final Location operator_loc;
        public final Node value;
        public final byte[] operator;

        public CallOperatorWriteNode(CallNode target, Location operator_loc, Node value, byte[] operator, int startOffset, int length) {
            super(startOffset, length);
            this.target = target;
            this.operator_loc = operator_loc;
            this.value = value;
            this.operator = operator;
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
            this.target.accept(visitor);
            this.value.accept(visitor);
        }

        public Node[] childNodes() {
            return new Node[] { this.target, this.value };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitCallOperatorWriteNode(this);
        }
    }

    // Represents assigning to a local variable in pattern matching.
    // 
    //     foo => [bar => baz]
    //            ^^^^^^^^^^^^
    public static final class CapturePatternNode extends Node {
        public final Node value;
        public final Node target;
        public final Location operator_loc;

        public CapturePatternNode(Node value, Node target, Location operator_loc, int startOffset, int length) {
            super(startOffset, length);
            this.value = value;
            this.target = target;
            this.operator_loc = operator_loc;
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
            this.value.accept(visitor);
            this.target.accept(visitor);
        }

        public Node[] childNodes() {
            return new Node[] { this.value, this.target };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitCapturePatternNode(this);
        }
    }

    // Represents the use of a case statement.
    // 
    // case true
    // ^^^^^^^^^
    // when false
    // end
    public static final class CaseNode extends Node {
        public final Node predicate; // optional
        public final Node[] conditions;
        public final ElseNode consequent; // optional
        public final Location case_keyword_loc;
        public final Location end_keyword_loc;

        public CaseNode(Node predicate, Node[] conditions, ElseNode consequent, Location case_keyword_loc, Location end_keyword_loc, int startOffset, int length) {
            super(startOffset, length);
            this.predicate = predicate;
            this.conditions = conditions;
            this.consequent = consequent;
            this.case_keyword_loc = case_keyword_loc;
            this.end_keyword_loc = end_keyword_loc;
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
            if (this.predicate != null) {
                this.predicate.accept(visitor);
            }
            for (Nodes.Node child : this.conditions) {
                child.accept(visitor);
            }
            if (this.consequent != null) {
                this.consequent.accept(visitor);
            }
        }

        public Node[] childNodes() {
            ArrayList<Node> childNodes = new ArrayList<>();
            childNodes.add(this.predicate);
            childNodes.addAll(Arrays.asList(this.conditions));
            childNodes.add(this.consequent);
            return childNodes.toArray(EMPTY_ARRAY);
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitCaseNode(this);
        }
    }

    // Represents a class declaration involving the `class` keyword.
    // 
    //     class Foo end
    //     ^^^^^^^^^^^^^
    public static final class ClassNode extends Node {
        public final byte[][] locals;
        public final Location class_keyword_loc;
        public final Node constant_path;
        public final Location inheritance_operator_loc; // optional
        public final Node superclass; // optional
        public final Node body; // optional
        public final Location end_keyword_loc;
        public final byte[] name;

        public ClassNode(byte[][] locals, Location class_keyword_loc, Node constant_path, Location inheritance_operator_loc, Node superclass, Node body, Location end_keyword_loc, byte[] name, int startOffset, int length) {
            super(startOffset, length);
            this.locals = locals;
            this.class_keyword_loc = class_keyword_loc;
            this.constant_path = constant_path;
            this.inheritance_operator_loc = inheritance_operator_loc;
            this.superclass = superclass;
            this.body = body;
            this.end_keyword_loc = end_keyword_loc;
            this.name = name;
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
            this.constant_path.accept(visitor);
            if (this.superclass != null) {
                this.superclass.accept(visitor);
            }
            if (this.body != null) {
                this.body.accept(visitor);
            }
        }

        public Node[] childNodes() {
            return new Node[] { this.constant_path, this.superclass, this.body };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitClassNode(this);
        }
    }

    // Represents the use of the `&&=` operator for assignment to a class variable.
    // 
    //     @@target &&= value
    //     ^^^^^^^^^^^^^^^^
    public static final class ClassVariableAndWriteNode extends Node {
        public final Location name_loc;
        public final Location operator_loc;
        public final Node value;

        public ClassVariableAndWriteNode(Location name_loc, Location operator_loc, Node value, int startOffset, int length) {
            super(startOffset, length);
            this.name_loc = name_loc;
            this.operator_loc = operator_loc;
            this.value = value;
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
            this.value.accept(visitor);
        }

        public Node[] childNodes() {
            return new Node[] { this.value };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitClassVariableAndWriteNode(this);
        }
    }

    // Represents assigning to a class variable using an operator that isn't `=`.
    // 
    //     @@target += value
    //     ^^^^^^^^^^^^^^^^^
    public static final class ClassVariableOperatorWriteNode extends Node {
        public final Location name_loc;
        public final Location operator_loc;
        public final Node value;
        public final byte[] operator;

        public ClassVariableOperatorWriteNode(Location name_loc, Location operator_loc, Node value, byte[] operator, int startOffset, int length) {
            super(startOffset, length);
            this.name_loc = name_loc;
            this.operator_loc = operator_loc;
            this.value = value;
            this.operator = operator;
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
            this.value.accept(visitor);
        }

        public Node[] childNodes() {
            return new Node[] { this.value };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitClassVariableOperatorWriteNode(this);
        }
    }

    // Represents the use of the `||=` operator for assignment to a class variable.
    // 
    //     @@target ||= value
    //     ^^^^^^^^^^^^^^^^^^
    public static final class ClassVariableOrWriteNode extends Node {
        public final Location name_loc;
        public final Location operator_loc;
        public final Node value;

        public ClassVariableOrWriteNode(Location name_loc, Location operator_loc, Node value, int startOffset, int length) {
            super(startOffset, length);
            this.name_loc = name_loc;
            this.operator_loc = operator_loc;
            this.value = value;
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
            this.value.accept(visitor);
        }

        public Node[] childNodes() {
            return new Node[] { this.value };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitClassVariableOrWriteNode(this);
        }
    }

    // Represents referencing a class variable.
    // 
    //     @@foo
    //     ^^^^^
    public static final class ClassVariableReadNode extends Node {

        public ClassVariableReadNode(int startOffset, int length) {
            super(startOffset, length);
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
        }

        public Node[] childNodes() {
            return EMPTY_ARRAY;
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitClassVariableReadNode(this);
        }
    }

    // Represents writing to a class variable in a context that doesn't have an explicit value.
    // 
    //     @@foo, @@bar = baz
    //     ^^^^^  ^^^^^
    public static final class ClassVariableTargetNode extends Node {

        public ClassVariableTargetNode(int startOffset, int length) {
            super(startOffset, length);
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
        }

        public Node[] childNodes() {
            return EMPTY_ARRAY;
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitClassVariableTargetNode(this);
        }
    }

    // Represents writing to a class variable.
    // 
    //     @@foo = 1
    //     ^^^^^^^^^
    public static final class ClassVariableWriteNode extends Node {
        public final Location name_loc;
        public final Node value; // optional
        public final Location operator_loc; // optional

        public ClassVariableWriteNode(Location name_loc, Node value, Location operator_loc, int startOffset, int length) {
            super(startOffset, length);
            this.name_loc = name_loc;
            this.value = value;
            this.operator_loc = operator_loc;
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
            if (this.value != null) {
                this.value.accept(visitor);
            }
        }

        public Node[] childNodes() {
            return new Node[] { this.value };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitClassVariableWriteNode(this);
        }
    }

    // Represents the use of the `&&=` operator for assignment to a constant.
    // 
    //     Target &&= value
    //     ^^^^^^^^^^^^^^^^
    public static final class ConstantAndWriteNode extends Node {
        public final Location name_loc;
        public final Location operator_loc;
        public final Node value;

        public ConstantAndWriteNode(Location name_loc, Location operator_loc, Node value, int startOffset, int length) {
            super(startOffset, length);
            this.name_loc = name_loc;
            this.operator_loc = operator_loc;
            this.value = value;
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
            this.value.accept(visitor);
        }

        public Node[] childNodes() {
            return new Node[] { this.value };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitConstantAndWriteNode(this);
        }
    }

    // Represents assigning to a constant using an operator that isn't `=`.
    // 
    //     Target += value
    //     ^^^^^^^^^^^^^^^
    public static final class ConstantOperatorWriteNode extends Node {
        public final Location name_loc;
        public final Location operator_loc;
        public final Node value;
        public final byte[] operator;

        public ConstantOperatorWriteNode(Location name_loc, Location operator_loc, Node value, byte[] operator, int startOffset, int length) {
            super(startOffset, length);
            this.name_loc = name_loc;
            this.operator_loc = operator_loc;
            this.value = value;
            this.operator = operator;
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
            this.value.accept(visitor);
        }

        public Node[] childNodes() {
            return new Node[] { this.value };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitConstantOperatorWriteNode(this);
        }
    }

    // Represents the use of the `||=` operator for assignment to a constant.
    // 
    //     Target ||= value
    //     ^^^^^^^^^^^^^^^^
    public static final class ConstantOrWriteNode extends Node {
        public final Location name_loc;
        public final Location operator_loc;
        public final Node value;

        public ConstantOrWriteNode(Location name_loc, Location operator_loc, Node value, int startOffset, int length) {
            super(startOffset, length);
            this.name_loc = name_loc;
            this.operator_loc = operator_loc;
            this.value = value;
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
            this.value.accept(visitor);
        }

        public Node[] childNodes() {
            return new Node[] { this.value };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitConstantOrWriteNode(this);
        }
    }

    // Represents the use of the `&&=` operator for assignment to a constant path.
    // 
    //     Parent::Child &&= value
    //     ^^^^^^^^^^^^^^^^^^^^^^^
    public static final class ConstantPathAndWriteNode extends Node {
        public final ConstantPathNode target;
        public final Location operator_loc;
        public final Node value;

        public ConstantPathAndWriteNode(ConstantPathNode target, Location operator_loc, Node value, int startOffset, int length) {
            super(startOffset, length);
            this.target = target;
            this.operator_loc = operator_loc;
            this.value = value;
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
            this.target.accept(visitor);
            this.value.accept(visitor);
        }

        public Node[] childNodes() {
            return new Node[] { this.target, this.value };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitConstantPathAndWriteNode(this);
        }
    }

    // Represents accessing a constant through a path of `::` operators.
    // 
    //     Foo::Bar
    //     ^^^^^^^^
    public static final class ConstantPathNode extends Node {
        public final Node parent; // optional
        public final Node child;
        public final Location delimiter_loc;

        public ConstantPathNode(Node parent, Node child, Location delimiter_loc, int startOffset, int length) {
            super(startOffset, length);
            this.parent = parent;
            this.child = child;
            this.delimiter_loc = delimiter_loc;
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
            if (this.parent != null) {
                this.parent.accept(visitor);
            }
            this.child.accept(visitor);
        }

        public Node[] childNodes() {
            return new Node[] { this.parent, this.child };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitConstantPathNode(this);
        }
    }

    // Represents assigning to a constant path using an operator that isn't `=`.
    // 
    //     Parent::Child += value
    //     ^^^^^^^^^^^^^^^^^^^^^^
    public static final class ConstantPathOperatorWriteNode extends Node {
        public final ConstantPathNode target;
        public final Location operator_loc;
        public final Node value;
        public final byte[] operator;

        public ConstantPathOperatorWriteNode(ConstantPathNode target, Location operator_loc, Node value, byte[] operator, int startOffset, int length) {
            super(startOffset, length);
            this.target = target;
            this.operator_loc = operator_loc;
            this.value = value;
            this.operator = operator;
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
            this.target.accept(visitor);
            this.value.accept(visitor);
        }

        public Node[] childNodes() {
            return new Node[] { this.target, this.value };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitConstantPathOperatorWriteNode(this);
        }
    }

    // Represents the use of the `||=` operator for assignment to a constant path.
    // 
    //     Parent::Child ||= value
    //     ^^^^^^^^^^^^^^^^^^^^^^^
    public static final class ConstantPathOrWriteNode extends Node {
        public final ConstantPathNode target;
        public final Location operator_loc;
        public final Node value;

        public ConstantPathOrWriteNode(ConstantPathNode target, Location operator_loc, Node value, int startOffset, int length) {
            super(startOffset, length);
            this.target = target;
            this.operator_loc = operator_loc;
            this.value = value;
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
            this.target.accept(visitor);
            this.value.accept(visitor);
        }

        public Node[] childNodes() {
            return new Node[] { this.target, this.value };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitConstantPathOrWriteNode(this);
        }
    }

    // Represents writing to a constant path in a context that doesn't have an explicit value.
    // 
    //     Foo::Foo, Bar::Bar = baz
    //     ^^^^^^^^  ^^^^^^^^
    public static final class ConstantPathTargetNode extends Node {
        public final Node parent; // optional
        public final Node child;
        public final Location delimiter_loc;

        public ConstantPathTargetNode(Node parent, Node child, Location delimiter_loc, int startOffset, int length) {
            super(startOffset, length);
            this.parent = parent;
            this.child = child;
            this.delimiter_loc = delimiter_loc;
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
            if (this.parent != null) {
                this.parent.accept(visitor);
            }
            this.child.accept(visitor);
        }

        public Node[] childNodes() {
            return new Node[] { this.parent, this.child };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitConstantPathTargetNode(this);
        }
    }

    // Represents writing to a constant path.
    // 
    //     ::Foo = 1
    //     ^^^^^^^^^
    // 
    //     Foo::Bar = 1
    //     ^^^^^^^^^^^^
    // 
    //     ::Foo::Bar = 1
    //     ^^^^^^^^^^^^^^
    public static final class ConstantPathWriteNode extends Node {
        public final ConstantPathNode target;
        public final Location operator_loc;
        public final Node value;

        public ConstantPathWriteNode(ConstantPathNode target, Location operator_loc, Node value, int startOffset, int length) {
            super(startOffset, length);
            this.target = target;
            this.operator_loc = operator_loc;
            this.value = value;
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
            this.target.accept(visitor);
            this.value.accept(visitor);
        }

        public Node[] childNodes() {
            return new Node[] { this.target, this.value };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitConstantPathWriteNode(this);
        }
    }

    // Represents referencing a constant.
    // 
    //     Foo
    //     ^^^
    public static final class ConstantReadNode extends Node {

        public ConstantReadNode(int startOffset, int length) {
            super(startOffset, length);
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
        }

        public Node[] childNodes() {
            return EMPTY_ARRAY;
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitConstantReadNode(this);
        }
    }

    // Represents writing to a constant in a context that doesn't have an explicit value.
    // 
    //     Foo, Bar = baz
    //     ^^^  ^^^
    public static final class ConstantTargetNode extends Node {

        public ConstantTargetNode(int startOffset, int length) {
            super(startOffset, length);
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
        }

        public Node[] childNodes() {
            return EMPTY_ARRAY;
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitConstantTargetNode(this);
        }
    }

    // Represents writing to a constant.
    // 
    //     Foo = 1
    //     ^^^^^^^
    public static final class ConstantWriteNode extends Node {
        public final Location name_loc;
        public final Node value;
        public final Location operator_loc;

        public ConstantWriteNode(Location name_loc, Node value, Location operator_loc, int startOffset, int length) {
            super(startOffset, length);
            this.name_loc = name_loc;
            this.value = value;
            this.operator_loc = operator_loc;
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
            this.value.accept(visitor);
        }

        public Node[] childNodes() {
            return new Node[] { this.value };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitConstantWriteNode(this);
        }
    }

    // Represents a method definition.
    // 
    //     def method
    //     end
    //     ^^^^^^^^^^
    public static final class DefNode extends Node {
        public final int serializedLength;
        public final Location name_loc;
        public final Node receiver; // optional
        public final ParametersNode parameters; // optional
        public final Node body; // optional
        public final byte[][] locals;
        public final Location def_keyword_loc;
        public final Location operator_loc; // optional
        public final Location lparen_loc; // optional
        public final Location rparen_loc; // optional
        public final Location equal_loc; // optional
        public final Location end_keyword_loc; // optional

        public DefNode(int serializedLength, Location name_loc, Node receiver, ParametersNode parameters, Node body, byte[][] locals, Location def_keyword_loc, Location operator_loc, Location lparen_loc, Location rparen_loc, Location equal_loc, Location end_keyword_loc, int startOffset, int length) {
            super(startOffset, length);
            this.serializedLength = serializedLength;
            this.name_loc = name_loc;
            this.receiver = receiver;
            this.parameters = parameters;
            this.body = body;
            this.locals = locals;
            this.def_keyword_loc = def_keyword_loc;
            this.operator_loc = operator_loc;
            this.lparen_loc = lparen_loc;
            this.rparen_loc = rparen_loc;
            this.equal_loc = equal_loc;
            this.end_keyword_loc = end_keyword_loc;
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
            if (this.receiver != null) {
                this.receiver.accept(visitor);
            }
            if (this.parameters != null) {
                this.parameters.accept(visitor);
            }
            if (this.body != null) {
                this.body.accept(visitor);
            }
        }

        public Node[] childNodes() {
            return new Node[] { this.receiver, this.parameters, this.body };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitDefNode(this);
        }
    }

    // Represents the use of the `defined?` keyword.
    // 
    //     defined?(a)
    //     ^^^^^^^^^^^
    public static final class DefinedNode extends Node {
        public final Location lparen_loc; // optional
        public final Node value;
        public final Location rparen_loc; // optional
        public final Location keyword_loc;

        public DefinedNode(Location lparen_loc, Node value, Location rparen_loc, Location keyword_loc, int startOffset, int length) {
            super(startOffset, length);
            this.lparen_loc = lparen_loc;
            this.value = value;
            this.rparen_loc = rparen_loc;
            this.keyword_loc = keyword_loc;
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
            this.value.accept(visitor);
        }

        public Node[] childNodes() {
            return new Node[] { this.value };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitDefinedNode(this);
        }
    }

    // Represents an `else` clause in a `case`, `if`, or `unless` statement.
    // 
    //     if a then b else c end
    //                 ^^^^^^^^^^
    public static final class ElseNode extends Node {
        public final Location else_keyword_loc;
        public final StatementsNode statements; // optional
        public final Location end_keyword_loc; // optional

        public ElseNode(Location else_keyword_loc, StatementsNode statements, Location end_keyword_loc, int startOffset, int length) {
            super(startOffset, length);
            this.else_keyword_loc = else_keyword_loc;
            this.statements = statements;
            this.end_keyword_loc = end_keyword_loc;
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
            if (this.statements != null) {
                this.statements.accept(visitor);
            }
        }

        public Node[] childNodes() {
            return new Node[] { this.statements };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitElseNode(this);
        }
    }

    // Represents an interpolated set of statements.
    // 
    //     "foo #{bar}"
    //          ^^^^^^
    public static final class EmbeddedStatementsNode extends Node {
        public final Location opening_loc;
        public final StatementsNode statements; // optional
        public final Location closing_loc;

        public EmbeddedStatementsNode(Location opening_loc, StatementsNode statements, Location closing_loc, int startOffset, int length) {
            super(startOffset, length);
            this.opening_loc = opening_loc;
            this.statements = statements;
            this.closing_loc = closing_loc;
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
            if (this.statements != null) {
                this.statements.accept(visitor);
            }
        }

        public Node[] childNodes() {
            return new Node[] { this.statements };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitEmbeddedStatementsNode(this);
        }
    }

    // Represents an interpolated variable.
    // 
    //     "foo #@bar"
    //          ^^^^^
    public static final class EmbeddedVariableNode extends Node {
        public final Location operator_loc;
        public final Node variable;

        public EmbeddedVariableNode(Location operator_loc, Node variable, int startOffset, int length) {
            super(startOffset, length);
            this.operator_loc = operator_loc;
            this.variable = variable;
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
            this.variable.accept(visitor);
        }

        public Node[] childNodes() {
            return new Node[] { this.variable };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitEmbeddedVariableNode(this);
        }
    }

    // Represents an `ensure` clause in a `begin` statement.
    // 
    //     begin
    //       foo
    //     ensure
    //     ^^^^^^
    //       bar
    //     end
    public static final class EnsureNode extends Node {
        public final Location ensure_keyword_loc;
        public final StatementsNode statements; // optional
        public final Location end_keyword_loc;

        public EnsureNode(Location ensure_keyword_loc, StatementsNode statements, Location end_keyword_loc, int startOffset, int length) {
            super(startOffset, length);
            this.ensure_keyword_loc = ensure_keyword_loc;
            this.statements = statements;
            this.end_keyword_loc = end_keyword_loc;
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
            if (this.statements != null) {
                this.statements.accept(visitor);
            }
        }

        public Node[] childNodes() {
            return new Node[] { this.statements };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitEnsureNode(this);
        }
    }

    // Represents the use of the literal `false` keyword.
    // 
    //     false
    //     ^^^^^
    public static final class FalseNode extends Node {

        public FalseNode(int startOffset, int length) {
            super(startOffset, length);
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
        }

        public Node[] childNodes() {
            return EMPTY_ARRAY;
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitFalseNode(this);
        }
    }

    // Represents a find pattern in pattern matching.
    // 
    //     foo in *bar, baz, *qux
    //     ^^^^^^^^^^^^^^^^^^^^^^
    // 
    //     foo in [*bar, baz, *qux]
    //     ^^^^^^^^^^^^^^^^^^^^^^^^
    // 
    //     foo in Foo(*bar, baz, *qux)
    //     ^^^^^^^^^^^^^^^^^^^^^^^^^^^
    public static final class FindPatternNode extends Node {
        public final Node constant; // optional
        public final Node left;
        public final Node[] requireds;
        public final Node right;
        public final Location opening_loc; // optional
        public final Location closing_loc; // optional

        public FindPatternNode(Node constant, Node left, Node[] requireds, Node right, Location opening_loc, Location closing_loc, int startOffset, int length) {
            super(startOffset, length);
            this.constant = constant;
            this.left = left;
            this.requireds = requireds;
            this.right = right;
            this.opening_loc = opening_loc;
            this.closing_loc = closing_loc;
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
            if (this.constant != null) {
                this.constant.accept(visitor);
            }
            this.left.accept(visitor);
            for (Nodes.Node child : this.requireds) {
                child.accept(visitor);
            }
            this.right.accept(visitor);
        }

        public Node[] childNodes() {
            ArrayList<Node> childNodes = new ArrayList<>();
            childNodes.add(this.constant);
            childNodes.add(this.left);
            childNodes.addAll(Arrays.asList(this.requireds));
            childNodes.add(this.right);
            return childNodes.toArray(EMPTY_ARRAY);
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitFindPatternNode(this);
        }
    }

    // Represents the use of the `..` or `...` operators to create flip flops.
    // 
    //     baz if foo .. bar
    //            ^^^^^^^^^^
    public static final class FlipFlopNode extends Node {
        public final Node left; // optional
        public final Node right; // optional
        public final Location operator_loc;
        public final short flags;

        public FlipFlopNode(Node left, Node right, Location operator_loc, short flags, int startOffset, int length) {
            super(startOffset, length);
            this.left = left;
            this.right = right;
            this.operator_loc = operator_loc;
            this.flags = flags;
        }
        
        public boolean isExcludeEnd() {
            return RangeFlags.isExcludeEnd(this.flags);
        }
        
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
            if (this.left != null) {
                this.left.accept(visitor);
            }
            if (this.right != null) {
                this.right.accept(visitor);
            }
        }

        public Node[] childNodes() {
            return new Node[] { this.left, this.right };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitFlipFlopNode(this);
        }
    }

    // Represents a floating point number literal.
    // 
    //     1.0
    //     ^^^
    public static final class FloatNode extends Node {

        public FloatNode(int startOffset, int length) {
            super(startOffset, length);
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
        }

        public Node[] childNodes() {
            return EMPTY_ARRAY;
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitFloatNode(this);
        }
    }

    // Represents the use of the `for` keyword.
    // 
    //     for i in a end
    //     ^^^^^^^^^^^^^^
    public static final class ForNode extends Node {
        public final Node index;
        public final Node collection;
        public final StatementsNode statements; // optional
        public final Location for_keyword_loc;
        public final Location in_keyword_loc;
        public final Location do_keyword_loc; // optional
        public final Location end_keyword_loc;

        public ForNode(Node index, Node collection, StatementsNode statements, Location for_keyword_loc, Location in_keyword_loc, Location do_keyword_loc, Location end_keyword_loc, int startOffset, int length) {
            super(startOffset, length);
            this.index = index;
            this.collection = collection;
            this.statements = statements;
            this.for_keyword_loc = for_keyword_loc;
            this.in_keyword_loc = in_keyword_loc;
            this.do_keyword_loc = do_keyword_loc;
            this.end_keyword_loc = end_keyword_loc;
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
            this.index.accept(visitor);
            this.collection.accept(visitor);
            if (this.statements != null) {
                this.statements.accept(visitor);
            }
        }

        public Node[] childNodes() {
            return new Node[] { this.index, this.collection, this.statements };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitForNode(this);
        }
    }

    // Represents forwarding all arguments to this method to another method.
    // 
    //     def foo(...)
    //       bar(...)
    //       ^^^^^^^^
    //     end
    public static final class ForwardingArgumentsNode extends Node {

        public ForwardingArgumentsNode(int startOffset, int length) {
            super(startOffset, length);
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
        }

        public Node[] childNodes() {
            return EMPTY_ARRAY;
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitForwardingArgumentsNode(this);
        }
    }

    // Represents the use of the forwarding parameter in a method, block, or lambda declaration.
    // 
    //     def foo(...)
    //             ^^^
    //     end
    public static final class ForwardingParameterNode extends Node {

        public ForwardingParameterNode(int startOffset, int length) {
            super(startOffset, length);
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
        }

        public Node[] childNodes() {
            return EMPTY_ARRAY;
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitForwardingParameterNode(this);
        }
    }

    // Represents the use of the `super` keyword without parentheses or arguments.
    // 
    //     super
    //     ^^^^^
    public static final class ForwardingSuperNode extends Node {
        public final BlockNode block; // optional

        public ForwardingSuperNode(BlockNode block, int startOffset, int length) {
            super(startOffset, length);
            this.block = block;
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
            if (this.block != null) {
                this.block.accept(visitor);
            }
        }

        public Node[] childNodes() {
            return new Node[] { this.block };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitForwardingSuperNode(this);
        }
    }

    // Represents the use of the `&&=` operator for assignment to a global variable.
    // 
    //     $target &&= value
    //     ^^^^^^^^^^^^^^^^^
    public static final class GlobalVariableAndWriteNode extends Node {
        public final Location name_loc;
        public final Location operator_loc;
        public final Node value;

        public GlobalVariableAndWriteNode(Location name_loc, Location operator_loc, Node value, int startOffset, int length) {
            super(startOffset, length);
            this.name_loc = name_loc;
            this.operator_loc = operator_loc;
            this.value = value;
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
            this.value.accept(visitor);
        }

        public Node[] childNodes() {
            return new Node[] { this.value };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitGlobalVariableAndWriteNode(this);
        }
    }

    // Represents assigning to a global variable using an operator that isn't `=`.
    // 
    //     $target += value
    //     ^^^^^^^^^^^^^^^^
    public static final class GlobalVariableOperatorWriteNode extends Node {
        public final Location name_loc;
        public final Location operator_loc;
        public final Node value;
        public final byte[] operator;

        public GlobalVariableOperatorWriteNode(Location name_loc, Location operator_loc, Node value, byte[] operator, int startOffset, int length) {
            super(startOffset, length);
            this.name_loc = name_loc;
            this.operator_loc = operator_loc;
            this.value = value;
            this.operator = operator;
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
            this.value.accept(visitor);
        }

        public Node[] childNodes() {
            return new Node[] { this.value };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitGlobalVariableOperatorWriteNode(this);
        }
    }

    // Represents the use of the `||=` operator for assignment to a global variable.
    // 
    //     $target ||= value
    //     ^^^^^^^^^^^^^^^^^
    public static final class GlobalVariableOrWriteNode extends Node {
        public final Location name_loc;
        public final Location operator_loc;
        public final Node value;

        public GlobalVariableOrWriteNode(Location name_loc, Location operator_loc, Node value, int startOffset, int length) {
            super(startOffset, length);
            this.name_loc = name_loc;
            this.operator_loc = operator_loc;
            this.value = value;
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
            this.value.accept(visitor);
        }

        public Node[] childNodes() {
            return new Node[] { this.value };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitGlobalVariableOrWriteNode(this);
        }
    }

    // Represents referencing a global variable.
    // 
    //     $foo
    //     ^^^^
    public static final class GlobalVariableReadNode extends Node {

        public GlobalVariableReadNode(int startOffset, int length) {
            super(startOffset, length);
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
        }

        public Node[] childNodes() {
            return EMPTY_ARRAY;
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitGlobalVariableReadNode(this);
        }
    }

    // Represents writing to a global variable in a context that doesn't have an explicit value.
    // 
    //     $foo, $bar = baz
    //     ^^^^  ^^^^
    public static final class GlobalVariableTargetNode extends Node {

        public GlobalVariableTargetNode(int startOffset, int length) {
            super(startOffset, length);
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
        }

        public Node[] childNodes() {
            return EMPTY_ARRAY;
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitGlobalVariableTargetNode(this);
        }
    }

    // Represents writing to a global variable.
    // 
    //     $foo = 1
    //     ^^^^^^^^
    public static final class GlobalVariableWriteNode extends Node {
        public final Location name_loc;
        public final Location operator_loc;
        public final Node value;

        public GlobalVariableWriteNode(Location name_loc, Location operator_loc, Node value, int startOffset, int length) {
            super(startOffset, length);
            this.name_loc = name_loc;
            this.operator_loc = operator_loc;
            this.value = value;
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
            this.value.accept(visitor);
        }

        public Node[] childNodes() {
            return new Node[] { this.value };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitGlobalVariableWriteNode(this);
        }
    }

    // Represents a hash literal.
    // 
    //     { a => b }
    //     ^^^^^^^^^^
    public static final class HashNode extends Node {
        public final Location opening_loc;
        public final Node[] elements;
        public final Location closing_loc;

        public HashNode(Location opening_loc, Node[] elements, Location closing_loc, int startOffset, int length) {
            super(startOffset, length);
            this.opening_loc = opening_loc;
            this.elements = elements;
            this.closing_loc = closing_loc;
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
            for (Nodes.Node child : this.elements) {
                child.accept(visitor);
            }
        }

        public Node[] childNodes() {
            return this.elements;
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitHashNode(this);
        }
    }

    // Represents a hash pattern in pattern matching.
    // 
    //     foo => { a: 1, b: 2 }
    //            ^^^^^^^^^^^^^^
    // 
    //     foo => { a: 1, b: 2, **c }
    //            ^^^^^^^^^^^^^^^^^^^
    public static final class HashPatternNode extends Node {
        public final Node constant; // optional
        public final Node[] assocs;
        public final Node kwrest; // optional
        public final Location opening_loc; // optional
        public final Location closing_loc; // optional

        public HashPatternNode(Node constant, Node[] assocs, Node kwrest, Location opening_loc, Location closing_loc, int startOffset, int length) {
            super(startOffset, length);
            this.constant = constant;
            this.assocs = assocs;
            this.kwrest = kwrest;
            this.opening_loc = opening_loc;
            this.closing_loc = closing_loc;
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
            if (this.constant != null) {
                this.constant.accept(visitor);
            }
            for (Nodes.Node child : this.assocs) {
                child.accept(visitor);
            }
            if (this.kwrest != null) {
                this.kwrest.accept(visitor);
            }
        }

        public Node[] childNodes() {
            ArrayList<Node> childNodes = new ArrayList<>();
            childNodes.add(this.constant);
            childNodes.addAll(Arrays.asList(this.assocs));
            childNodes.add(this.kwrest);
            return childNodes.toArray(EMPTY_ARRAY);
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitHashPatternNode(this);
        }
    }

    // Represents the use of the `if` keyword, either in the block form or the modifier form.
    // 
    //     bar if foo
    //     ^^^^^^^^^^
    // 
    //     if foo then bar end
    //     ^^^^^^^^^^^^^^^^^^^
    public static final class IfNode extends Node {
        public final Location if_keyword_loc; // optional
        public final Node predicate;
        public final StatementsNode statements; // optional
        public final Node consequent; // optional
        public final Location end_keyword_loc; // optional

        public IfNode(Location if_keyword_loc, Node predicate, StatementsNode statements, Node consequent, Location end_keyword_loc, int startOffset, int length) {
            super(startOffset, length);
            this.if_keyword_loc = if_keyword_loc;
            this.predicate = predicate;
            this.statements = statements;
            this.consequent = consequent;
            this.end_keyword_loc = end_keyword_loc;
        }
                
        @Override
        public void setNewLineFlag(Source source, boolean[] newlineMarked) {
            this.predicate.setNewLineFlag(source, newlineMarked);
        }

        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
            this.predicate.accept(visitor);
            if (this.statements != null) {
                this.statements.accept(visitor);
            }
            if (this.consequent != null) {
                this.consequent.accept(visitor);
            }
        }

        public Node[] childNodes() {
            return new Node[] { this.predicate, this.statements, this.consequent };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitIfNode(this);
        }
    }

    // Represents an imaginary number literal.
    // 
    //     1.0i
    //     ^^^^
    public static final class ImaginaryNode extends Node {
        public final Node numeric;

        public ImaginaryNode(Node numeric, int startOffset, int length) {
            super(startOffset, length);
            this.numeric = numeric;
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
            this.numeric.accept(visitor);
        }

        public Node[] childNodes() {
            return new Node[] { this.numeric };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitImaginaryNode(this);
        }
    }

    // Represents the use of the `in` keyword in a case statement.
    // 
    //     case a; in b then c end
    //             ^^^^^^^^^^^
    public static final class InNode extends Node {
        public final Node pattern;
        public final StatementsNode statements; // optional
        public final Location in_loc;
        public final Location then_loc; // optional

        public InNode(Node pattern, StatementsNode statements, Location in_loc, Location then_loc, int startOffset, int length) {
            super(startOffset, length);
            this.pattern = pattern;
            this.statements = statements;
            this.in_loc = in_loc;
            this.then_loc = then_loc;
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
            this.pattern.accept(visitor);
            if (this.statements != null) {
                this.statements.accept(visitor);
            }
        }

        public Node[] childNodes() {
            return new Node[] { this.pattern, this.statements };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitInNode(this);
        }
    }

    // Represents the use of the `&&=` operator for assignment to an instance variable.
    // 
    //     @target &&= value
    //     ^^^^^^^^^^^^^^^^^
    public static final class InstanceVariableAndWriteNode extends Node {
        public final Location name_loc;
        public final Location operator_loc;
        public final Node value;

        public InstanceVariableAndWriteNode(Location name_loc, Location operator_loc, Node value, int startOffset, int length) {
            super(startOffset, length);
            this.name_loc = name_loc;
            this.operator_loc = operator_loc;
            this.value = value;
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
            this.value.accept(visitor);
        }

        public Node[] childNodes() {
            return new Node[] { this.value };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitInstanceVariableAndWriteNode(this);
        }
    }

    // Represents assigning to an instance variable using an operator that isn't `=`.
    // 
    //     @target += value
    //     ^^^^^^^^^^^^^^^^
    public static final class InstanceVariableOperatorWriteNode extends Node {
        public final Location name_loc;
        public final Location operator_loc;
        public final Node value;
        public final byte[] operator;

        public InstanceVariableOperatorWriteNode(Location name_loc, Location operator_loc, Node value, byte[] operator, int startOffset, int length) {
            super(startOffset, length);
            this.name_loc = name_loc;
            this.operator_loc = operator_loc;
            this.value = value;
            this.operator = operator;
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
            this.value.accept(visitor);
        }

        public Node[] childNodes() {
            return new Node[] { this.value };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitInstanceVariableOperatorWriteNode(this);
        }
    }

    // Represents the use of the `||=` operator for assignment to an instance variable.
    // 
    //     @target ||= value
    //     ^^^^^^^^^^^^^^^^^
    public static final class InstanceVariableOrWriteNode extends Node {
        public final Location name_loc;
        public final Location operator_loc;
        public final Node value;

        public InstanceVariableOrWriteNode(Location name_loc, Location operator_loc, Node value, int startOffset, int length) {
            super(startOffset, length);
            this.name_loc = name_loc;
            this.operator_loc = operator_loc;
            this.value = value;
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
            this.value.accept(visitor);
        }

        public Node[] childNodes() {
            return new Node[] { this.value };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitInstanceVariableOrWriteNode(this);
        }
    }

    // Represents referencing an instance variable.
    // 
    //     @foo
    //     ^^^^
    public static final class InstanceVariableReadNode extends Node {

        public InstanceVariableReadNode(int startOffset, int length) {
            super(startOffset, length);
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
        }

        public Node[] childNodes() {
            return EMPTY_ARRAY;
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitInstanceVariableReadNode(this);
        }
    }

    // Represents writing to an instance variable in a context that doesn't have an explicit value.
    // 
    //     @foo, @bar = baz
    //     ^^^^  ^^^^
    public static final class InstanceVariableTargetNode extends Node {

        public InstanceVariableTargetNode(int startOffset, int length) {
            super(startOffset, length);
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
        }

        public Node[] childNodes() {
            return EMPTY_ARRAY;
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitInstanceVariableTargetNode(this);
        }
    }

    // Represents writing to an instance variable.
    // 
    //     @foo = 1
    //     ^^^^^^^^
    public static final class InstanceVariableWriteNode extends Node {
        public final Location name_loc;
        public final Node value;
        public final Location operator_loc;

        public InstanceVariableWriteNode(Location name_loc, Node value, Location operator_loc, int startOffset, int length) {
            super(startOffset, length);
            this.name_loc = name_loc;
            this.value = value;
            this.operator_loc = operator_loc;
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
            this.value.accept(visitor);
        }

        public Node[] childNodes() {
            return new Node[] { this.value };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitInstanceVariableWriteNode(this);
        }
    }

    // Represents an integer number literal.
    // 
    //     1
    //     ^
    public static final class IntegerNode extends Node {

        public IntegerNode(int startOffset, int length) {
            super(startOffset, length);
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
        }

        public Node[] childNodes() {
            return EMPTY_ARRAY;
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitIntegerNode(this);
        }
    }

    // Represents a regular expression literal that contains interpolation.
    // 
    //     /foo #{bar} baz/
    //     ^^^^^^^^^^^^^^^^
    public static final class InterpolatedRegularExpressionNode extends Node {
        public final Location opening_loc;
        public final Node[] parts;
        public final Location closing_loc;
        public final short flags;

        public InterpolatedRegularExpressionNode(Location opening_loc, Node[] parts, Location closing_loc, short flags, int startOffset, int length) {
            super(startOffset, length);
            this.opening_loc = opening_loc;
            this.parts = parts;
            this.closing_loc = closing_loc;
            this.flags = flags;
        }
        
        public boolean isIgnoreCase() {
            return RegularExpressionFlags.isIgnoreCase(this.flags);
        }

        public boolean isMultiLine() {
            return RegularExpressionFlags.isMultiLine(this.flags);
        }

        public boolean isExtended() {
            return RegularExpressionFlags.isExtended(this.flags);
        }

        public boolean isEucJp() {
            return RegularExpressionFlags.isEucJp(this.flags);
        }

        public boolean isAscii8bit() {
            return RegularExpressionFlags.isAscii8bit(this.flags);
        }

        public boolean isWindows31j() {
            return RegularExpressionFlags.isWindows31j(this.flags);
        }

        public boolean isUtf8() {
            return RegularExpressionFlags.isUtf8(this.flags);
        }

        public boolean isOnce() {
            return RegularExpressionFlags.isOnce(this.flags);
        }
        
        @Override
        public void setNewLineFlag(Source source, boolean[] newlineMarked) {
            Node first = this.parts.length > 0 ? this.parts[0] : null;
            if (first != null) {
                first.setNewLineFlag(source, newlineMarked);
            }
        }

        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
            for (Nodes.Node child : this.parts) {
                child.accept(visitor);
            }
        }

        public Node[] childNodes() {
            return this.parts;
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitInterpolatedRegularExpressionNode(this);
        }
    }

    // Represents a string literal that contains interpolation.
    // 
    //     "foo #{bar} baz"
    //     ^^^^^^^^^^^^^^^^
    public static final class InterpolatedStringNode extends Node {
        public final Location opening_loc; // optional
        public final Node[] parts;
        public final Location closing_loc; // optional

        public InterpolatedStringNode(Location opening_loc, Node[] parts, Location closing_loc, int startOffset, int length) {
            super(startOffset, length);
            this.opening_loc = opening_loc;
            this.parts = parts;
            this.closing_loc = closing_loc;
        }
                
        @Override
        public void setNewLineFlag(Source source, boolean[] newlineMarked) {
            Node first = this.parts.length > 0 ? this.parts[0] : null;
            if (first != null) {
                first.setNewLineFlag(source, newlineMarked);
            }
        }

        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
            for (Nodes.Node child : this.parts) {
                child.accept(visitor);
            }
        }

        public Node[] childNodes() {
            return this.parts;
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitInterpolatedStringNode(this);
        }
    }

    // Represents a symbol literal that contains interpolation.
    // 
    //     :"foo #{bar} baz"
    //     ^^^^^^^^^^^^^^^^^
    public static final class InterpolatedSymbolNode extends Node {
        public final Location opening_loc; // optional
        public final Node[] parts;
        public final Location closing_loc; // optional

        public InterpolatedSymbolNode(Location opening_loc, Node[] parts, Location closing_loc, int startOffset, int length) {
            super(startOffset, length);
            this.opening_loc = opening_loc;
            this.parts = parts;
            this.closing_loc = closing_loc;
        }
                
        @Override
        public void setNewLineFlag(Source source, boolean[] newlineMarked) {
            Node first = this.parts.length > 0 ? this.parts[0] : null;
            if (first != null) {
                first.setNewLineFlag(source, newlineMarked);
            }
        }

        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
            for (Nodes.Node child : this.parts) {
                child.accept(visitor);
            }
        }

        public Node[] childNodes() {
            return this.parts;
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitInterpolatedSymbolNode(this);
        }
    }

    // Represents an xstring literal that contains interpolation.
    // 
    //     `foo #{bar} baz`
    //     ^^^^^^^^^^^^^^^^
    public static final class InterpolatedXStringNode extends Node {
        public final Location opening_loc;
        public final Node[] parts;
        public final Location closing_loc;

        public InterpolatedXStringNode(Location opening_loc, Node[] parts, Location closing_loc, int startOffset, int length) {
            super(startOffset, length);
            this.opening_loc = opening_loc;
            this.parts = parts;
            this.closing_loc = closing_loc;
        }
                
        @Override
        public void setNewLineFlag(Source source, boolean[] newlineMarked) {
            Node first = this.parts.length > 0 ? this.parts[0] : null;
            if (first != null) {
                first.setNewLineFlag(source, newlineMarked);
            }
        }

        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
            for (Nodes.Node child : this.parts) {
                child.accept(visitor);
            }
        }

        public Node[] childNodes() {
            return this.parts;
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitInterpolatedXStringNode(this);
        }
    }

    // Represents a hash literal without opening and closing braces.
    // 
    //     foo(a: b)
    //         ^^^^
    public static final class KeywordHashNode extends Node {
        public final Node[] elements;

        public KeywordHashNode(Node[] elements, int startOffset, int length) {
            super(startOffset, length);
            this.elements = elements;
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
            for (Nodes.Node child : this.elements) {
                child.accept(visitor);
            }
        }

        public Node[] childNodes() {
            return this.elements;
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitKeywordHashNode(this);
        }
    }

    // Represents a keyword parameter to a method, block, or lambda definition.
    // 
    //     def a(b:)
    //           ^^
    //     end
    // 
    //     def a(b: 1)
    //           ^^^^
    //     end
    public static final class KeywordParameterNode extends Node {
        public final Location name_loc;
        public final Node value; // optional

        public KeywordParameterNode(Location name_loc, Node value, int startOffset, int length) {
            super(startOffset, length);
            this.name_loc = name_loc;
            this.value = value;
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
            if (this.value != null) {
                this.value.accept(visitor);
            }
        }

        public Node[] childNodes() {
            return new Node[] { this.value };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitKeywordParameterNode(this);
        }
    }

    // Represents a keyword rest parameter to a method, block, or lambda definition.
    // 
    //     def a(**b)
    //           ^^^
    //     end
    public static final class KeywordRestParameterNode extends Node {
        public final Location operator_loc;
        public final Location name_loc; // optional

        public KeywordRestParameterNode(Location operator_loc, Location name_loc, int startOffset, int length) {
            super(startOffset, length);
            this.operator_loc = operator_loc;
            this.name_loc = name_loc;
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
        }

        public Node[] childNodes() {
            return EMPTY_ARRAY;
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitKeywordRestParameterNode(this);
        }
    }

    // Represents using a lambda literal (not the lambda method call).
    // 
    //     ->(value) { value * 2 }
    //     ^^^^^^^^^^^^^^^^^^^^^^^
    public static final class LambdaNode extends Node {
        public final byte[][] locals;
        public final Location operator_loc;
        public final Location opening_loc;
        public final Location closing_loc;
        public final BlockParametersNode parameters; // optional
        public final Node body; // optional

        public LambdaNode(byte[][] locals, Location operator_loc, Location opening_loc, Location closing_loc, BlockParametersNode parameters, Node body, int startOffset, int length) {
            super(startOffset, length);
            this.locals = locals;
            this.operator_loc = operator_loc;
            this.opening_loc = opening_loc;
            this.closing_loc = closing_loc;
            this.parameters = parameters;
            this.body = body;
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
            if (this.parameters != null) {
                this.parameters.accept(visitor);
            }
            if (this.body != null) {
                this.body.accept(visitor);
            }
        }

        public Node[] childNodes() {
            return new Node[] { this.parameters, this.body };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitLambdaNode(this);
        }
    }

    // Represents the use of the `&&=` operator for assignment to a local variable.
    // 
    //     target &&= value
    //     ^^^^^^^^^^^^^^^^
    public static final class LocalVariableAndWriteNode extends Node {
        public final Location name_loc;
        public final Location operator_loc;
        public final Node value;
        public final byte[] name;
        public final int depth;

        public LocalVariableAndWriteNode(Location name_loc, Location operator_loc, Node value, byte[] name, int depth, int startOffset, int length) {
            super(startOffset, length);
            this.name_loc = name_loc;
            this.operator_loc = operator_loc;
            this.value = value;
            this.name = name;
            this.depth = depth;
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
            this.value.accept(visitor);
        }

        public Node[] childNodes() {
            return new Node[] { this.value };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitLocalVariableAndWriteNode(this);
        }
    }

    // Represents assigning to a local variable using an operator that isn't `=`.
    // 
    //     target += value
    //     ^^^^^^^^^^^^^^^
    public static final class LocalVariableOperatorWriteNode extends Node {
        public final Location name_loc;
        public final Location operator_loc;
        public final Node value;
        public final byte[] name;
        public final byte[] operator;
        public final int depth;

        public LocalVariableOperatorWriteNode(Location name_loc, Location operator_loc, Node value, byte[] name, byte[] operator, int depth, int startOffset, int length) {
            super(startOffset, length);
            this.name_loc = name_loc;
            this.operator_loc = operator_loc;
            this.value = value;
            this.name = name;
            this.operator = operator;
            this.depth = depth;
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
            this.value.accept(visitor);
        }

        public Node[] childNodes() {
            return new Node[] { this.value };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitLocalVariableOperatorWriteNode(this);
        }
    }

    // Represents the use of the `||=` operator for assignment to a local variable.
    // 
    //     target ||= value
    //     ^^^^^^^^^^^^^^^^
    public static final class LocalVariableOrWriteNode extends Node {
        public final Location name_loc;
        public final Location operator_loc;
        public final Node value;
        public final byte[] name;
        public final int depth;

        public LocalVariableOrWriteNode(Location name_loc, Location operator_loc, Node value, byte[] name, int depth, int startOffset, int length) {
            super(startOffset, length);
            this.name_loc = name_loc;
            this.operator_loc = operator_loc;
            this.value = value;
            this.name = name;
            this.depth = depth;
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
            this.value.accept(visitor);
        }

        public Node[] childNodes() {
            return new Node[] { this.value };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitLocalVariableOrWriteNode(this);
        }
    }

    // Represents reading a local variable. Note that this requires that a local
    // variable of the same name has already been written to in the same scope,
    // otherwise it is parsed as a method call.
    // 
    //     foo
    //     ^^^
    public static final class LocalVariableReadNode extends Node {
        public final byte[] name;
        public final int depth;

        public LocalVariableReadNode(byte[] name, int depth, int startOffset, int length) {
            super(startOffset, length);
            this.name = name;
            this.depth = depth;
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
        }

        public Node[] childNodes() {
            return EMPTY_ARRAY;
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitLocalVariableReadNode(this);
        }
    }

    // Represents writing to a local variable in a context that doesn't have an explicit value.
    // 
    //     foo, bar = baz
    //     ^^^  ^^^
    public static final class LocalVariableTargetNode extends Node {
        public final byte[] name;
        public final int depth;

        public LocalVariableTargetNode(byte[] name, int depth, int startOffset, int length) {
            super(startOffset, length);
            this.name = name;
            this.depth = depth;
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
        }

        public Node[] childNodes() {
            return EMPTY_ARRAY;
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitLocalVariableTargetNode(this);
        }
    }

    // Represents writing to a local variable.
    // 
    //     foo = 1
    //     ^^^^^^^
    public static final class LocalVariableWriteNode extends Node {
        public final byte[] name;
        public final int depth;
        public final Node value;
        public final Location name_loc;
        public final Location operator_loc;

        public LocalVariableWriteNode(byte[] name, int depth, Node value, Location name_loc, Location operator_loc, int startOffset, int length) {
            super(startOffset, length);
            this.name = name;
            this.depth = depth;
            this.value = value;
            this.name_loc = name_loc;
            this.operator_loc = operator_loc;
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
            this.value.accept(visitor);
        }

        public Node[] childNodes() {
            return new Node[] { this.value };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitLocalVariableWriteNode(this);
        }
    }

    // Represents the use of the modifier `in` operator.
    // 
    //     foo in bar
    //     ^^^^^^^^^^
    public static final class MatchPredicateNode extends Node {
        public final Node value;
        public final Node pattern;
        public final Location operator_loc;

        public MatchPredicateNode(Node value, Node pattern, Location operator_loc, int startOffset, int length) {
            super(startOffset, length);
            this.value = value;
            this.pattern = pattern;
            this.operator_loc = operator_loc;
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
            this.value.accept(visitor);
            this.pattern.accept(visitor);
        }

        public Node[] childNodes() {
            return new Node[] { this.value, this.pattern };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitMatchPredicateNode(this);
        }
    }

    // Represents the use of the `=>` operator.
    // 
    //     foo => bar
    //     ^^^^^^^^^^
    public static final class MatchRequiredNode extends Node {
        public final Node value;
        public final Node pattern;
        public final Location operator_loc;

        public MatchRequiredNode(Node value, Node pattern, Location operator_loc, int startOffset, int length) {
            super(startOffset, length);
            this.value = value;
            this.pattern = pattern;
            this.operator_loc = operator_loc;
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
            this.value.accept(visitor);
            this.pattern.accept(visitor);
        }

        public Node[] childNodes() {
            return new Node[] { this.value, this.pattern };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitMatchRequiredNode(this);
        }
    }

    // Represents a node that is missing from the source and results in a syntax
    // error.
    public static final class MissingNode extends Node {

        public MissingNode(int startOffset, int length) {
            super(startOffset, length);
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
        }

        public Node[] childNodes() {
            return EMPTY_ARRAY;
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitMissingNode(this);
        }
    }

    // Represents a module declaration involving the `module` keyword.
    // 
    //     module Foo end
    //     ^^^^^^^^^^^^^^
    public static final class ModuleNode extends Node {
        public final byte[][] locals;
        public final Location module_keyword_loc;
        public final Node constant_path;
        public final Node body; // optional
        public final Location end_keyword_loc;
        public final byte[] name;

        public ModuleNode(byte[][] locals, Location module_keyword_loc, Node constant_path, Node body, Location end_keyword_loc, byte[] name, int startOffset, int length) {
            super(startOffset, length);
            this.locals = locals;
            this.module_keyword_loc = module_keyword_loc;
            this.constant_path = constant_path;
            this.body = body;
            this.end_keyword_loc = end_keyword_loc;
            this.name = name;
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
            this.constant_path.accept(visitor);
            if (this.body != null) {
                this.body.accept(visitor);
            }
        }

        public Node[] childNodes() {
            return new Node[] { this.constant_path, this.body };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitModuleNode(this);
        }
    }

    // Represents a multi-target expression.
    // 
    //     a, b, c = 1, 2, 3
    //     ^^^^^^^^^^^^^^^^^
    public static final class MultiWriteNode extends Node {
        public final Node[] targets;
        public final Location operator_loc; // optional
        public final Node value; // optional
        public final Location lparen_loc; // optional
        public final Location rparen_loc; // optional

        public MultiWriteNode(Node[] targets, Location operator_loc, Node value, Location lparen_loc, Location rparen_loc, int startOffset, int length) {
            super(startOffset, length);
            this.targets = targets;
            this.operator_loc = operator_loc;
            this.value = value;
            this.lparen_loc = lparen_loc;
            this.rparen_loc = rparen_loc;
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
            for (Nodes.Node child : this.targets) {
                child.accept(visitor);
            }
            if (this.value != null) {
                this.value.accept(visitor);
            }
        }

        public Node[] childNodes() {
            ArrayList<Node> childNodes = new ArrayList<>();
            childNodes.addAll(Arrays.asList(this.targets));
            childNodes.add(this.value);
            return childNodes.toArray(EMPTY_ARRAY);
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitMultiWriteNode(this);
        }
    }

    // Represents the use of the `next` keyword.
    // 
    //     next 1
    //     ^^^^^^
    public static final class NextNode extends Node {
        public final ArgumentsNode arguments; // optional
        public final Location keyword_loc;

        public NextNode(ArgumentsNode arguments, Location keyword_loc, int startOffset, int length) {
            super(startOffset, length);
            this.arguments = arguments;
            this.keyword_loc = keyword_loc;
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
            if (this.arguments != null) {
                this.arguments.accept(visitor);
            }
        }

        public Node[] childNodes() {
            return new Node[] { this.arguments };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitNextNode(this);
        }
    }

    // Represents the use of the `nil` keyword.
    // 
    //     nil
    //     ^^^
    public static final class NilNode extends Node {

        public NilNode(int startOffset, int length) {
            super(startOffset, length);
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
        }

        public Node[] childNodes() {
            return EMPTY_ARRAY;
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitNilNode(this);
        }
    }

    // Represents the use of `**nil` inside method arguments.
    // 
    //     def a(**nil)
    //           ^^^^^
    //     end
    public static final class NoKeywordsParameterNode extends Node {
        public final Location operator_loc;
        public final Location keyword_loc;

        public NoKeywordsParameterNode(Location operator_loc, Location keyword_loc, int startOffset, int length) {
            super(startOffset, length);
            this.operator_loc = operator_loc;
            this.keyword_loc = keyword_loc;
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
        }

        public Node[] childNodes() {
            return EMPTY_ARRAY;
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitNoKeywordsParameterNode(this);
        }
    }

    // Represents reading a numbered reference to a capture in the previous match.
    // 
    //     $1
    //     ^^
    public static final class NumberedReferenceReadNode extends Node {

        public NumberedReferenceReadNode(int startOffset, int length) {
            super(startOffset, length);
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
        }

        public Node[] childNodes() {
            return EMPTY_ARRAY;
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitNumberedReferenceReadNode(this);
        }
    }

    // Represents an optional parameter to a method, block, or lambda definition.
    // 
    //     def a(b = 1)
    //           ^^^^^
    //     end
    public static final class OptionalParameterNode extends Node {
        public final byte[] name;
        public final Location name_loc;
        public final Location operator_loc;
        public final Node value;

        public OptionalParameterNode(byte[] name, Location name_loc, Location operator_loc, Node value, int startOffset, int length) {
            super(startOffset, length);
            this.name = name;
            this.name_loc = name_loc;
            this.operator_loc = operator_loc;
            this.value = value;
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
            this.value.accept(visitor);
        }

        public Node[] childNodes() {
            return new Node[] { this.value };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitOptionalParameterNode(this);
        }
    }

    // Represents the use of the `||` operator or the `or` keyword.
    // 
    //     left or right
    //     ^^^^^^^^^^^^^
    public static final class OrNode extends Node {
        public final Node left;
        public final Node right;
        public final Location operator_loc;

        public OrNode(Node left, Node right, Location operator_loc, int startOffset, int length) {
            super(startOffset, length);
            this.left = left;
            this.right = right;
            this.operator_loc = operator_loc;
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
            this.left.accept(visitor);
            this.right.accept(visitor);
        }

        public Node[] childNodes() {
            return new Node[] { this.left, this.right };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitOrNode(this);
        }
    }

    // Represents the list of parameters on a method, block, or lambda definition.
    // 
    //     def a(b, c, d)
    //           ^^^^^^^
    //     end
    public static final class ParametersNode extends Node {
        public final Node[] requireds;
        public final Node[] optionals;
        public final Node[] posts;
        public final RestParameterNode rest; // optional
        public final Node[] keywords;
        public final Node keyword_rest; // optional
        public final BlockParameterNode block; // optional

        public ParametersNode(Node[] requireds, Node[] optionals, Node[] posts, RestParameterNode rest, Node[] keywords, Node keyword_rest, BlockParameterNode block, int startOffset, int length) {
            super(startOffset, length);
            this.requireds = requireds;
            this.optionals = optionals;
            this.posts = posts;
            this.rest = rest;
            this.keywords = keywords;
            this.keyword_rest = keyword_rest;
            this.block = block;
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
            for (Nodes.Node child : this.requireds) {
                child.accept(visitor);
            }
            for (Nodes.Node child : this.optionals) {
                child.accept(visitor);
            }
            for (Nodes.Node child : this.posts) {
                child.accept(visitor);
            }
            if (this.rest != null) {
                this.rest.accept(visitor);
            }
            for (Nodes.Node child : this.keywords) {
                child.accept(visitor);
            }
            if (this.keyword_rest != null) {
                this.keyword_rest.accept(visitor);
            }
            if (this.block != null) {
                this.block.accept(visitor);
            }
        }

        public Node[] childNodes() {
            ArrayList<Node> childNodes = new ArrayList<>();
            childNodes.addAll(Arrays.asList(this.requireds));
            childNodes.addAll(Arrays.asList(this.optionals));
            childNodes.addAll(Arrays.asList(this.posts));
            childNodes.add(this.rest);
            childNodes.addAll(Arrays.asList(this.keywords));
            childNodes.add(this.keyword_rest);
            childNodes.add(this.block);
            return childNodes.toArray(EMPTY_ARRAY);
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitParametersNode(this);
        }
    }

    // Represents a parenthesized expression
    // 
    //     (10 + 34)
    //     ^^^^^^^^^
    public static final class ParenthesesNode extends Node {
        public final Node body; // optional
        public final Location opening_loc;
        public final Location closing_loc;

        public ParenthesesNode(Node body, Location opening_loc, Location closing_loc, int startOffset, int length) {
            super(startOffset, length);
            this.body = body;
            this.opening_loc = opening_loc;
            this.closing_loc = closing_loc;
        }
                
        @Override
        public void setNewLineFlag(Source source, boolean[] newlineMarked) {
            // Never mark ParenthesesNode with a newline flag, mark children instead
        }

        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
            if (this.body != null) {
                this.body.accept(visitor);
            }
        }

        public Node[] childNodes() {
            return new Node[] { this.body };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitParenthesesNode(this);
        }
    }

    // Represents the use of the `^` operator for pinning an expression in a
    // pattern matching expression.
    // 
    //     foo in ^(bar)
    //            ^^^^^^
    public static final class PinnedExpressionNode extends Node {
        public final Node expression;
        public final Location operator_loc;
        public final Location lparen_loc;
        public final Location rparen_loc;

        public PinnedExpressionNode(Node expression, Location operator_loc, Location lparen_loc, Location rparen_loc, int startOffset, int length) {
            super(startOffset, length);
            this.expression = expression;
            this.operator_loc = operator_loc;
            this.lparen_loc = lparen_loc;
            this.rparen_loc = rparen_loc;
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
            this.expression.accept(visitor);
        }

        public Node[] childNodes() {
            return new Node[] { this.expression };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitPinnedExpressionNode(this);
        }
    }

    // Represents the use of the `^` operator for pinning a variable in a pattern
    // matching expression.
    // 
    //     foo in ^bar
    //            ^^^^
    public static final class PinnedVariableNode extends Node {
        public final Node variable;
        public final Location operator_loc;

        public PinnedVariableNode(Node variable, Location operator_loc, int startOffset, int length) {
            super(startOffset, length);
            this.variable = variable;
            this.operator_loc = operator_loc;
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
            this.variable.accept(visitor);
        }

        public Node[] childNodes() {
            return new Node[] { this.variable };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitPinnedVariableNode(this);
        }
    }

    // Represents the use of the `END` keyword.
    // 
    //     END { foo }
    //     ^^^^^^^^^^^
    public static final class PostExecutionNode extends Node {
        public final StatementsNode statements; // optional
        public final Location keyword_loc;
        public final Location opening_loc;
        public final Location closing_loc;

        public PostExecutionNode(StatementsNode statements, Location keyword_loc, Location opening_loc, Location closing_loc, int startOffset, int length) {
            super(startOffset, length);
            this.statements = statements;
            this.keyword_loc = keyword_loc;
            this.opening_loc = opening_loc;
            this.closing_loc = closing_loc;
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
            if (this.statements != null) {
                this.statements.accept(visitor);
            }
        }

        public Node[] childNodes() {
            return new Node[] { this.statements };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitPostExecutionNode(this);
        }
    }

    // Represents the use of the `BEGIN` keyword.
    // 
    //     BEGIN { foo }
    //     ^^^^^^^^^^^^^
    public static final class PreExecutionNode extends Node {
        public final StatementsNode statements; // optional
        public final Location keyword_loc;
        public final Location opening_loc;
        public final Location closing_loc;

        public PreExecutionNode(StatementsNode statements, Location keyword_loc, Location opening_loc, Location closing_loc, int startOffset, int length) {
            super(startOffset, length);
            this.statements = statements;
            this.keyword_loc = keyword_loc;
            this.opening_loc = opening_loc;
            this.closing_loc = closing_loc;
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
            if (this.statements != null) {
                this.statements.accept(visitor);
            }
        }

        public Node[] childNodes() {
            return new Node[] { this.statements };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitPreExecutionNode(this);
        }
    }

    // The top level node of any parse tree.
    public static final class ProgramNode extends Node {
        public final byte[][] locals;
        public final StatementsNode statements;

        public ProgramNode(byte[][] locals, StatementsNode statements, int startOffset, int length) {
            super(startOffset, length);
            this.locals = locals;
            this.statements = statements;
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
            this.statements.accept(visitor);
        }

        public Node[] childNodes() {
            return new Node[] { this.statements };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitProgramNode(this);
        }
    }

    // Represents the use of the `..` or `...` operators.
    // 
    //     1..2
    //     ^^^^
    // 
    //     c if a =~ /left/ ... b =~ /right/
    //          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    public static final class RangeNode extends Node {
        public final Node left; // optional
        public final Node right; // optional
        public final Location operator_loc;
        public final short flags;

        public RangeNode(Node left, Node right, Location operator_loc, short flags, int startOffset, int length) {
            super(startOffset, length);
            this.left = left;
            this.right = right;
            this.operator_loc = operator_loc;
            this.flags = flags;
        }
        
        public boolean isExcludeEnd() {
            return RangeFlags.isExcludeEnd(this.flags);
        }
        
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
            if (this.left != null) {
                this.left.accept(visitor);
            }
            if (this.right != null) {
                this.right.accept(visitor);
            }
        }

        public Node[] childNodes() {
            return new Node[] { this.left, this.right };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitRangeNode(this);
        }
    }

    // Represents a rational number literal.
    // 
    //     1.0r
    //     ^^^^
    public static final class RationalNode extends Node {
        public final Node numeric;

        public RationalNode(Node numeric, int startOffset, int length) {
            super(startOffset, length);
            this.numeric = numeric;
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
            this.numeric.accept(visitor);
        }

        public Node[] childNodes() {
            return new Node[] { this.numeric };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitRationalNode(this);
        }
    }

    // Represents the use of the `redo` keyword.
    // 
    //     redo
    //     ^^^^
    public static final class RedoNode extends Node {

        public RedoNode(int startOffset, int length) {
            super(startOffset, length);
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
        }

        public Node[] childNodes() {
            return EMPTY_ARRAY;
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitRedoNode(this);
        }
    }

    // Represents a regular expression literal with no interpolation.
    // 
    //     /foo/i
    //     ^^^^^^
    public static final class RegularExpressionNode extends Node {
        public final Location opening_loc;
        public final Location content_loc;
        public final Location closing_loc;
        public final byte[] unescaped;
        public final short flags;

        public RegularExpressionNode(Location opening_loc, Location content_loc, Location closing_loc, byte[] unescaped, short flags, int startOffset, int length) {
            super(startOffset, length);
            this.opening_loc = opening_loc;
            this.content_loc = content_loc;
            this.closing_loc = closing_loc;
            this.unescaped = unescaped;
            this.flags = flags;
        }
        
        public boolean isIgnoreCase() {
            return RegularExpressionFlags.isIgnoreCase(this.flags);
        }

        public boolean isMultiLine() {
            return RegularExpressionFlags.isMultiLine(this.flags);
        }

        public boolean isExtended() {
            return RegularExpressionFlags.isExtended(this.flags);
        }

        public boolean isEucJp() {
            return RegularExpressionFlags.isEucJp(this.flags);
        }

        public boolean isAscii8bit() {
            return RegularExpressionFlags.isAscii8bit(this.flags);
        }

        public boolean isWindows31j() {
            return RegularExpressionFlags.isWindows31j(this.flags);
        }

        public boolean isUtf8() {
            return RegularExpressionFlags.isUtf8(this.flags);
        }

        public boolean isOnce() {
            return RegularExpressionFlags.isOnce(this.flags);
        }
        
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
        }

        public Node[] childNodes() {
            return EMPTY_ARRAY;
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitRegularExpressionNode(this);
        }
    }

    // Represents a destructured required parameter node.
    // 
    //     def foo((bar, baz))
    //             ^^^^^^^^^^
    //     end
    public static final class RequiredDestructuredParameterNode extends Node {
        public final Node[] parameters;
        public final Location opening_loc;
        public final Location closing_loc;

        public RequiredDestructuredParameterNode(Node[] parameters, Location opening_loc, Location closing_loc, int startOffset, int length) {
            super(startOffset, length);
            this.parameters = parameters;
            this.opening_loc = opening_loc;
            this.closing_loc = closing_loc;
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
            for (Nodes.Node child : this.parameters) {
                child.accept(visitor);
            }
        }

        public Node[] childNodes() {
            return this.parameters;
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitRequiredDestructuredParameterNode(this);
        }
    }

    // Represents a required parameter to a method, block, or lambda definition.
    // 
    //     def a(b)
    //           ^
    //     end
    public static final class RequiredParameterNode extends Node {
        public final byte[] name;

        public RequiredParameterNode(byte[] name, int startOffset, int length) {
            super(startOffset, length);
            this.name = name;
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
        }

        public Node[] childNodes() {
            return EMPTY_ARRAY;
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitRequiredParameterNode(this);
        }
    }

    // Represents an expression modified with a rescue.
    // 
    //   foo rescue nil
    //   ^^^^^^^^^^^^^^
    public static final class RescueModifierNode extends Node {
        public final Node expression;
        public final Location keyword_loc;
        public final Node rescue_expression;

        public RescueModifierNode(Node expression, Location keyword_loc, Node rescue_expression, int startOffset, int length) {
            super(startOffset, length);
            this.expression = expression;
            this.keyword_loc = keyword_loc;
            this.rescue_expression = rescue_expression;
        }
                
        @Override
        public void setNewLineFlag(Source source, boolean[] newlineMarked) {
            this.expression.setNewLineFlag(source, newlineMarked);
        }

        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
            this.expression.accept(visitor);
            this.rescue_expression.accept(visitor);
        }

        public Node[] childNodes() {
            return new Node[] { this.expression, this.rescue_expression };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitRescueModifierNode(this);
        }
    }

    // Represents a rescue statement.
    // 
    //     begin
    //     rescue Foo, *splat, Bar => ex
    //     ^^^^^^
    //       foo
    //     end
    // 
    // `Foo, *splat, Bar` are in the `exceptions` field.
    // `ex` is in the `exception` field.
    public static final class RescueNode extends Node {
        public final Location keyword_loc;
        public final Node[] exceptions;
        public final Location operator_loc; // optional
        public final Node reference; // optional
        public final StatementsNode statements; // optional
        public final RescueNode consequent; // optional

        public RescueNode(Location keyword_loc, Node[] exceptions, Location operator_loc, Node reference, StatementsNode statements, RescueNode consequent, int startOffset, int length) {
            super(startOffset, length);
            this.keyword_loc = keyword_loc;
            this.exceptions = exceptions;
            this.operator_loc = operator_loc;
            this.reference = reference;
            this.statements = statements;
            this.consequent = consequent;
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
            for (Nodes.Node child : this.exceptions) {
                child.accept(visitor);
            }
            if (this.reference != null) {
                this.reference.accept(visitor);
            }
            if (this.statements != null) {
                this.statements.accept(visitor);
            }
            if (this.consequent != null) {
                this.consequent.accept(visitor);
            }
        }

        public Node[] childNodes() {
            ArrayList<Node> childNodes = new ArrayList<>();
            childNodes.addAll(Arrays.asList(this.exceptions));
            childNodes.add(this.reference);
            childNodes.add(this.statements);
            childNodes.add(this.consequent);
            return childNodes.toArray(EMPTY_ARRAY);
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitRescueNode(this);
        }
    }

    // Represents a rest parameter to a method, block, or lambda definition.
    // 
    //     def a(*b)
    //           ^^
    //     end
    public static final class RestParameterNode extends Node {
        public final Location operator_loc;
        public final Location name_loc; // optional

        public RestParameterNode(Location operator_loc, Location name_loc, int startOffset, int length) {
            super(startOffset, length);
            this.operator_loc = operator_loc;
            this.name_loc = name_loc;
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
        }

        public Node[] childNodes() {
            return EMPTY_ARRAY;
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitRestParameterNode(this);
        }
    }

    // Represents the use of the `retry` keyword.
    // 
    //     retry
    //     ^^^^^
    public static final class RetryNode extends Node {

        public RetryNode(int startOffset, int length) {
            super(startOffset, length);
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
        }

        public Node[] childNodes() {
            return EMPTY_ARRAY;
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitRetryNode(this);
        }
    }

    // Represents the use of the `return` keyword.
    // 
    //     return 1
    //     ^^^^^^^^
    public static final class ReturnNode extends Node {
        public final Location keyword_loc;
        public final ArgumentsNode arguments; // optional

        public ReturnNode(Location keyword_loc, ArgumentsNode arguments, int startOffset, int length) {
            super(startOffset, length);
            this.keyword_loc = keyword_loc;
            this.arguments = arguments;
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
            if (this.arguments != null) {
                this.arguments.accept(visitor);
            }
        }

        public Node[] childNodes() {
            return new Node[] { this.arguments };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitReturnNode(this);
        }
    }

    // Represents the `self` keyword.
    // 
    //     self
    //     ^^^^
    public static final class SelfNode extends Node {

        public SelfNode(int startOffset, int length) {
            super(startOffset, length);
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
        }

        public Node[] childNodes() {
            return EMPTY_ARRAY;
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitSelfNode(this);
        }
    }

    // Represents a singleton class declaration involving the `class` keyword.
    // 
    //     class << self end
    //     ^^^^^^^^^^^^^^^^^
    public static final class SingletonClassNode extends Node {
        public final byte[][] locals;
        public final Location class_keyword_loc;
        public final Location operator_loc;
        public final Node expression;
        public final Node body; // optional
        public final Location end_keyword_loc;

        public SingletonClassNode(byte[][] locals, Location class_keyword_loc, Location operator_loc, Node expression, Node body, Location end_keyword_loc, int startOffset, int length) {
            super(startOffset, length);
            this.locals = locals;
            this.class_keyword_loc = class_keyword_loc;
            this.operator_loc = operator_loc;
            this.expression = expression;
            this.body = body;
            this.end_keyword_loc = end_keyword_loc;
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
            this.expression.accept(visitor);
            if (this.body != null) {
                this.body.accept(visitor);
            }
        }

        public Node[] childNodes() {
            return new Node[] { this.expression, this.body };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitSingletonClassNode(this);
        }
    }

    // Represents the use of the `__ENCODING__` keyword.
    // 
    //     __ENCODING__
    //     ^^^^^^^^^^^^
    public static final class SourceEncodingNode extends Node {

        public SourceEncodingNode(int startOffset, int length) {
            super(startOffset, length);
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
        }

        public Node[] childNodes() {
            return EMPTY_ARRAY;
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitSourceEncodingNode(this);
        }
    }

    // Represents the use of the `__FILE__` keyword.
    // 
    //     __FILE__
    //     ^^^^^^^^
    public static final class SourceFileNode extends Node {
        public final byte[] filepath;

        public SourceFileNode(byte[] filepath, int startOffset, int length) {
            super(startOffset, length);
            this.filepath = filepath;
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
        }

        public Node[] childNodes() {
            return EMPTY_ARRAY;
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitSourceFileNode(this);
        }
    }

    // Represents the use of the `__LINE__` keyword.
    // 
    //     __LINE__
    //     ^^^^^^^^
    public static final class SourceLineNode extends Node {

        public SourceLineNode(int startOffset, int length) {
            super(startOffset, length);
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
        }

        public Node[] childNodes() {
            return EMPTY_ARRAY;
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitSourceLineNode(this);
        }
    }

    // Represents the use of the splat operator.
    // 
    //     [*a]
    //      ^^
    public static final class SplatNode extends Node {
        public final Location operator_loc;
        public final Node expression; // optional

        public SplatNode(Location operator_loc, Node expression, int startOffset, int length) {
            super(startOffset, length);
            this.operator_loc = operator_loc;
            this.expression = expression;
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
            if (this.expression != null) {
                this.expression.accept(visitor);
            }
        }

        public Node[] childNodes() {
            return new Node[] { this.expression };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitSplatNode(this);
        }
    }

    // Represents a set of statements contained within some scope.
    // 
    //     foo; bar; baz
    //     ^^^^^^^^^^^^^
    public static final class StatementsNode extends Node {
        public final Node[] body;

        public StatementsNode(Node[] body, int startOffset, int length) {
            super(startOffset, length);
            this.body = body;
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
            for (Nodes.Node child : this.body) {
                child.accept(visitor);
            }
        }

        public Node[] childNodes() {
            return this.body;
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitStatementsNode(this);
        }
    }

    // Represents the use of compile-time string concatenation.
    // 
    //     "foo" "bar"
    //     ^^^^^^^^^^^
    public static final class StringConcatNode extends Node {
        public final Node left;
        public final Node right;

        public StringConcatNode(Node left, Node right, int startOffset, int length) {
            super(startOffset, length);
            this.left = left;
            this.right = right;
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
            this.left.accept(visitor);
            this.right.accept(visitor);
        }

        public Node[] childNodes() {
            return new Node[] { this.left, this.right };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitStringConcatNode(this);
        }
    }

    // Represents a string literal, a string contained within a `%w` list, or
    // plain string content within an interpolated string.
    // 
    //     "foo"
    //     ^^^^^
    // 
    //     %w[foo]
    //        ^^^
    // 
    //     "foo #{bar} baz"
    //      ^^^^      ^^^^
    public static final class StringNode extends Node {
        public final Location opening_loc; // optional
        public final Location content_loc;
        public final Location closing_loc; // optional
        public final byte[] unescaped;

        public StringNode(Location opening_loc, Location content_loc, Location closing_loc, byte[] unescaped, int startOffset, int length) {
            super(startOffset, length);
            this.opening_loc = opening_loc;
            this.content_loc = content_loc;
            this.closing_loc = closing_loc;
            this.unescaped = unescaped;
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
        }

        public Node[] childNodes() {
            return EMPTY_ARRAY;
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitStringNode(this);
        }
    }

    // Represents the use of the `super` keyword with parentheses or arguments.
    // 
    //     super()
    //     ^^^^^^^
    // 
    //     super foo, bar
    //     ^^^^^^^^^^^^^^
    public static final class SuperNode extends Node {
        public final Location keyword_loc;
        public final Location lparen_loc; // optional
        public final ArgumentsNode arguments; // optional
        public final Location rparen_loc; // optional
        public final BlockNode block; // optional

        public SuperNode(Location keyword_loc, Location lparen_loc, ArgumentsNode arguments, Location rparen_loc, BlockNode block, int startOffset, int length) {
            super(startOffset, length);
            this.keyword_loc = keyword_loc;
            this.lparen_loc = lparen_loc;
            this.arguments = arguments;
            this.rparen_loc = rparen_loc;
            this.block = block;
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
            if (this.arguments != null) {
                this.arguments.accept(visitor);
            }
            if (this.block != null) {
                this.block.accept(visitor);
            }
        }

        public Node[] childNodes() {
            return new Node[] { this.arguments, this.block };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitSuperNode(this);
        }
    }

    // Represents a symbol literal or a symbol contained within a `%i` list.
    // 
    //     :foo
    //     ^^^^
    // 
    //     %i[foo]
    //        ^^^
    public static final class SymbolNode extends Node {
        public final Location opening_loc; // optional
        public final Location value_loc; // optional
        public final Location closing_loc; // optional
        public final byte[] unescaped;

        public SymbolNode(Location opening_loc, Location value_loc, Location closing_loc, byte[] unescaped, int startOffset, int length) {
            super(startOffset, length);
            this.opening_loc = opening_loc;
            this.value_loc = value_loc;
            this.closing_loc = closing_loc;
            this.unescaped = unescaped;
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
        }

        public Node[] childNodes() {
            return EMPTY_ARRAY;
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitSymbolNode(this);
        }
    }

    // Represents the use of the literal `true` keyword.
    // 
    //     true
    //     ^^^^
    public static final class TrueNode extends Node {

        public TrueNode(int startOffset, int length) {
            super(startOffset, length);
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
        }

        public Node[] childNodes() {
            return EMPTY_ARRAY;
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitTrueNode(this);
        }
    }

    // Represents the use of the `undef` keyword.
    // 
    //     undef :foo, :bar, :baz
    //     ^^^^^^^^^^^^^^^^^^^^^^
    public static final class UndefNode extends Node {
        public final Node[] names;
        public final Location keyword_loc;

        public UndefNode(Node[] names, Location keyword_loc, int startOffset, int length) {
            super(startOffset, length);
            this.names = names;
            this.keyword_loc = keyword_loc;
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
            for (Nodes.Node child : this.names) {
                child.accept(visitor);
            }
        }

        public Node[] childNodes() {
            return this.names;
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitUndefNode(this);
        }
    }

    // Represents the use of the `unless` keyword, either in the block form or the modifier form.
    // 
    //     bar unless foo
    //     ^^^^^^^^^^^^^^
    // 
    //     unless foo then bar end
    //     ^^^^^^^^^^^^^^^^^^^^^^^
    public static final class UnlessNode extends Node {
        public final Location keyword_loc;
        public final Node predicate;
        public final StatementsNode statements; // optional
        public final ElseNode consequent; // optional
        public final Location end_keyword_loc; // optional

        public UnlessNode(Location keyword_loc, Node predicate, StatementsNode statements, ElseNode consequent, Location end_keyword_loc, int startOffset, int length) {
            super(startOffset, length);
            this.keyword_loc = keyword_loc;
            this.predicate = predicate;
            this.statements = statements;
            this.consequent = consequent;
            this.end_keyword_loc = end_keyword_loc;
        }
                
        @Override
        public void setNewLineFlag(Source source, boolean[] newlineMarked) {
            this.predicate.setNewLineFlag(source, newlineMarked);
        }

        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
            this.predicate.accept(visitor);
            if (this.statements != null) {
                this.statements.accept(visitor);
            }
            if (this.consequent != null) {
                this.consequent.accept(visitor);
            }
        }

        public Node[] childNodes() {
            return new Node[] { this.predicate, this.statements, this.consequent };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitUnlessNode(this);
        }
    }

    // Represents the use of the `until` keyword, either in the block form or the modifier form.
    // 
    //     bar until foo
    //     ^^^^^^^^^^^^^
    // 
    //     until foo do bar end
    //     ^^^^^^^^^^^^^^^^^^^^
    public static final class UntilNode extends Node {
        public final Location keyword_loc;
        public final Location closing_loc; // optional
        public final Node predicate;
        public final StatementsNode statements; // optional
        public final short flags;

        public UntilNode(Location keyword_loc, Location closing_loc, Node predicate, StatementsNode statements, short flags, int startOffset, int length) {
            super(startOffset, length);
            this.keyword_loc = keyword_loc;
            this.closing_loc = closing_loc;
            this.predicate = predicate;
            this.statements = statements;
            this.flags = flags;
        }
        
        public boolean isBeginModifier() {
            return LoopFlags.isBeginModifier(this.flags);
        }
        
        @Override
        public void setNewLineFlag(Source source, boolean[] newlineMarked) {
            this.predicate.setNewLineFlag(source, newlineMarked);
        }

        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
            this.predicate.accept(visitor);
            if (this.statements != null) {
                this.statements.accept(visitor);
            }
        }

        public Node[] childNodes() {
            return new Node[] { this.predicate, this.statements };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitUntilNode(this);
        }
    }

    // Represents the use of the `when` keyword within a case statement.
    // 
    //     case true
    //     when true
    //     ^^^^^^^^^
    //     end
    public static final class WhenNode extends Node {
        public final Location keyword_loc;
        public final Node[] conditions;
        public final StatementsNode statements; // optional

        public WhenNode(Location keyword_loc, Node[] conditions, StatementsNode statements, int startOffset, int length) {
            super(startOffset, length);
            this.keyword_loc = keyword_loc;
            this.conditions = conditions;
            this.statements = statements;
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
            for (Nodes.Node child : this.conditions) {
                child.accept(visitor);
            }
            if (this.statements != null) {
                this.statements.accept(visitor);
            }
        }

        public Node[] childNodes() {
            ArrayList<Node> childNodes = new ArrayList<>();
            childNodes.addAll(Arrays.asList(this.conditions));
            childNodes.add(this.statements);
            return childNodes.toArray(EMPTY_ARRAY);
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitWhenNode(this);
        }
    }

    // Represents the use of the `while` keyword, either in the block form or the modifier form.
    // 
    //     bar while foo
    //     ^^^^^^^^^^^^^
    // 
    //     while foo do bar end
    //     ^^^^^^^^^^^^^^^^^^^^
    public static final class WhileNode extends Node {
        public final Location keyword_loc;
        public final Location closing_loc; // optional
        public final Node predicate;
        public final StatementsNode statements; // optional
        public final short flags;

        public WhileNode(Location keyword_loc, Location closing_loc, Node predicate, StatementsNode statements, short flags, int startOffset, int length) {
            super(startOffset, length);
            this.keyword_loc = keyword_loc;
            this.closing_loc = closing_loc;
            this.predicate = predicate;
            this.statements = statements;
            this.flags = flags;
        }
        
        public boolean isBeginModifier() {
            return LoopFlags.isBeginModifier(this.flags);
        }
        
        @Override
        public void setNewLineFlag(Source source, boolean[] newlineMarked) {
            this.predicate.setNewLineFlag(source, newlineMarked);
        }

        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
            this.predicate.accept(visitor);
            if (this.statements != null) {
                this.statements.accept(visitor);
            }
        }

        public Node[] childNodes() {
            return new Node[] { this.predicate, this.statements };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitWhileNode(this);
        }
    }

    // Represents an xstring literal with no interpolation.
    // 
    //     `foo`
    //     ^^^^^
    public static final class XStringNode extends Node {
        public final Location opening_loc;
        public final Location content_loc;
        public final Location closing_loc;
        public final byte[] unescaped;

        public XStringNode(Location opening_loc, Location content_loc, Location closing_loc, byte[] unescaped, int startOffset, int length) {
            super(startOffset, length);
            this.opening_loc = opening_loc;
            this.content_loc = content_loc;
            this.closing_loc = closing_loc;
            this.unescaped = unescaped;
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
        }

        public Node[] childNodes() {
            return EMPTY_ARRAY;
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitXStringNode(this);
        }
    }

    // Represents the use of the `yield` keyword.
    // 
    //     yield 1
    //     ^^^^^^^
    public static final class YieldNode extends Node {
        public final Location keyword_loc;
        public final Location lparen_loc; // optional
        public final ArgumentsNode arguments; // optional
        public final Location rparen_loc; // optional

        public YieldNode(Location keyword_loc, Location lparen_loc, ArgumentsNode arguments, Location rparen_loc, int startOffset, int length) {
            super(startOffset, length);
            this.keyword_loc = keyword_loc;
            this.lparen_loc = lparen_loc;
            this.arguments = arguments;
            this.rparen_loc = rparen_loc;
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
            if (this.arguments != null) {
                this.arguments.accept(visitor);
            }
        }

        public Node[] childNodes() {
            return new Node[] { this.arguments };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitYieldNode(this);
        }
    }

}
// @formatter:on
