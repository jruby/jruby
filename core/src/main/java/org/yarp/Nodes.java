package org.yarp;

import java.lang.Override;
import java.lang.String;
import java.lang.StringBuilder;
import java.util.ArrayList;
import java.util.Arrays;

import org.jruby.parser.StaticScope;

// GENERATED BY Nodes.java.erb
// @formatter:off
public abstract class Nodes {

    public enum TokenType {
        EOF,
        MISSING,
        NOT_PROVIDED,
        AMPERSAND,
        AMPERSAND_AMPERSAND,
        AMPERSAND_AMPERSAND_EQUAL,
        AMPERSAND_DOT,
        AMPERSAND_EQUAL,
        BACKTICK,
        BACK_REFERENCE,
        BANG,
        BANG_EQUAL,
        BANG_TILDE,
        BRACE_LEFT,
        BRACE_RIGHT,
        BRACKET_LEFT,
        BRACKET_LEFT_ARRAY,
        BRACKET_LEFT_RIGHT,
        BRACKET_LEFT_RIGHT_EQUAL,
        BRACKET_RIGHT,
        CARET,
        CARET_EQUAL,
        CHARACTER_LITERAL,
        CLASS_VARIABLE,
        COLON,
        COLON_COLON,
        COMMA,
        COMMENT,
        CONSTANT,
        DOT,
        DOT_DOT,
        DOT_DOT_DOT,
        EMBDOC_BEGIN,
        EMBDOC_END,
        EMBDOC_LINE,
        EMBEXPR_BEGIN,
        EMBEXPR_END,
        EMBVAR,
        EQUAL,
        EQUAL_EQUAL,
        EQUAL_EQUAL_EQUAL,
        EQUAL_GREATER,
        EQUAL_TILDE,
        FLOAT,
        GLOBAL_VARIABLE,
        GREATER,
        GREATER_EQUAL,
        GREATER_GREATER,
        GREATER_GREATER_EQUAL,
        HEREDOC_END,
        HEREDOC_START,
        IDENTIFIER,
        IGNORED_NEWLINE,
        IMAGINARY_NUMBER,
        INSTANCE_VARIABLE,
        INTEGER,
        KEYWORD_ALIAS,
        KEYWORD_AND,
        KEYWORD_BEGIN,
        KEYWORD_BEGIN_UPCASE,
        KEYWORD_BREAK,
        KEYWORD_CASE,
        KEYWORD_CLASS,
        KEYWORD_DEF,
        KEYWORD_DEFINED,
        KEYWORD_DO,
        KEYWORD_DO_LOOP,
        KEYWORD_ELSE,
        KEYWORD_ELSIF,
        KEYWORD_END,
        KEYWORD_END_UPCASE,
        KEYWORD_ENSURE,
        KEYWORD_FALSE,
        KEYWORD_FOR,
        KEYWORD_IF,
        KEYWORD_IF_MODIFIER,
        KEYWORD_IN,
        KEYWORD_MODULE,
        KEYWORD_NEXT,
        KEYWORD_NIL,
        KEYWORD_NOT,
        KEYWORD_OR,
        KEYWORD_REDO,
        KEYWORD_RESCUE,
        KEYWORD_RESCUE_MODIFIER,
        KEYWORD_RETRY,
        KEYWORD_RETURN,
        KEYWORD_SELF,
        KEYWORD_SUPER,
        KEYWORD_THEN,
        KEYWORD_TRUE,
        KEYWORD_UNDEF,
        KEYWORD_UNLESS,
        KEYWORD_UNLESS_MODIFIER,
        KEYWORD_UNTIL,
        KEYWORD_UNTIL_MODIFIER,
        KEYWORD_WHEN,
        KEYWORD_WHILE,
        KEYWORD_WHILE_MODIFIER,
        KEYWORD_YIELD,
        KEYWORD___ENCODING__,
        KEYWORD___FILE__,
        KEYWORD___LINE__,
        LABEL,
        LABEL_END,
        LAMBDA_BEGIN,
        LESS,
        LESS_EQUAL,
        LESS_EQUAL_GREATER,
        LESS_LESS,
        LESS_LESS_EQUAL,
        MINUS,
        MINUS_EQUAL,
        MINUS_GREATER,
        NEWLINE,
        NTH_REFERENCE,
        PARENTHESIS_LEFT,
        PARENTHESIS_LEFT_PARENTHESES,
        PARENTHESIS_RIGHT,
        PERCENT,
        PERCENT_EQUAL,
        PERCENT_LOWER_I,
        PERCENT_LOWER_W,
        PERCENT_LOWER_X,
        PERCENT_UPPER_I,
        PERCENT_UPPER_W,
        PIPE,
        PIPE_EQUAL,
        PIPE_PIPE,
        PIPE_PIPE_EQUAL,
        PLUS,
        PLUS_EQUAL,
        QUESTION_MARK,
        RATIONAL_NUMBER,
        REGEXP_BEGIN,
        REGEXP_END,
        SEMICOLON,
        SLASH,
        SLASH_EQUAL,
        STAR,
        STAR_EQUAL,
        STAR_STAR,
        STAR_STAR_EQUAL,
        STRING_BEGIN,
        STRING_CONTENT,
        STRING_END,
        SYMBOL_BEGIN,
        TILDE,
        UCOLON_COLON,
        UDOT_DOT,
        UDOT_DOT_DOT,
        UMINUS,
        UMINUS_NUM,
        UPLUS,
        USTAR,
        USTAR_STAR,
        WORDS_SEP,
        __END__,
    }

    static final TokenType[] TOKEN_TYPES = TokenType.values();

    public static final class Token {
        public final TokenType type;
        public final int startOffset;
        public final int endOffset;

        public Token(TokenType type, int startOffset, int endOffset) {
            this.type = type;
            this.startOffset = startOffset;
            this.endOffset = endOffset;
        }
    }

    public static final class Location {
        public final int startOffset;
        public final int endOffset;

        public Location(int startOffset, int endOffset) {
            this.startOffset = startOffset;
            this.endOffset = endOffset;
        }
    }

    public static abstract class Node {

        public static final Node[] EMPTY_ARRAY = {};

        public final int startOffset;
        public final int endOffset;

        public Node(int startOffset, int endOffset) {
            this.startOffset = startOffset;
            this.endOffset = endOffset;
        }

        public abstract <T> T accept(AbstractNodeVisitor<T> visitor);

        public abstract Node[] childNodes();

        @Override
        public String toString() {
            return toString("");
        }

        private String toString(String indent) {
            StringBuilder builder = new StringBuilder();
            builder.append(indent).append(this.getClass().getSimpleName()).append('\n');
            for (Node child : childNodes()) {
                if (child != null) {
                    builder.append(child.toString(indent + "  "));
                }
            }
            return builder.toString();
        }
    }


    // Represents the use of the `alias` keyword.
    // 
    //     alias foo bar
    //     ^^^^^^^^^^^^^
    public static final class AliasNode extends Node {
        public final Node new_name;
        public final Node old_name;
        public final Location keyword_loc;

        public AliasNode(Node new_name, Node old_name, Location keyword_loc, int startOffset, int endOffset) {
            super(startOffset, endOffset);
            this.new_name =  new_name;
            this.old_name =  old_name;
            this.keyword_loc =  keyword_loc;
        }

        public Node[] childNodes() {
            return new Node[] { new_name, old_name };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitAliasNode(this);
        }
    }

    // Represents an alternation pattern in pattern matching.
    // 
    //     foo => bar | baz
    //            ^^^^^^^^^
    public static final class AlternationPatternNode extends Node {
        public final Node left;
        public final Node right;
        public final Location operator_loc;

        public AlternationPatternNode(Node left, Node right, Location operator_loc, int startOffset, int endOffset) {
            super(startOffset, endOffset);
            this.left =  left;
            this.right =  right;
            this.operator_loc =  operator_loc;
        }

        public Node[] childNodes() {
            return new Node[] { left, right };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitAlternationPatternNode(this);
        }
    }

    // Represents the use of the `&&` operator or the `and` keyword.
    // 
    //     left and right
    //     ^^^^^^^^^^^^^^
    public static final class AndNode extends Node {
        public final Node left;
        public final Node right;
        public final Token operator;

        public AndNode(Node left, Node right, Token operator, int startOffset, int endOffset) {
            super(startOffset, endOffset);
            this.left =  left;
            this.right =  right;
            this.operator =  operator;
        }

        public Node[] childNodes() {
            return new Node[] { left, right };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitAndNode(this);
        }
    }

    // Represents a set of arguments to a method or a keyword.
    // 
    //     return foo, bar, baz
    //            ^^^^^^^^^^^^^
    public static final class ArgumentsNode extends Node {
        public final Node[] arguments;

        public ArgumentsNode(Node[] arguments, int startOffset, int endOffset) {
            super(startOffset, endOffset);
            this.arguments =  arguments;
        }

        public Node[] childNodes() {
            return arguments;
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitArgumentsNode(this);
        }
    }

    // Represents an array literal. This can be a regular array using brackets or
    // a special array using % like %w or %i.
    // 
    //     [1, 2, 3]
    //     ^^^^^^^^^
    public static final class ArrayNode extends Node {
        public final Node[] elements;
        public final Token opening; // optional
        public final Token closing; // optional

        public ArrayNode(Node[] elements, Token opening, Token closing, int startOffset, int endOffset) {
            super(startOffset, endOffset);
            this.elements =  elements;
            this.opening =  opening;
            this.closing =  closing;
        }

        public Node[] childNodes() {
            return elements;
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitArrayNode(this);
        }
    }

    // Represents an array pattern in pattern matching.
    // 
    //     foo in 1, 2
    //     ^^^^^^^^^^^
    // 
    //     foo in [1, 2]
    //     ^^^^^^^^^^^^^
    // 
    //     foo in *1
    //     ^^^^^^^^^
    // 
    //     foo in Bar[]
    //     ^^^^^^^^^^^^
    // 
    //     foo in Bar[1, 2, 3]
    //     ^^^^^^^^^^^^^^^^^^^
    public static final class ArrayPatternNode extends Node {
        public final Node constant; // optional
        public final Node[] requireds;
        public final Node rest; // optional
        public final Node[] posts;
        public final Location opening_loc; // optional
        public final Location closing_loc; // optional

        public ArrayPatternNode(Node constant, Node[] requireds, Node rest, Node[] posts, Location opening_loc, Location closing_loc, int startOffset, int endOffset) {
            super(startOffset, endOffset);
            this.constant =  constant;
            this.requireds =  requireds;
            this.rest =  rest;
            this.posts =  posts;
            this.opening_loc =  opening_loc;
            this.closing_loc =  closing_loc;
        }

        public Node[] childNodes() {
            ArrayList<Node> childNodes = new ArrayList<>();
            childNodes.add(constant);
            childNodes.addAll(Arrays.asList(requireds));
            childNodes.add(rest);
            childNodes.addAll(Arrays.asList(posts));
            return childNodes.toArray(EMPTY_ARRAY);
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitArrayPatternNode(this);
        }
    }

    // Represents a hash key/value pair.
    // 
    //     { a => b }
    //       ^^^^^^
    public static final class AssocNode extends Node {
        public final Node key;
        public final Node value; // optional
        public final Token operator; // optional

        public AssocNode(Node key, Node value, Token operator, int startOffset, int endOffset) {
            super(startOffset, endOffset);
            this.key =  key;
            this.value =  value;
            this.operator =  operator;
        }

        public Node[] childNodes() {
            return new Node[] { key, value };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitAssocNode(this);
        }
    }

    // Represents a splat in a hash literal.
    // 
    //     { **foo }
    //       ^^^^^
    public static final class AssocSplatNode extends Node {
        public final Node value; // optional
        public final Location operator_loc;

        public AssocSplatNode(Node value, Location operator_loc, int startOffset, int endOffset) {
            super(startOffset, endOffset);
            this.value =  value;
            this.operator_loc =  operator_loc;
        }

        public Node[] childNodes() {
            return new Node[] { value };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitAssocSplatNode(this);
        }
    }

    // Represents a begin statement.
    // 
    //     begin
    //       foo
    //     end
    //     ^^^^^
    public static final class BeginNode extends Node {
        public final Token begin_keyword; // optional
        public final StatementsNode statements; // optional
        public final RescueNode rescue_clause; // optional
        public final ElseNode else_clause; // optional
        public final EnsureNode ensure_clause; // optional
        public final Token end_keyword; // optional

        public BeginNode(Token begin_keyword, Node statements, Node rescue_clause, Node else_clause, Node ensure_clause, Token end_keyword, int startOffset, int endOffset) {
            super(startOffset, endOffset);
            this.begin_keyword =  begin_keyword;
            this.statements = (StatementsNode) statements;
            this.rescue_clause = (RescueNode) rescue_clause;
            this.else_clause = (ElseNode) else_clause;
            this.ensure_clause = (EnsureNode) ensure_clause;
            this.end_keyword =  end_keyword;
        }

        public Node[] childNodes() {
            return new Node[] { statements, rescue_clause, else_clause, ensure_clause };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitBeginNode(this);
        }
    }

    // Represents block method arguments.
    // 
    //     bar(&args)
    //     ^^^^^^^^^^
    public static final class BlockArgumentNode extends Node {
        public final Node expression; // optional
        public final Location operator_loc;

        public BlockArgumentNode(Node expression, Location operator_loc, int startOffset, int endOffset) {
            super(startOffset, endOffset);
            this.expression =  expression;
            this.operator_loc =  operator_loc;
        }

        public Node[] childNodes() {
            return new Node[] { expression };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitBlockArgumentNode(this);
        }
    }

    // Represents a block of ruby code.
    // 
    // [1, 2, 3].each { |i| puts x }
    //                ^^^^^^^^^^^^^^
    public static final class BlockNode extends Node {
        public final StaticScope scope;
        public final BlockParametersNode parameters; // optional
        public final Node statements; // optional
        public final Location opening_loc;
        public final Location closing_loc;

        public BlockNode(StaticScope scope, Node parameters, Node statements, Location opening_loc, Location closing_loc, int startOffset, int endOffset) {
            super(startOffset, endOffset);
            this.scope =  scope;
            this.parameters = (BlockParametersNode) parameters;
            this.statements =  statements;
            this.opening_loc =  opening_loc;
            this.closing_loc =  closing_loc;
        }

        public Node[] childNodes() {
            return new Node[] { parameters, statements };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitBlockNode(this);
        }
    }

    // Represents a block parameter to a method, block, or lambda definition.
    // 
    //     def a(&b)
    //           ^^
    //     end
    public static final class BlockParameterNode extends Node {
        public final Token name; // optional
        public final Location operator_loc;

        public BlockParameterNode(Token name, Location operator_loc, int startOffset, int endOffset) {
            super(startOffset, endOffset);
            this.name =  name;
            this.operator_loc =  operator_loc;
        }

        public Node[] childNodes() {
            return EMPTY_ARRAY;
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitBlockParameterNode(this);
        }
    }

    // Represents a block variable declaration.
    // 
    //     -> (a, b = 1; local) { }
    //         ^^^^^^^^^^^^^^^
    public static final class BlockParametersNode extends Node {
        public final ParametersNode parameters; // optional
        public final Token[] locals;

        public BlockParametersNode(Node parameters, Token[] locals, int startOffset, int endOffset) {
            super(startOffset, endOffset);
            this.parameters = (ParametersNode) parameters;
            this.locals =  locals;
        }

        public Node[] childNodes() {
            return new Node[] { parameters };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitBlockParametersNode(this);
        }
    }

    // Represents the use of the `break` keyword.
    // 
    //     break foo
    //     ^^^^^^^^^
    public static final class BreakNode extends Node {
        public final ArgumentsNode arguments; // optional
        public final Location keyword_loc;

        public BreakNode(Node arguments, Location keyword_loc, int startOffset, int endOffset) {
            super(startOffset, endOffset);
            this.arguments = (ArgumentsNode) arguments;
            this.keyword_loc =  keyword_loc;
        }

        public Node[] childNodes() {
            return new Node[] { arguments };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitBreakNode(this);
        }
    }

    // Represents a method call, in all of the various forms that can take.
    // 
    //     foo
    //     ^^^
    // 
    //     foo()
    //     ^^^^^
    // 
    //     +foo
    //     ^^^^
    // 
    //     foo + bar
    //     ^^^^^^^^^
    // 
    //     foo.bar
    //     ^^^^^^^
    // 
    //     foo&.bar
    //     ^^^^^^^^
    public static final class CallNode extends Node {
        public final Node receiver; // optional
        public final Token call_operator; // optional
        public final Token message; // optional
        public final Token opening; // optional
        public final ArgumentsNode arguments; // optional
        public final Token closing; // optional
        public final BlockNode block; // optional
        public final byte[] name;

        public CallNode(Node receiver, Token call_operator, Token message, Token opening, Node arguments, Token closing, Node block, byte[] name, int startOffset, int endOffset) {
            super(startOffset, endOffset);
            this.receiver =  receiver;
            this.call_operator =  call_operator;
            this.message =  message;
            this.opening =  opening;
            this.arguments = (ArgumentsNode) arguments;
            this.closing =  closing;
            this.block = (BlockNode) block;
            this.name =  name;
        }

        public Node[] childNodes() {
            return new Node[] { receiver, arguments, block };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitCallNode(this);
        }
    }

    // Represents assigning to a local variable in pattern matching.
    // 
    //     foo => [bar => baz]
    //            ^^^^^^^^^^^^
    public static final class CapturePatternNode extends Node {
        public final Node value;
        public final Node target;
        public final Location operator_loc;

        public CapturePatternNode(Node value, Node target, Location operator_loc, int startOffset, int endOffset) {
            super(startOffset, endOffset);
            this.value =  value;
            this.target =  target;
            this.operator_loc =  operator_loc;
        }

        public Node[] childNodes() {
            return new Node[] { value, target };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitCapturePatternNode(this);
        }
    }

    // Represents the use of a case statement.
    // 
    // case true
    // ^^^^^^^^^
    // when false
    // end
    public static final class CaseNode extends Node {
        public final Node predicate; // optional
        public final Node[] conditions;
        public final ElseNode consequent; // optional
        public final Location case_keyword_loc;
        public final Location end_keyword_loc;

        public CaseNode(Node predicate, Node[] conditions, Node consequent, Location case_keyword_loc, Location end_keyword_loc, int startOffset, int endOffset) {
            super(startOffset, endOffset);
            this.predicate =  predicate;
            this.conditions =  conditions;
            this.consequent = (ElseNode) consequent;
            this.case_keyword_loc =  case_keyword_loc;
            this.end_keyword_loc =  end_keyword_loc;
        }

        public Node[] childNodes() {
            ArrayList<Node> childNodes = new ArrayList<>();
            childNodes.add(predicate);
            childNodes.addAll(Arrays.asList(conditions));
            childNodes.add(consequent);
            return childNodes.toArray(EMPTY_ARRAY);
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitCaseNode(this);
        }
    }

    // Represents a class declaration involving the `class` keyword.
    // 
    //     class Foo end
    //     ^^^^^^^^^^^^^
    public static final class ClassNode extends Node {
        public final StaticScope scope;
        public final Token class_keyword;
        public final Node constant_path;
        public final Token inheritance_operator; // optional
        public final Node superclass; // optional
        public final Node statements; // optional
        public final Token end_keyword;

        public ClassNode(StaticScope scope, Token class_keyword, Node constant_path, Token inheritance_operator, Node superclass, Node statements, Token end_keyword, int startOffset, int endOffset) {
            super(startOffset, endOffset);
            this.scope =  scope;
            this.class_keyword =  class_keyword;
            this.constant_path =  constant_path;
            this.inheritance_operator =  inheritance_operator;
            this.superclass =  superclass;
            this.statements =  statements;
            this.end_keyword =  end_keyword;
        }

        public Node[] childNodes() {
            return new Node[] { constant_path, superclass, statements };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitClassNode(this);
        }
    }

    // Represents referencing a class variable.
    // 
    //     @@foo
    //     ^^^^^
    public static final class ClassVariableReadNode extends Node {

        public ClassVariableReadNode(int startOffset, int endOffset) {
            super(startOffset, endOffset);
        }

        public Node[] childNodes() {
            return EMPTY_ARRAY;
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitClassVariableReadNode(this);
        }
    }

    // Represents writing to a class variable.
    // 
    //     @@foo = 1
    //     ^^^^^^^^^
    public static final class ClassVariableWriteNode extends Node {
        public final Location name_loc;
        public final Node value; // optional
        public final Location operator_loc; // optional

        public ClassVariableWriteNode(Location name_loc, Node value, Location operator_loc, int startOffset, int endOffset) {
            super(startOffset, endOffset);
            this.name_loc =  name_loc;
            this.value =  value;
            this.operator_loc =  operator_loc;
        }

        public Node[] childNodes() {
            return new Node[] { value };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitClassVariableWriteNode(this);
        }
    }

    // Represents accessing a constant through a path of `::` operators.
    // 
    //     Foo::Bar
    //     ^^^^^^^^
    public static final class ConstantPathNode extends Node {
        public final Node parent; // optional
        public final Node child;
        public final Location delimiter_loc;

        public ConstantPathNode(Node parent, Node child, Location delimiter_loc, int startOffset, int endOffset) {
            super(startOffset, endOffset);
            this.parent =  parent;
            this.child =  child;
            this.delimiter_loc =  delimiter_loc;
        }

        public Node[] childNodes() {
            return new Node[] { parent, child };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitConstantPathNode(this);
        }
    }

    // Represents writing to a constant.
    // 
    //     Foo = 1
    //     ^^^^^^^
    // 
    //     Foo::Bar = 1
    //     ^^^^^^^^^^^^
    public static final class ConstantPathWriteNode extends Node {
        public final Node target;
        public final Token operator; // optional
        public final Node value; // optional

        public ConstantPathWriteNode(Node target, Token operator, Node value, int startOffset, int endOffset) {
            super(startOffset, endOffset);
            this.target =  target;
            this.operator =  operator;
            this.value =  value;
        }

        public Node[] childNodes() {
            return new Node[] { target, value };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitConstantPathWriteNode(this);
        }
    }

    // Represents referencing a constant.
    // 
    //     Foo
    //     ^^^
    public static final class ConstantReadNode extends Node {

        public ConstantReadNode(int startOffset, int endOffset) {
            super(startOffset, endOffset);
        }

        public Node[] childNodes() {
            return EMPTY_ARRAY;
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitConstantReadNode(this);
        }
    }

    // Represents a method definition.
    // 
    //     def method
    //     end
    //     ^^^^^^^^^^
    public static final class DefNode extends Node {
        public final Token name;
        public final Node receiver; // optional
        public final ParametersNode parameters; // optional
        public final Node statements; // optional
        public final StaticScope scope;
        public final Location def_keyword_loc;
        public final Location operator_loc; // optional
        public final Location lparen_loc; // optional
        public final Location rparen_loc; // optional
        public final Location equal_loc; // optional
        public final Location end_keyword_loc; // optional

        public DefNode(Token name, Node receiver, Node parameters, Node statements, StaticScope scope, Location def_keyword_loc, Location operator_loc, Location lparen_loc, Location rparen_loc, Location equal_loc, Location end_keyword_loc, int startOffset, int endOffset) {
            super(startOffset, endOffset);
            this.name =  name;
            this.receiver =  receiver;
            this.parameters = (ParametersNode) parameters;
            this.statements =  statements;
            this.scope =  scope;
            this.def_keyword_loc =  def_keyword_loc;
            this.operator_loc =  operator_loc;
            this.lparen_loc =  lparen_loc;
            this.rparen_loc =  rparen_loc;
            this.equal_loc =  equal_loc;
            this.end_keyword_loc =  end_keyword_loc;
        }

        public Node[] childNodes() {
            return new Node[] { receiver, parameters, statements };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitDefNode(this);
        }
    }

    // Represents the use of the `defined?` keyword.
    // 
    //     defined?(a)
    //     ^^^^^^^^^^^
    public static final class DefinedNode extends Node {
        public final Token lparen; // optional
        public final Node value;
        public final Token rparen; // optional
        public final Location keyword_loc;

        public DefinedNode(Token lparen, Node value, Token rparen, Location keyword_loc, int startOffset, int endOffset) {
            super(startOffset, endOffset);
            this.lparen =  lparen;
            this.value =  value;
            this.rparen =  rparen;
            this.keyword_loc =  keyword_loc;
        }

        public Node[] childNodes() {
            return new Node[] { value };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitDefinedNode(this);
        }
    }

    // Represents an `else` clause in a `case`, `if`, or `unless` statement.
    // 
    //     if a then b else c end
    //                 ^^^^^^^^^^
    public static final class ElseNode extends Node {
        public final Token else_keyword;
        public final StatementsNode statements; // optional
        public final Token end_keyword; // optional

        public ElseNode(Token else_keyword, Node statements, Token end_keyword, int startOffset, int endOffset) {
            super(startOffset, endOffset);
            this.else_keyword =  else_keyword;
            this.statements = (StatementsNode) statements;
            this.end_keyword =  end_keyword;
        }

        public Node[] childNodes() {
            return new Node[] { statements };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitElseNode(this);
        }
    }

    // Represents an `ensure` clause in a `begin` statement.
    // 
    //     begin
    //       foo
    //     ensure
    //     ^^^^^^
    //       bar
    //     end
    public static final class EnsureNode extends Node {
        public final Token ensure_keyword;
        public final StatementsNode statements; // optional
        public final Token end_keyword;

        public EnsureNode(Token ensure_keyword, Node statements, Token end_keyword, int startOffset, int endOffset) {
            super(startOffset, endOffset);
            this.ensure_keyword =  ensure_keyword;
            this.statements = (StatementsNode) statements;
            this.end_keyword =  end_keyword;
        }

        public Node[] childNodes() {
            return new Node[] { statements };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitEnsureNode(this);
        }
    }

    // Represents the use of the literal `false` keyword.
    // 
    //     false
    //     ^^^^^
    public static final class FalseNode extends Node {

        public FalseNode(int startOffset, int endOffset) {
            super(startOffset, endOffset);
        }

        public Node[] childNodes() {
            return EMPTY_ARRAY;
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitFalseNode(this);
        }
    }

    // Represents a find pattern in pattern matching.
    // 
    //     foo in *bar, baz, *qux
    //     ^^^^^^^^^^^^^^^^^^^^^^
    // 
    //     foo in [*bar, baz, *qux]
    //     ^^^^^^^^^^^^^^^^^^^^^^^^
    // 
    //     foo in Foo(*bar, baz, *qux)
    //     ^^^^^^^^^^^^^^^^^^^^^^^^^^^
    public static final class FindPatternNode extends Node {
        public final Node constant; // optional
        public final Node left;
        public final Node[] requireds;
        public final Node right;
        public final Location opening_loc; // optional
        public final Location closing_loc; // optional

        public FindPatternNode(Node constant, Node left, Node[] requireds, Node right, Location opening_loc, Location closing_loc, int startOffset, int endOffset) {
            super(startOffset, endOffset);
            this.constant =  constant;
            this.left =  left;
            this.requireds =  requireds;
            this.right =  right;
            this.opening_loc =  opening_loc;
            this.closing_loc =  closing_loc;
        }

        public Node[] childNodes() {
            ArrayList<Node> childNodes = new ArrayList<>();
            childNodes.add(constant);
            childNodes.add(left);
            childNodes.addAll(Arrays.asList(requireds));
            childNodes.add(right);
            return childNodes.toArray(EMPTY_ARRAY);
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitFindPatternNode(this);
        }
    }

    // Represents a floating point number literal.
    // 
    //     1.0
    //     ^^^
    public static final class FloatNode extends Node {

        public FloatNode(int startOffset, int endOffset) {
            super(startOffset, endOffset);
        }

        public Node[] childNodes() {
            return EMPTY_ARRAY;
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitFloatNode(this);
        }
    }

    // Represents the use of the `for` keyword.
    // 
    //     for i in a end
    //     ^^^^^^^^^^^^^^
    public static final class ForNode extends Node {
        public final Node index;
        public final Node collection;
        public final StatementsNode statements; // optional
        public final Location for_keyword_loc;
        public final Location in_keyword_loc;
        public final Location do_keyword_loc; // optional
        public final Location end_keyword_loc;

        public ForNode(Node index, Node collection, Node statements, Location for_keyword_loc, Location in_keyword_loc, Location do_keyword_loc, Location end_keyword_loc, int startOffset, int endOffset) {
            super(startOffset, endOffset);
            this.index =  index;
            this.collection =  collection;
            this.statements = (StatementsNode) statements;
            this.for_keyword_loc =  for_keyword_loc;
            this.in_keyword_loc =  in_keyword_loc;
            this.do_keyword_loc =  do_keyword_loc;
            this.end_keyword_loc =  end_keyword_loc;
        }

        public Node[] childNodes() {
            return new Node[] { index, collection, statements };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitForNode(this);
        }
    }

    // Represents forwarding all arguments to this method to another method.
    // 
    //     def foo(...)
    //       bar(...)
    //       ^^^^^^^^
    //     end
    public static final class ForwardingArgumentsNode extends Node {

        public ForwardingArgumentsNode(int startOffset, int endOffset) {
            super(startOffset, endOffset);
        }

        public Node[] childNodes() {
            return EMPTY_ARRAY;
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitForwardingArgumentsNode(this);
        }
    }

    // Represents the use of the forwarding parameter in a method, block, or lambda declaration.
    // 
    //     def foo(...)
    //             ^^^
    //     end
    public static final class ForwardingParameterNode extends Node {

        public ForwardingParameterNode(int startOffset, int endOffset) {
            super(startOffset, endOffset);
        }

        public Node[] childNodes() {
            return EMPTY_ARRAY;
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitForwardingParameterNode(this);
        }
    }

    // Represents the use of the `super` keyword without parentheses or arguments.
    // 
    //     super
    //     ^^^^^
    public static final class ForwardingSuperNode extends Node {
        public final BlockNode block; // optional

        public ForwardingSuperNode(Node block, int startOffset, int endOffset) {
            super(startOffset, endOffset);
            this.block = (BlockNode) block;
        }

        public Node[] childNodes() {
            return new Node[] { block };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitForwardingSuperNode(this);
        }
    }

    // Represents referencing a global variable.
    // 
    //     $foo
    //     ^^^^
    public static final class GlobalVariableReadNode extends Node {
        public final Token name;

        public GlobalVariableReadNode(Token name, int startOffset, int endOffset) {
            super(startOffset, endOffset);
            this.name =  name;
        }

        public Node[] childNodes() {
            return EMPTY_ARRAY;
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitGlobalVariableReadNode(this);
        }
    }

    // Represents writing to a global variable.
    // 
    //     $foo = 1
    //     ^^^^^^^^
    public static final class GlobalVariableWriteNode extends Node {
        public final Token name;
        public final Token operator; // optional
        public final Node value; // optional

        public GlobalVariableWriteNode(Token name, Token operator, Node value, int startOffset, int endOffset) {
            super(startOffset, endOffset);
            this.name =  name;
            this.operator =  operator;
            this.value =  value;
        }

        public Node[] childNodes() {
            return new Node[] { value };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitGlobalVariableWriteNode(this);
        }
    }

    // Represents a hash literal.
    // 
    //     { a => b }
    //     ^^^^^^^^^^
    public static final class HashNode extends Node {
        public final Token opening; // optional
        public final Node[] elements;
        public final Token closing; // optional

        public HashNode(Token opening, Node[] elements, Token closing, int startOffset, int endOffset) {
            super(startOffset, endOffset);
            this.opening =  opening;
            this.elements =  elements;
            this.closing =  closing;
        }

        public Node[] childNodes() {
            return elements;
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitHashNode(this);
        }
    }

    // Represents a hash pattern in pattern matching.
    // 
    //     foo => { a: 1, b: 2 }
    //            ^^^^^^^^^^^^^^
    // 
    //     foo => { a: 1, b: 2, **c }
    //            ^^^^^^^^^^^^^^^^^^^
    public static final class HashPatternNode extends Node {
        public final Node constant; // optional
        public final Node[] assocs;
        public final Node kwrest; // optional
        public final Location opening_loc; // optional
        public final Location closing_loc; // optional

        public HashPatternNode(Node constant, Node[] assocs, Node kwrest, Location opening_loc, Location closing_loc, int startOffset, int endOffset) {
            super(startOffset, endOffset);
            this.constant =  constant;
            this.assocs =  assocs;
            this.kwrest =  kwrest;
            this.opening_loc =  opening_loc;
            this.closing_loc =  closing_loc;
        }

        public Node[] childNodes() {
            ArrayList<Node> childNodes = new ArrayList<>();
            childNodes.add(constant);
            childNodes.addAll(Arrays.asList(assocs));
            childNodes.add(kwrest);
            return childNodes.toArray(EMPTY_ARRAY);
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitHashPatternNode(this);
        }
    }

    // Represents the use of a heredoc.
    // 
    //     <<~HERE
    //       Content.
    //     HERE
    //     ^^^^^^^^^^
    public static final class HeredocNode extends Node {
        public final Token opening;
        public final Node[] parts;
        public final Token closing;
        public final int dedent;

        public HeredocNode(Token opening, Node[] parts, Token closing, int dedent, int startOffset, int endOffset) {
            super(startOffset, endOffset);
            this.opening =  opening;
            this.parts =  parts;
            this.closing =  closing;
            this.dedent =  dedent;
        }

        public Node[] childNodes() {
            return parts;
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitHeredocNode(this);
        }
    }

    // Represents the use of the `if` keyword, either in the block form or the modifier form.
    // 
    //     bar if foo
    //     ^^^^^^^^^^
    // 
    //     if foo then bar end
    //     ^^^^^^^^^^^^^^^^^^^
    public static final class IfNode extends Node {
        public final Token if_keyword;
        public final Node predicate;
        public final StatementsNode statements; // optional
        public final Node consequent; // optional
        public final Token end_keyword; // optional

        public IfNode(Token if_keyword, Node predicate, Node statements, Node consequent, Token end_keyword, int startOffset, int endOffset) {
            super(startOffset, endOffset);
            this.if_keyword =  if_keyword;
            this.predicate =  predicate;
            this.statements = (StatementsNode) statements;
            this.consequent =  consequent;
            this.end_keyword =  end_keyword;
        }

        public Node[] childNodes() {
            return new Node[] { predicate, statements, consequent };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitIfNode(this);
        }
    }

    // Represents an imaginary number literal.
    // 
    //     1.0i
    //     ^^^^
    public static final class ImaginaryNode extends Node {

        public ImaginaryNode(int startOffset, int endOffset) {
            super(startOffset, endOffset);
        }

        public Node[] childNodes() {
            return EMPTY_ARRAY;
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitImaginaryNode(this);
        }
    }

    // Represents the use of the `in` keyword in a case statement.
    // 
    //     case a; in b then c end
    //             ^^^^^^^^^^^
    public static final class InNode extends Node {
        public final Node pattern;
        public final StatementsNode statements; // optional
        public final Location in_loc;
        public final Location then_loc; // optional

        public InNode(Node pattern, Node statements, Location in_loc, Location then_loc, int startOffset, int endOffset) {
            super(startOffset, endOffset);
            this.pattern =  pattern;
            this.statements = (StatementsNode) statements;
            this.in_loc =  in_loc;
            this.then_loc =  then_loc;
        }

        public Node[] childNodes() {
            return new Node[] { pattern, statements };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitInNode(this);
        }
    }

    // Represents referencing an instance variable.
    // 
    //     @foo
    //     ^^^^
    public static final class InstanceVariableReadNode extends Node {

        public InstanceVariableReadNode(int startOffset, int endOffset) {
            super(startOffset, endOffset);
        }

        public Node[] childNodes() {
            return EMPTY_ARRAY;
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitInstanceVariableReadNode(this);
        }
    }

    // Represents writing to an instance variable.
    // 
    //     @foo = 1
    //     ^^^^^^^^
    public static final class InstanceVariableWriteNode extends Node {
        public final Location name_loc;
        public final Node value; // optional
        public final Location operator_loc; // optional

        public InstanceVariableWriteNode(Location name_loc, Node value, Location operator_loc, int startOffset, int endOffset) {
            super(startOffset, endOffset);
            this.name_loc =  name_loc;
            this.value =  value;
            this.operator_loc =  operator_loc;
        }

        public Node[] childNodes() {
            return new Node[] { value };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitInstanceVariableWriteNode(this);
        }
    }

    // Represents an integer number literal.
    // 
    //     1
    //     ^
    public static final class IntegerNode extends Node {

        public IntegerNode(int startOffset, int endOffset) {
            super(startOffset, endOffset);
        }

        public Node[] childNodes() {
            return EMPTY_ARRAY;
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitIntegerNode(this);
        }
    }

    // Represents a regular expression literal that contains interpolation.
    // 
    //     /foo #{bar} baz/
    //     ^^^^^^^^^^^^^^^^
    public static final class InterpolatedRegularExpressionNode extends Node {
        public final Token opening;
        public final Node[] parts;
        public final Token closing;

        public InterpolatedRegularExpressionNode(Token opening, Node[] parts, Token closing, int startOffset, int endOffset) {
            super(startOffset, endOffset);
            this.opening =  opening;
            this.parts =  parts;
            this.closing =  closing;
        }

        public Node[] childNodes() {
            return parts;
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitInterpolatedRegularExpressionNode(this);
        }
    }

    // Represents a string literal that contains interpolation.
    // 
    //     "foo #{bar} baz"
    //     ^^^^^^^^^^^^^^^^
    public static final class InterpolatedStringNode extends Node {
        public final Token opening; // optional
        public final Node[] parts;
        public final Token closing; // optional

        public InterpolatedStringNode(Token opening, Node[] parts, Token closing, int startOffset, int endOffset) {
            super(startOffset, endOffset);
            this.opening =  opening;
            this.parts =  parts;
            this.closing =  closing;
        }

        public Node[] childNodes() {
            return parts;
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitInterpolatedStringNode(this);
        }
    }

    // Represents a symbol literal that contains interpolation.
    // 
    //     :"foo #{bar} baz"
    //     ^^^^^^^^^^^^^^^^^
    public static final class InterpolatedSymbolNode extends Node {
        public final Token opening; // optional
        public final Node[] parts;
        public final Token closing; // optional

        public InterpolatedSymbolNode(Token opening, Node[] parts, Token closing, int startOffset, int endOffset) {
            super(startOffset, endOffset);
            this.opening =  opening;
            this.parts =  parts;
            this.closing =  closing;
        }

        public Node[] childNodes() {
            return parts;
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitInterpolatedSymbolNode(this);
        }
    }

    // Represents an xstring literal that contains interpolation.
    // 
    //     `foo #{bar} baz`
    //     ^^^^^^^^^^^^^^^^
    public static final class InterpolatedXStringNode extends Node {
        public final Token opening;
        public final Node[] parts;
        public final Token closing;

        public InterpolatedXStringNode(Token opening, Node[] parts, Token closing, int startOffset, int endOffset) {
            super(startOffset, endOffset);
            this.opening =  opening;
            this.parts =  parts;
            this.closing =  closing;
        }

        public Node[] childNodes() {
            return parts;
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitInterpolatedXStringNode(this);
        }
    }

    // Represents a keyword parameter to a method, block, or lambda definition.
    // 
    //     def a(b:)
    //           ^^
    //     end
    // 
    //     def a(b: 1)
    //           ^^^^
    //     end
    public static final class KeywordParameterNode extends Node {
        public final Token name;
        public final Node value; // optional

        public KeywordParameterNode(Token name, Node value, int startOffset, int endOffset) {
            super(startOffset, endOffset);
            this.name =  name;
            this.value =  value;
        }

        public Node[] childNodes() {
            return new Node[] { value };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitKeywordParameterNode(this);
        }
    }

    // Represents a keyword rest parameter to a method, block, or lambda definition.
    // 
    //     def a(**b)
    //           ^^^
    //     end
    public static final class KeywordRestParameterNode extends Node {
        public final Token operator;
        public final Token name; // optional

        public KeywordRestParameterNode(Token operator, Token name, int startOffset, int endOffset) {
            super(startOffset, endOffset);
            this.operator =  operator;
            this.name =  name;
        }

        public Node[] childNodes() {
            return EMPTY_ARRAY;
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitKeywordRestParameterNode(this);
        }
    }

    // Represents using a lambda literal (not the lambda method call).
    // 
    //     ->(value) { value * 2 }
    //     ^^^^^^^^^^^^^^^^^^^^^^^
    public static final class LambdaNode extends Node {
        public final StaticScope scope;
        public final Token opening;
        public final Token lparen; // optional
        public final BlockParametersNode parameters; // optional
        public final Token rparen; // optional
        public final Node statements; // optional

        public LambdaNode(StaticScope scope, Token opening, Token lparen, Node parameters, Token rparen, Node statements, int startOffset, int endOffset) {
            super(startOffset, endOffset);
            this.scope =  scope;
            this.opening =  opening;
            this.lparen =  lparen;
            this.parameters = (BlockParametersNode) parameters;
            this.rparen =  rparen;
            this.statements =  statements;
        }

        public Node[] childNodes() {
            return new Node[] { parameters, statements };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitLambdaNode(this);
        }
    }

    // Represents reading a local variable. Note that this requires that a local
    // variable of the same name has already been written to in the same scope,
    // otherwise it is parsed as a method call.
    // 
    //     foo
    //     ^^^
    public static final class LocalVariableReadNode extends Node {
        public final int depth;

        public LocalVariableReadNode(int depth, int startOffset, int endOffset) {
            super(startOffset, endOffset);
            this.depth =  depth;
        }

        public Node[] childNodes() {
            return EMPTY_ARRAY;
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitLocalVariableReadNode(this);
        }
    }

    // Represents writing to a local variable.
    // 
    //     foo = 1
    //     ^^^^^^^
    public static final class LocalVariableWriteNode extends Node {
        public final Location name_loc;
        public final Node value; // optional
        public final Location operator_loc; // optional
        public final int depth;

        public LocalVariableWriteNode(Location name_loc, Node value, Location operator_loc, int depth, int startOffset, int endOffset) {
            super(startOffset, endOffset);
            this.name_loc =  name_loc;
            this.value =  value;
            this.operator_loc =  operator_loc;
            this.depth =  depth;
        }

        public Node[] childNodes() {
            return new Node[] { value };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitLocalVariableWriteNode(this);
        }
    }

    // Represents the use of the modifier `in` operator.
    // 
    //     foo in bar
    //     ^^^^^^^^^^
    public static final class MatchPredicateNode extends Node {
        public final Node value;
        public final Node pattern;
        public final Location operator_loc;

        public MatchPredicateNode(Node value, Node pattern, Location operator_loc, int startOffset, int endOffset) {
            super(startOffset, endOffset);
            this.value =  value;
            this.pattern =  pattern;
            this.operator_loc =  operator_loc;
        }

        public Node[] childNodes() {
            return new Node[] { value, pattern };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitMatchPredicateNode(this);
        }
    }

    // Represents the use of the `=>` operator.
    // 
    //     foo => bar
    //     ^^^^^^^^^^
    public static final class MatchRequiredNode extends Node {
        public final Node value;
        public final Node pattern;
        public final Location operator_loc;

        public MatchRequiredNode(Node value, Node pattern, Location operator_loc, int startOffset, int endOffset) {
            super(startOffset, endOffset);
            this.value =  value;
            this.pattern =  pattern;
            this.operator_loc =  operator_loc;
        }

        public Node[] childNodes() {
            return new Node[] { value, pattern };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitMatchRequiredNode(this);
        }
    }

    // Represents a node that is missing from the source and results in a syntax
    // error.
    public static final class MissingNode extends Node {

        public MissingNode(int startOffset, int endOffset) {
            super(startOffset, endOffset);
        }

        public Node[] childNodes() {
            return EMPTY_ARRAY;
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitMissingNode(this);
        }
    }

    // Represents a module declaration involving the `module` keyword.
    // 
    //     module Foo end
    //     ^^^^^^^^^^^^^^
    public static final class ModuleNode extends Node {
        public final StaticScope scope;
        public final Token module_keyword;
        public final Node constant_path;
        public final Node statements; // optional
        public final Token end_keyword;

        public ModuleNode(StaticScope scope, Token module_keyword, Node constant_path, Node statements, Token end_keyword, int startOffset, int endOffset) {
            super(startOffset, endOffset);
            this.scope =  scope;
            this.module_keyword =  module_keyword;
            this.constant_path =  constant_path;
            this.statements =  statements;
            this.end_keyword =  end_keyword;
        }

        public Node[] childNodes() {
            return new Node[] { constant_path, statements };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitModuleNode(this);
        }
    }

    // Represents a multi-target expression.
    // 
    //     a, b, c = 1, 2, 3
    //     ^^^^^^^^^^^^^^^^^
    public static final class MultiWriteNode extends Node {
        public final Node[] targets;
        public final Token operator; // optional
        public final Node value; // optional
        public final Location lparen_loc; // optional
        public final Location rparen_loc; // optional

        public MultiWriteNode(Node[] targets, Token operator, Node value, Location lparen_loc, Location rparen_loc, int startOffset, int endOffset) {
            super(startOffset, endOffset);
            this.targets =  targets;
            this.operator =  operator;
            this.value =  value;
            this.lparen_loc =  lparen_loc;
            this.rparen_loc =  rparen_loc;
        }

        public Node[] childNodes() {
            ArrayList<Node> childNodes = new ArrayList<>();
            childNodes.addAll(Arrays.asList(targets));
            childNodes.add(value);
            return childNodes.toArray(EMPTY_ARRAY);
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitMultiWriteNode(this);
        }
    }

    // Represents the use of the `next` keyword.
    // 
    //     next 1
    //     ^^^^^^
    public static final class NextNode extends Node {
        public final ArgumentsNode arguments; // optional
        public final Location keyword_loc;

        public NextNode(Node arguments, Location keyword_loc, int startOffset, int endOffset) {
            super(startOffset, endOffset);
            this.arguments = (ArgumentsNode) arguments;
            this.keyword_loc =  keyword_loc;
        }

        public Node[] childNodes() {
            return new Node[] { arguments };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitNextNode(this);
        }
    }

    // Represents the use of the `nil` keyword.
    // 
    //     nil
    //     ^^^
    public static final class NilNode extends Node {

        public NilNode(int startOffset, int endOffset) {
            super(startOffset, endOffset);
        }

        public Node[] childNodes() {
            return EMPTY_ARRAY;
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitNilNode(this);
        }
    }

    // Represents the use of `**nil` inside method arguments.
    // 
    //     def a(**nil)
    //           ^^^^^
    //     end
    public static final class NoKeywordsParameterNode extends Node {
        public final Location operator_loc;
        public final Location keyword_loc;

        public NoKeywordsParameterNode(Location operator_loc, Location keyword_loc, int startOffset, int endOffset) {
            super(startOffset, endOffset);
            this.operator_loc =  operator_loc;
            this.keyword_loc =  keyword_loc;
        }

        public Node[] childNodes() {
            return EMPTY_ARRAY;
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitNoKeywordsParameterNode(this);
        }
    }

    // Represents the use of the `&&=` operator for assignment.
    // 
    //     target &&= value
    //     ^^^^^^^^^^^^^^^^
    public static final class OperatorAndAssignmentNode extends Node {
        public final Node target;
        public final Node value;
        public final Location operator_loc;

        public OperatorAndAssignmentNode(Node target, Node value, Location operator_loc, int startOffset, int endOffset) {
            super(startOffset, endOffset);
            this.target =  target;
            this.value =  value;
            this.operator_loc =  operator_loc;
        }

        public Node[] childNodes() {
            return new Node[] { target, value };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitOperatorAndAssignmentNode(this);
        }
    }

    // Represents assigning to a value using an operator that isn't `=`.
    // 
    //     foo += bar
    //     ^^^^^^^^^^
    public static final class OperatorAssignmentNode extends Node {
        public final Node target;
        public final Token operator;
        public final Node value;

        public OperatorAssignmentNode(Node target, Token operator, Node value, int startOffset, int endOffset) {
            super(startOffset, endOffset);
            this.target =  target;
            this.operator =  operator;
            this.value =  value;
        }

        public Node[] childNodes() {
            return new Node[] { target, value };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitOperatorAssignmentNode(this);
        }
    }

    // Represents the use of the `||=` operator for assignment.
    // 
    //     target ||= value
    //     ^^^^^^^^^^^^^^^^
    public static final class OperatorOrAssignmentNode extends Node {
        public final Node target;
        public final Node value;
        public final Location operator_loc;

        public OperatorOrAssignmentNode(Node target, Node value, Location operator_loc, int startOffset, int endOffset) {
            super(startOffset, endOffset);
            this.target =  target;
            this.value =  value;
            this.operator_loc =  operator_loc;
        }

        public Node[] childNodes() {
            return new Node[] { target, value };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitOperatorOrAssignmentNode(this);
        }
    }

    // Represents an optional parameter to a method, block, or lambda definition.
    // 
    //     def a(b = 1)
    //           ^^^^^
    //     end
    public static final class OptionalParameterNode extends Node {
        public final Token name;
        public final Token equal_operator;
        public final Node value;

        public OptionalParameterNode(Token name, Token equal_operator, Node value, int startOffset, int endOffset) {
            super(startOffset, endOffset);
            this.name =  name;
            this.equal_operator =  equal_operator;
            this.value =  value;
        }

        public Node[] childNodes() {
            return new Node[] { value };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitOptionalParameterNode(this);
        }
    }

    // Represents the use of the `||` operator or the `or` keyword.
    // 
    //     left or right
    //     ^^^^^^^^^^^^^
    public static final class OrNode extends Node {
        public final Node left;
        public final Node right;
        public final Location operator_loc;

        public OrNode(Node left, Node right, Location operator_loc, int startOffset, int endOffset) {
            super(startOffset, endOffset);
            this.left =  left;
            this.right =  right;
            this.operator_loc =  operator_loc;
        }

        public Node[] childNodes() {
            return new Node[] { left, right };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitOrNode(this);
        }
    }

    // Represents the list of parameters on a method, block, or lambda definition.
    // 
    //     def a(b, c, d)
    //           ^^^^^^^
    //     end
    public static final class ParametersNode extends Node {
        public final Node[] requireds;
        public final Node[] optionals;
        public final Node[] posts;
        public final RestParameterNode rest; // optional
        public final Node[] keywords;
        public final Node keyword_rest; // optional
        public final BlockParameterNode block; // optional

        public ParametersNode(Node[] requireds, Node[] optionals, Node[] posts, Node rest, Node[] keywords, Node keyword_rest, Node block, int startOffset, int endOffset) {
            super(startOffset, endOffset);
            this.requireds =  requireds;
            this.optionals =  optionals;
            this.posts =  posts;
            this.rest = (RestParameterNode) rest;
            this.keywords =  keywords;
            this.keyword_rest =  keyword_rest;
            this.block = (BlockParameterNode) block;
        }

        public Node[] childNodes() {
            ArrayList<Node> childNodes = new ArrayList<>();
            childNodes.addAll(Arrays.asList(requireds));
            childNodes.addAll(Arrays.asList(optionals));
            childNodes.addAll(Arrays.asList(posts));
            childNodes.add(rest);
            childNodes.addAll(Arrays.asList(keywords));
            childNodes.add(keyword_rest);
            childNodes.add(block);
            return childNodes.toArray(EMPTY_ARRAY);
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitParametersNode(this);
        }
    }

    // Represents a parentesized expression
    // 
    //     (10 + 34)
    //     ^^^^^^^^^
    public static final class ParenthesesNode extends Node {
        public final Node statements; // optional
        public final Location opening_loc;
        public final Location closing_loc;

        public ParenthesesNode(Node statements, Location opening_loc, Location closing_loc, int startOffset, int endOffset) {
            super(startOffset, endOffset);
            this.statements =  statements;
            this.opening_loc =  opening_loc;
            this.closing_loc =  closing_loc;
        }

        public Node[] childNodes() {
            return new Node[] { statements };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitParenthesesNode(this);
        }
    }

    // Represents the use of the `^` operator for pinning an expression in a
    // pattern matching expression.
    // 
    //     foo in ^(bar)
    //            ^^^^^^
    public static final class PinnedExpressionNode extends Node {
        public final Node expression;
        public final Location operator_loc;
        public final Location lparen_loc;
        public final Location rparen_loc;

        public PinnedExpressionNode(Node expression, Location operator_loc, Location lparen_loc, Location rparen_loc, int startOffset, int endOffset) {
            super(startOffset, endOffset);
            this.expression =  expression;
            this.operator_loc =  operator_loc;
            this.lparen_loc =  lparen_loc;
            this.rparen_loc =  rparen_loc;
        }

        public Node[] childNodes() {
            return new Node[] { expression };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitPinnedExpressionNode(this);
        }
    }

    // Represents the use of the `^` operator for pinning a variable in a pattern
    // matching expression.
    // 
    //     foo in ^bar
    //            ^^^^
    public static final class PinnedVariableNode extends Node {
        public final Node variable;
        public final Location operator_loc;

        public PinnedVariableNode(Node variable, Location operator_loc, int startOffset, int endOffset) {
            super(startOffset, endOffset);
            this.variable =  variable;
            this.operator_loc =  operator_loc;
        }

        public Node[] childNodes() {
            return new Node[] { variable };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitPinnedVariableNode(this);
        }
    }

    // Represents the use of the `END` keyword.
    // 
    //     END { foo }
    //     ^^^^^^^^^^^
    public static final class PostExecutionNode extends Node {
        public final StatementsNode statements;
        public final Location keyword_loc;
        public final Location opening_loc;
        public final Location closing_loc;

        public PostExecutionNode(Node statements, Location keyword_loc, Location opening_loc, Location closing_loc, int startOffset, int endOffset) {
            super(startOffset, endOffset);
            this.statements = (StatementsNode) statements;
            this.keyword_loc =  keyword_loc;
            this.opening_loc =  opening_loc;
            this.closing_loc =  closing_loc;
        }

        public Node[] childNodes() {
            return new Node[] { statements };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitPostExecutionNode(this);
        }
    }

    // Represents the use of the `BEGIN` keyword.
    // 
    //     BEGIN { foo }
    //     ^^^^^^^^^^^^^
    public static final class PreExecutionNode extends Node {
        public final StatementsNode statements;
        public final Location keyword_loc;
        public final Location opening_loc;
        public final Location closing_loc;

        public PreExecutionNode(Node statements, Location keyword_loc, Location opening_loc, Location closing_loc, int startOffset, int endOffset) {
            super(startOffset, endOffset);
            this.statements = (StatementsNode) statements;
            this.keyword_loc =  keyword_loc;
            this.opening_loc =  opening_loc;
            this.closing_loc =  closing_loc;
        }

        public Node[] childNodes() {
            return new Node[] { statements };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitPreExecutionNode(this);
        }
    }

    // The top level node of any parse tree.
    public static final class ProgramNode extends Node {
        public final StaticScope scope;
        public final StatementsNode statements;

        public ProgramNode(StaticScope scope, Node statements, int startOffset, int endOffset) {
            super(startOffset, endOffset);
            this.scope =  scope;
            this.statements = (StatementsNode) statements;
        }

        public Node[] childNodes() {
            return new Node[] { statements };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitProgramNode(this);
        }
    }

    // Represents the use of the `..` or `...` operators.
    // 
    //     1..2
    //     ^^^^
    // 
    //     c if a =~ /left/ ... b =~ /right/
    //          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    public static final class RangeNode extends Node {
        public final Node left; // optional
        public final Node right; // optional
        public final Location operator_loc;

        public RangeNode(Node left, Node right, Location operator_loc, int startOffset, int endOffset) {
            super(startOffset, endOffset);
            this.left =  left;
            this.right =  right;
            this.operator_loc =  operator_loc;
        }

        public Node[] childNodes() {
            return new Node[] { left, right };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitRangeNode(this);
        }
    }

    // Represents a rational number literal.
    // 
    //     1.0r
    //     ^^^^
    public static final class RationalNode extends Node {

        public RationalNode(int startOffset, int endOffset) {
            super(startOffset, endOffset);
        }

        public Node[] childNodes() {
            return EMPTY_ARRAY;
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitRationalNode(this);
        }
    }

    // Represents the use of the `redo` keyword.
    // 
    //     redo
    //     ^^^^
    public static final class RedoNode extends Node {

        public RedoNode(int startOffset, int endOffset) {
            super(startOffset, endOffset);
        }

        public Node[] childNodes() {
            return EMPTY_ARRAY;
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitRedoNode(this);
        }
    }

    // Represents a regular expression literal with no interpolation.
    // 
    //     /foo/i
    //     ^^^^^^
    public static final class RegularExpressionNode extends Node {
        public final Token opening;
        public final Token content;
        public final Token closing;
        public final byte[] unescaped;

        public RegularExpressionNode(Token opening, Token content, Token closing, byte[] unescaped, int startOffset, int endOffset) {
            super(startOffset, endOffset);
            this.opening =  opening;
            this.content =  content;
            this.closing =  closing;
            this.unescaped =  unescaped;
        }

        public Node[] childNodes() {
            return EMPTY_ARRAY;
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitRegularExpressionNode(this);
        }
    }

    // Represents a destructured required parameter node.
    // 
    //     def foo((bar, baz))
    //             ^^^^^^^^^^
    //     end
    public static final class RequiredDestructuredParameterNode extends Node {
        public final Node[] parameters;
        public final Token opening;
        public final Token closing;

        public RequiredDestructuredParameterNode(Node[] parameters, Token opening, Token closing, int startOffset, int endOffset) {
            super(startOffset, endOffset);
            this.parameters =  parameters;
            this.opening =  opening;
            this.closing =  closing;
        }

        public Node[] childNodes() {
            return parameters;
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitRequiredDestructuredParameterNode(this);
        }
    }

    // Represents a required parameter to a method, block, or lambda definition.
    // 
    //     def a(b)
    //           ^
    //     end
    public static final class RequiredParameterNode extends Node {

        public RequiredParameterNode(int startOffset, int endOffset) {
            super(startOffset, endOffset);
        }

        public Node[] childNodes() {
            return EMPTY_ARRAY;
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitRequiredParameterNode(this);
        }
    }

    // Represents an expression modified with a rescue.
    // 
    //   foo rescue nil
    //   ^^^^^^^^^^^^^^
    public static final class RescueModifierNode extends Node {
        public final Node expression;
        public final Token rescue_keyword;
        public final Node rescue_expression;

        public RescueModifierNode(Node expression, Token rescue_keyword, Node rescue_expression, int startOffset, int endOffset) {
            super(startOffset, endOffset);
            this.expression =  expression;
            this.rescue_keyword =  rescue_keyword;
            this.rescue_expression =  rescue_expression;
        }

        public Node[] childNodes() {
            return new Node[] { expression, rescue_expression };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitRescueModifierNode(this);
        }
    }

    // Represents a rescue statement.
    // 
    //     begin
    //     rescue
    //       foo
    //     ^^^^^^
    //     end
    public static final class RescueNode extends Node {
        public final Token rescue_keyword;
        public final Node[] exceptions;
        public final Token equal_greater; // optional
        public final Node exception; // optional
        public final StatementsNode statements; // optional
        public final RescueNode consequent; // optional

        public RescueNode(Token rescue_keyword, Node[] exceptions, Token equal_greater, Node exception, Node statements, Node consequent, int startOffset, int endOffset) {
            super(startOffset, endOffset);
            this.rescue_keyword =  rescue_keyword;
            this.exceptions =  exceptions;
            this.equal_greater =  equal_greater;
            this.exception =  exception;
            this.statements = (StatementsNode) statements;
            this.consequent = (RescueNode) consequent;
        }

        public Node[] childNodes() {
            ArrayList<Node> childNodes = new ArrayList<>();
            childNodes.addAll(Arrays.asList(exceptions));
            childNodes.add(exception);
            childNodes.add(statements);
            childNodes.add(consequent);
            return childNodes.toArray(EMPTY_ARRAY);
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitRescueNode(this);
        }
    }

    // Represents a rest parameter to a method, block, or lambda definition.
    // 
    //     def a(*b)
    //           ^^
    //     end
    public static final class RestParameterNode extends Node {
        public final Token operator;
        public final Token name; // optional

        public RestParameterNode(Token operator, Token name, int startOffset, int endOffset) {
            super(startOffset, endOffset);
            this.operator =  operator;
            this.name =  name;
        }

        public Node[] childNodes() {
            return EMPTY_ARRAY;
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitRestParameterNode(this);
        }
    }

    // Represents the use of the `retry` keyword.
    // 
    //     retry
    //     ^^^^^
    public static final class RetryNode extends Node {

        public RetryNode(int startOffset, int endOffset) {
            super(startOffset, endOffset);
        }

        public Node[] childNodes() {
            return EMPTY_ARRAY;
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitRetryNode(this);
        }
    }

    // Represents the use of the `return` keyword.
    // 
    //     return 1
    //     ^^^^^^^^
    public static final class ReturnNode extends Node {
        public final Token keyword;
        public final ArgumentsNode arguments; // optional

        public ReturnNode(Token keyword, Node arguments, int startOffset, int endOffset) {
            super(startOffset, endOffset);
            this.keyword =  keyword;
            this.arguments = (ArgumentsNode) arguments;
        }

        public Node[] childNodes() {
            return new Node[] { arguments };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitReturnNode(this);
        }
    }

    // Represents the local variables within a given lexical scope. These are
    // attached to nodes where a new scope is created.
    public static final class ScopeNode extends Node {
        public final Token[] locals;

        public ScopeNode(Token[] locals, int startOffset, int endOffset) {
            super(startOffset, endOffset);
            this.locals =  locals;
        }

        public Node[] childNodes() {
            return EMPTY_ARRAY;
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitScopeNode(this);
        }
    }

    // Represents the `self` keyword.
    // 
    //     self
    //     ^^^^
    public static final class SelfNode extends Node {

        public SelfNode(int startOffset, int endOffset) {
            super(startOffset, endOffset);
        }

        public Node[] childNodes() {
            return EMPTY_ARRAY;
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitSelfNode(this);
        }
    }

    // Represents a singleton class declaration involving the `class` keyword.
    // 
    //     class << self end
    //     ^^^^^^^^^^^^^^^^^
    public static final class SingletonClassNode extends Node {
        public final StaticScope scope;
        public final Token class_keyword;
        public final Token operator;
        public final Node expression;
        public final Node statements; // optional
        public final Token end_keyword;

        public SingletonClassNode(StaticScope scope, Token class_keyword, Token operator, Node expression, Node statements, Token end_keyword, int startOffset, int endOffset) {
            super(startOffset, endOffset);
            this.scope =  scope;
            this.class_keyword =  class_keyword;
            this.operator =  operator;
            this.expression =  expression;
            this.statements =  statements;
            this.end_keyword =  end_keyword;
        }

        public Node[] childNodes() {
            return new Node[] { expression, statements };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitSingletonClassNode(this);
        }
    }

    // Represents the use of the `__ENCODING__` keyword.
    // 
    //     __ENCODING__
    //     ^^^^^^^^^^^^
    public static final class SourceEncodingNode extends Node {

        public SourceEncodingNode(int startOffset, int endOffset) {
            super(startOffset, endOffset);
        }

        public Node[] childNodes() {
            return EMPTY_ARRAY;
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitSourceEncodingNode(this);
        }
    }

    // Represents the use of the `__FILE__` keyword.
    // 
    //     __FILE__
    //     ^^^^^^^^
    public static final class SourceFileNode extends Node {

        public SourceFileNode(int startOffset, int endOffset) {
            super(startOffset, endOffset);
        }

        public Node[] childNodes() {
            return EMPTY_ARRAY;
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitSourceFileNode(this);
        }
    }

    // Represents the use of the `__LINE__` keyword.
    // 
    //     __LINE__
    //     ^^^^^^^^
    public static final class SourceLineNode extends Node {

        public SourceLineNode(int startOffset, int endOffset) {
            super(startOffset, endOffset);
        }

        public Node[] childNodes() {
            return EMPTY_ARRAY;
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitSourceLineNode(this);
        }
    }

    // Represents the use of the splat operator.
    // 
    //     [*a]
    //      ^^
    public static final class SplatNode extends Node {
        public final Token operator;
        public final Node expression; // optional

        public SplatNode(Token operator, Node expression, int startOffset, int endOffset) {
            super(startOffset, endOffset);
            this.operator =  operator;
            this.expression =  expression;
        }

        public Node[] childNodes() {
            return new Node[] { expression };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitSplatNode(this);
        }
    }

    // Represents a set of statements contained within some scope.
    // 
    //     foo; bar; baz
    //     ^^^^^^^^^^^^^
    public static final class StatementsNode extends Node {
        public final Node[] body;

        public StatementsNode(Node[] body, int startOffset, int endOffset) {
            super(startOffset, endOffset);
            this.body =  body;
        }

        public Node[] childNodes() {
            return body;
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitStatementsNode(this);
        }
    }

    // Represents the use of compile-time string concatenation.
    // 
    //     "foo" "bar"
    //     ^^^^^^^^^^^
    public static final class StringConcatNode extends Node {
        public final Node left;
        public final Node right;

        public StringConcatNode(Node left, Node right, int startOffset, int endOffset) {
            super(startOffset, endOffset);
            this.left =  left;
            this.right =  right;
        }

        public Node[] childNodes() {
            return new Node[] { left, right };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitStringConcatNode(this);
        }
    }

    // Represents an interpolated set of statements within a string.
    // 
    //     "foo #{bar}"
    //          ^^^^^^
    public static final class StringInterpolatedNode extends Node {
        public final Token opening;
        public final StatementsNode statements; // optional
        public final Token closing;

        public StringInterpolatedNode(Token opening, Node statements, Token closing, int startOffset, int endOffset) {
            super(startOffset, endOffset);
            this.opening =  opening;
            this.statements = (StatementsNode) statements;
            this.closing =  closing;
        }

        public Node[] childNodes() {
            return new Node[] { statements };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitStringInterpolatedNode(this);
        }
    }

    // Represents a string literal, a string contained within a `%w` list, or
    // plain string content within an interpolated string.
    // 
    //     "foo"
    //     ^^^^^
    // 
    //     %w[foo]
    //        ^^^
    // 
    //     "foo #{bar} baz"
    //      ^^^^      ^^^^
    public static final class StringNode extends Node {
        public final Token opening; // optional
        public final Token content;
        public final Token closing; // optional
        public final byte[] unescaped;

        public StringNode(Token opening, Token content, Token closing, byte[] unescaped, int startOffset, int endOffset) {
            super(startOffset, endOffset);
            this.opening =  opening;
            this.content =  content;
            this.closing =  closing;
            this.unescaped =  unescaped;
        }

        public Node[] childNodes() {
            return EMPTY_ARRAY;
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitStringNode(this);
        }
    }

    // Represents the use of the `super` keyword with parentheses or arguments.
    // 
    //     super()
    //     ^^^^^^^
    // 
    //     super foo, bar
    //     ^^^^^^^^^^^^^^
    public static final class SuperNode extends Node {
        public final Token keyword;
        public final Token lparen; // optional
        public final ArgumentsNode arguments; // optional
        public final Token rparen; // optional
        public final BlockNode block; // optional

        public SuperNode(Token keyword, Token lparen, Node arguments, Token rparen, Node block, int startOffset, int endOffset) {
            super(startOffset, endOffset);
            this.keyword =  keyword;
            this.lparen =  lparen;
            this.arguments = (ArgumentsNode) arguments;
            this.rparen =  rparen;
            this.block = (BlockNode) block;
        }

        public Node[] childNodes() {
            return new Node[] { arguments, block };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitSuperNode(this);
        }
    }

    // Represents a symbol literal or a symbol contained within a `%i` list.
    // 
    //     :foo
    //     ^^^^
    // 
    //     %i[foo]
    //        ^^^
    public static final class SymbolNode extends Node {
        public final Token opening; // optional
        public final Token value;
        public final Token closing; // optional
        public final byte[] unescaped;

        public SymbolNode(Token opening, Token value, Token closing, byte[] unescaped, int startOffset, int endOffset) {
            super(startOffset, endOffset);
            this.opening =  opening;
            this.value =  value;
            this.closing =  closing;
            this.unescaped =  unescaped;
        }

        public Node[] childNodes() {
            return EMPTY_ARRAY;
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitSymbolNode(this);
        }
    }

    // Represents the use of the literal `true` keyword.
    // 
    //     true
    //     ^^^^
    public static final class TrueNode extends Node {

        public TrueNode(int startOffset, int endOffset) {
            super(startOffset, endOffset);
        }

        public Node[] childNodes() {
            return EMPTY_ARRAY;
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitTrueNode(this);
        }
    }

    // Represents the use of the `undef` keyword.
    // 
    //     undef :foo, :bar, :baz
    //     ^^^^^^^^^^^^^^^^^^^^^^
    public static final class UndefNode extends Node {
        public final Node[] names;
        public final Location keyword_loc;

        public UndefNode(Node[] names, Location keyword_loc, int startOffset, int endOffset) {
            super(startOffset, endOffset);
            this.names =  names;
            this.keyword_loc =  keyword_loc;
        }

        public Node[] childNodes() {
            return names;
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitUndefNode(this);
        }
    }

    // Represents the use of the `unless` keyword, either in the block form or the modifier form.
    // 
    //     bar unless foo
    //     ^^^^^^^^^^^^^^
    // 
    //     unless foo then bar end
    //     ^^^^^^^^^^^^^^^^^^^^^^^
    public static final class UnlessNode extends Node {
        public final Token keyword;
        public final Node predicate;
        public final StatementsNode statements; // optional
        public final ElseNode consequent; // optional
        public final Token end_keyword; // optional

        public UnlessNode(Token keyword, Node predicate, Node statements, Node consequent, Token end_keyword, int startOffset, int endOffset) {
            super(startOffset, endOffset);
            this.keyword =  keyword;
            this.predicate =  predicate;
            this.statements = (StatementsNode) statements;
            this.consequent = (ElseNode) consequent;
            this.end_keyword =  end_keyword;
        }

        public Node[] childNodes() {
            return new Node[] { predicate, statements, consequent };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitUnlessNode(this);
        }
    }

    // Represents the use of the `until` keyword, either in the block form or the modifier form.
    // 
    //     bar until foo
    //     ^^^^^^^^^^^^^
    // 
    //     until foo do bar end
    //     ^^^^^^^^^^^^^^^^^^^^
    public static final class UntilNode extends Node {
        public final Token keyword;
        public final Node predicate;
        public final StatementsNode statements; // optional

        public UntilNode(Token keyword, Node predicate, Node statements, int startOffset, int endOffset) {
            super(startOffset, endOffset);
            this.keyword =  keyword;
            this.predicate =  predicate;
            this.statements = (StatementsNode) statements;
        }

        public Node[] childNodes() {
            return new Node[] { predicate, statements };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitUntilNode(this);
        }
    }

    // case true
    // when true
    // ^^^^^^^^^
    // end
    public static final class WhenNode extends Node {
        public final Token when_keyword;
        public final Node[] conditions;
        public final StatementsNode statements; // optional

        public WhenNode(Token when_keyword, Node[] conditions, Node statements, int startOffset, int endOffset) {
            super(startOffset, endOffset);
            this.when_keyword =  when_keyword;
            this.conditions =  conditions;
            this.statements = (StatementsNode) statements;
        }

        public Node[] childNodes() {
            ArrayList<Node> childNodes = new ArrayList<>();
            childNodes.addAll(Arrays.asList(conditions));
            childNodes.add(statements);
            return childNodes.toArray(EMPTY_ARRAY);
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitWhenNode(this);
        }
    }

    // Represents the use of the `while` keyword, either in the block form or the modifier form.
    // 
    //     bar while foo
    //     ^^^^^^^^^^^^^
    // 
    //     while foo do bar end
    //     ^^^^^^^^^^^^^^^^^^^^
    public static final class WhileNode extends Node {
        public final Token keyword;
        public final Node predicate;
        public final StatementsNode statements; // optional

        public WhileNode(Token keyword, Node predicate, Node statements, int startOffset, int endOffset) {
            super(startOffset, endOffset);
            this.keyword =  keyword;
            this.predicate =  predicate;
            this.statements = (StatementsNode) statements;
        }

        public Node[] childNodes() {
            return new Node[] { predicate, statements };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitWhileNode(this);
        }
    }

    // Represents an xstring literal with no interpolation.
    // 
    //     `foo`
    //     ^^^^^
    public static final class XStringNode extends Node {
        public final Token opening;
        public final Token content;
        public final Token closing;
        public final byte[] unescaped;

        public XStringNode(Token opening, Token content, Token closing, byte[] unescaped, int startOffset, int endOffset) {
            super(startOffset, endOffset);
            this.opening =  opening;
            this.content =  content;
            this.closing =  closing;
            this.unescaped =  unescaped;
        }

        public Node[] childNodes() {
            return EMPTY_ARRAY;
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitXStringNode(this);
        }
    }

    // Represents the use of the `yield` keyword.
    // 
    //     yield 1
    //     ^^^^^^^
    public static final class YieldNode extends Node {
        public final Token keyword;
        public final Token lparen; // optional
        public final ArgumentsNode arguments; // optional
        public final Token rparen; // optional

        public YieldNode(Token keyword, Token lparen, Node arguments, Token rparen, int startOffset, int endOffset) {
            super(startOffset, endOffset);
            this.keyword =  keyword;
            this.lparen =  lparen;
            this.arguments = (ArgumentsNode) arguments;
            this.rparen =  rparen;
        }

        public Node[] childNodes() {
            return new Node[] { arguments };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitYieldNode(this);
        }
    }

}
// @formatter:on
