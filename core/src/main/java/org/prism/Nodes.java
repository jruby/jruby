/******************************************************************************/
/* This file is generated by the templates/template.rb script and should not  */
/* be modified manually. See                                                  */
/* templates/java/org/prism/Nodes.java.erb                                    */
/* if you are looking to modify the                                           */
/* template                                                                   */
/******************************************************************************/
package org.prism;

import java.lang.Override;
import java.lang.String;
import java.lang.StringBuilder;
import java.nio.charset.StandardCharsets;
import java.util.ArrayList;
import java.util.Arrays;

// GENERATED BY Nodes.java.erb
// @formatter:off
public abstract class Nodes {

    public static final byte[][] EMPTY_BYTE_ARRAY_ARRAY = {};
    public static final org.jruby.RubySymbol[] EMPTY_STRING_ARRAY = {};

    public static final class Location {

        public static final Location[] EMPTY_ARRAY = {};

        public final int startOffset;
        public final int length;

        public Location(int startOffset, int length) {
            this.startOffset = startOffset;
            this.length = length;
        }

        public int endOffset() {
            return startOffset + length;
        }
    }

    public static final class Source {
        public final byte[] bytes;
        private int startLine;
        private final int[] lineOffsets;

        public Source(byte[] bytes) {
            this(bytes, 1, computeLineOffsets(bytes));
        }

        public Source(byte[] bytes, int startLine, int[] lineOffsets) {
            assert lineOffsets[0] == 0;
            this.bytes = bytes;
            this.startLine = startLine;
            this.lineOffsets = lineOffsets;
        }

        public void setStartLine(int startLine) {
            this.startLine = startLine;
        }

        public static int[] computeLineOffsets(byte[] bytes) {
            int[] lineOffsets = new int[8];
            int lineOffsetsSize = 0;
            lineOffsets[lineOffsetsSize++] = 0;

            for (int i = 0; i < bytes.length; i++) {
                if (bytes[i] == '\n') {
                    if (lineOffsetsSize == lineOffsets.length) {
                        lineOffsets = Arrays.copyOf(lineOffsets, lineOffsets.length * 2);
                    }
                    lineOffsets[lineOffsetsSize++] = i + 1;
                }
            }
            return Arrays.copyOf(lineOffsets, lineOffsetsSize);
        }

        // 1-based
        public int line(int byteOffset) {
            return startLine + findLine(byteOffset);
        }

        // 0-based
        public int findLine(int byteOffset) {
            if (byteOffset >= bytes.length) byteOffset = bytes.length - 1;
            assert byteOffset >= 0 : byteOffset;
            int index = Arrays.binarySearch(lineOffsets, byteOffset);
            int line;
            if (index < 0) {
                line = -index - 2;
            } else {
                line = index;
            }
            assert line >= 0 && line <= getLineCount() : line;
            return line;
        }

        public int getLineCount() {
            return lineOffsets.length;
        }
    }

    public static abstract class Node {

        public static final Node[] EMPTY_ARRAY = {};

        public final int startOffset;
        public final int length;
        private boolean newLineFlag = false;

        public Node(int startOffset, int length) {
            this.startOffset = startOffset;
            this.length = length;
        }

        public final int endOffset() {
            return startOffset + length;
        }

        public final boolean hasNewLineFlag() {
            return newLineFlag;
        }

        public void setNewLineFlag(Source source, boolean[] newlineMarked) {
            int line = source.findLine(this.startOffset);
            if (!newlineMarked[line]) {
                newlineMarked[line] = true;
                this.newLineFlag = true;
            }
        }

        public void setNewLineFlag(boolean newLineFlag) {
            this.newLineFlag = newLineFlag;
        }

        public abstract <T> T accept(AbstractNodeVisitor<T> visitor);

        public abstract <T> void visitChildNodes(AbstractNodeVisitor<T> visitor);

        public abstract Node[] childNodes();

        @Override
        public String toString() {
            return toString("");
        }

        protected abstract String toString(String indent);
    }

    /**
     * Flags for arguments nodes.
     */
    public static final class ArgumentsNodeFlags implements Comparable<ArgumentsNodeFlags> {

        // if arguments contain keyword splat
        public static final short CONTAINS_KEYWORD_SPLAT = 1 << 0;

        public static boolean isContainsKeywordSplat(short flags) {
            return (flags & CONTAINS_KEYWORD_SPLAT) != 0;
        }

        private final short flags;

        public ArgumentsNodeFlags(short flags) {
            this.flags = flags;
        }

        @Override
        public int hashCode() {
            return flags;
        }

        @Override
        public boolean equals(Object other) {
            if (!(other instanceof ArgumentsNodeFlags)) {
                return false;
            }

            return flags == ((ArgumentsNodeFlags) other).flags;
        }

        @Override
        public int compareTo(ArgumentsNodeFlags other) {
            return flags - other.flags;
        }

        public boolean isContainsKeywordSplat() {
            return (flags & CONTAINS_KEYWORD_SPLAT) != 0;
        }

    }

    /**
     * Flags for array nodes.
     */
    public static final class ArrayNodeFlags implements Comparable<ArrayNodeFlags> {

        // if array contains splat nodes
        public static final short CONTAINS_SPLAT = 1 << 0;

        public static boolean isContainsSplat(short flags) {
            return (flags & CONTAINS_SPLAT) != 0;
        }

        private final short flags;

        public ArrayNodeFlags(short flags) {
            this.flags = flags;
        }

        @Override
        public int hashCode() {
            return flags;
        }

        @Override
        public boolean equals(Object other) {
            if (!(other instanceof ArrayNodeFlags)) {
                return false;
            }

            return flags == ((ArrayNodeFlags) other).flags;
        }

        @Override
        public int compareTo(ArrayNodeFlags other) {
            return flags - other.flags;
        }

        public boolean isContainsSplat() {
            return (flags & CONTAINS_SPLAT) != 0;
        }

    }

    /**
     * Flags for call nodes.
     */
    public static final class CallNodeFlags implements Comparable<CallNodeFlags> {

        // &. operator
        public static final short SAFE_NAVIGATION = 1 << 0;

        // a call that could have been a local variable
        public static final short VARIABLE_CALL = 1 << 1;

        public static boolean isSafeNavigation(short flags) {
            return (flags & SAFE_NAVIGATION) != 0;
        }

        public static boolean isVariableCall(short flags) {
            return (flags & VARIABLE_CALL) != 0;
        }

        private final short flags;

        public CallNodeFlags(short flags) {
            this.flags = flags;
        }

        @Override
        public int hashCode() {
            return flags;
        }

        @Override
        public boolean equals(Object other) {
            if (!(other instanceof CallNodeFlags)) {
                return false;
            }

            return flags == ((CallNodeFlags) other).flags;
        }

        @Override
        public int compareTo(CallNodeFlags other) {
            return flags - other.flags;
        }

        public boolean isSafeNavigation() {
            return (flags & SAFE_NAVIGATION) != 0;
        }

        public boolean isVariableCall() {
            return (flags & VARIABLE_CALL) != 0;
        }

    }

    /**
     * Flags for integer nodes that correspond to the base of the integer.
     */
    public static final class IntegerBaseFlags implements Comparable<IntegerBaseFlags> {

        // 0b prefix
        public static final short BINARY = 1 << 0;

        // 0o or 0 prefix
        public static final short OCTAL = 1 << 1;

        // 0d or no prefix
        public static final short DECIMAL = 1 << 2;

        // 0x prefix
        public static final short HEXADECIMAL = 1 << 3;

        public static boolean isBinary(short flags) {
            return (flags & BINARY) != 0;
        }

        public static boolean isOctal(short flags) {
            return (flags & OCTAL) != 0;
        }

        public static boolean isDecimal(short flags) {
            return (flags & DECIMAL) != 0;
        }

        public static boolean isHexadecimal(short flags) {
            return (flags & HEXADECIMAL) != 0;
        }

        private final short flags;

        public IntegerBaseFlags(short flags) {
            this.flags = flags;
        }

        @Override
        public int hashCode() {
            return flags;
        }

        @Override
        public boolean equals(Object other) {
            if (!(other instanceof IntegerBaseFlags)) {
                return false;
            }

            return flags == ((IntegerBaseFlags) other).flags;
        }

        @Override
        public int compareTo(IntegerBaseFlags other) {
            return flags - other.flags;
        }

        public boolean isBinary() {
            return (flags & BINARY) != 0;
        }

        public boolean isOctal() {
            return (flags & OCTAL) != 0;
        }

        public boolean isDecimal() {
            return (flags & DECIMAL) != 0;
        }

        public boolean isHexadecimal() {
            return (flags & HEXADECIMAL) != 0;
        }

    }

    /**
     * Flags for while and until loop nodes.
     */
    public static final class LoopFlags implements Comparable<LoopFlags> {

        // a loop after a begin statement, so the body is executed first before the condition
        public static final short BEGIN_MODIFIER = 1 << 0;

        public static boolean isBeginModifier(short flags) {
            return (flags & BEGIN_MODIFIER) != 0;
        }

        private final short flags;

        public LoopFlags(short flags) {
            this.flags = flags;
        }

        @Override
        public int hashCode() {
            return flags;
        }

        @Override
        public boolean equals(Object other) {
            if (!(other instanceof LoopFlags)) {
                return false;
            }

            return flags == ((LoopFlags) other).flags;
        }

        @Override
        public int compareTo(LoopFlags other) {
            return flags - other.flags;
        }

        public boolean isBeginModifier() {
            return (flags & BEGIN_MODIFIER) != 0;
        }

    }

    /**
     * Flags for range and flip-flop nodes.
     */
    public static final class RangeFlags implements Comparable<RangeFlags> {

        // ... operator
        public static final short EXCLUDE_END = 1 << 0;

        public static boolean isExcludeEnd(short flags) {
            return (flags & EXCLUDE_END) != 0;
        }

        private final short flags;

        public RangeFlags(short flags) {
            this.flags = flags;
        }

        @Override
        public int hashCode() {
            return flags;
        }

        @Override
        public boolean equals(Object other) {
            if (!(other instanceof RangeFlags)) {
                return false;
            }

            return flags == ((RangeFlags) other).flags;
        }

        @Override
        public int compareTo(RangeFlags other) {
            return flags - other.flags;
        }

        public boolean isExcludeEnd() {
            return (flags & EXCLUDE_END) != 0;
        }

    }

    /**
     * Flags for regular expression and match last line nodes.
     */
    public static final class RegularExpressionFlags implements Comparable<RegularExpressionFlags> {

        // i - ignores the case of characters when matching
        public static final short IGNORE_CASE = 1 << 0;

        // x - ignores whitespace and allows comments in regular expressions
        public static final short EXTENDED = 1 << 1;

        // m - allows $ to match the end of lines within strings
        public static final short MULTI_LINE = 1 << 2;

        // o - only interpolates values into the regular expression once
        public static final short ONCE = 1 << 3;

        // e - forces the EUC-JP encoding
        public static final short EUC_JP = 1 << 4;

        // n - forces the ASCII-8BIT encoding
        public static final short ASCII_8BIT = 1 << 5;

        // s - forces the Windows-31J encoding
        public static final short WINDOWS_31J = 1 << 6;

        // u - forces the UTF-8 encoding
        public static final short UTF_8 = 1 << 7;

        public static boolean isIgnoreCase(short flags) {
            return (flags & IGNORE_CASE) != 0;
        }

        public static boolean isExtended(short flags) {
            return (flags & EXTENDED) != 0;
        }

        public static boolean isMultiLine(short flags) {
            return (flags & MULTI_LINE) != 0;
        }

        public static boolean isOnce(short flags) {
            return (flags & ONCE) != 0;
        }

        public static boolean isEucJp(short flags) {
            return (flags & EUC_JP) != 0;
        }

        public static boolean isAscii8bit(short flags) {
            return (flags & ASCII_8BIT) != 0;
        }

        public static boolean isWindows31j(short flags) {
            return (flags & WINDOWS_31J) != 0;
        }

        public static boolean isUtf8(short flags) {
            return (flags & UTF_8) != 0;
        }

        private final short flags;

        public RegularExpressionFlags(short flags) {
            this.flags = flags;
        }

        @Override
        public int hashCode() {
            return flags;
        }

        @Override
        public boolean equals(Object other) {
            if (!(other instanceof RegularExpressionFlags)) {
                return false;
            }

            return flags == ((RegularExpressionFlags) other).flags;
        }

        @Override
        public int compareTo(RegularExpressionFlags other) {
            return flags - other.flags;
        }

        public boolean isIgnoreCase() {
            return (flags & IGNORE_CASE) != 0;
        }

        public boolean isExtended() {
            return (flags & EXTENDED) != 0;
        }

        public boolean isMultiLine() {
            return (flags & MULTI_LINE) != 0;
        }

        public boolean isOnce() {
            return (flags & ONCE) != 0;
        }

        public boolean isEucJp() {
            return (flags & EUC_JP) != 0;
        }

        public boolean isAscii8bit() {
            return (flags & ASCII_8BIT) != 0;
        }

        public boolean isWindows31j() {
            return (flags & WINDOWS_31J) != 0;
        }

        public boolean isUtf8() {
            return (flags & UTF_8) != 0;
        }

    }

    /**
     * Flags for string nodes.
     */
    public static final class StringFlags implements Comparable<StringFlags> {

        // frozen by virtue of a `frozen_string_literal` comment
        public static final short FROZEN = 1 << 0;

        public static boolean isFrozen(short flags) {
            return (flags & FROZEN) != 0;
        }

        private final short flags;

        public StringFlags(short flags) {
            this.flags = flags;
        }

        @Override
        public int hashCode() {
            return flags;
        }

        @Override
        public boolean equals(Object other) {
            if (!(other instanceof StringFlags)) {
                return false;
            }

            return flags == ((StringFlags) other).flags;
        }

        @Override
        public int compareTo(StringFlags other) {
            return flags - other.flags;
        }

        public boolean isFrozen() {
            return (flags & FROZEN) != 0;
        }

    }

    /**
     * Represents the use of the `alias` keyword to alias a global variable.
     *
     *     alias $foo $bar
     *     ^^^^^^^^^^^^^^^
     */
    public static final class AliasGlobalVariableNode extends Node {
        public final Node new_name;
        public final Node old_name;

        public AliasGlobalVariableNode(Node new_name, Node old_name, int startOffset, int length) {
            super(startOffset, length);
            this.new_name = new_name;
            this.old_name = old_name;
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
            this.new_name.accept(visitor);
            this.old_name.accept(visitor);
        }

        public Node[] childNodes() {
            return new Node[] { this.new_name, this.old_name };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitAliasGlobalVariableNode(this);
        }

        @Override
        protected String toString(String indent) {
            StringBuilder builder = new StringBuilder();
            builder.append(this.getClass().getSimpleName());
            if (hasNewLineFlag()) {
                builder.append("[Li]");
            }
            builder.append('\n');
            String nextIndent = indent + "  ";
            builder.append(nextIndent);
            builder.append("new_name: ");
            builder.append(this.new_name.toString(nextIndent));
            builder.append(nextIndent);
            builder.append("old_name: ");
            builder.append(this.old_name.toString(nextIndent));
            return builder.toString();
        }
    }

    /**
     * Represents the use of the `alias` keyword to alias a method.
     *
     *     alias foo bar
     *     ^^^^^^^^^^^^^
     */
    public static final class AliasMethodNode extends Node {
        public final Node new_name;
        public final Node old_name;

        public AliasMethodNode(Node new_name, Node old_name, int startOffset, int length) {
            super(startOffset, length);
            this.new_name = new_name;
            this.old_name = old_name;
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
            this.new_name.accept(visitor);
            this.old_name.accept(visitor);
        }

        public Node[] childNodes() {
            return new Node[] { this.new_name, this.old_name };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitAliasMethodNode(this);
        }

        @Override
        protected String toString(String indent) {
            StringBuilder builder = new StringBuilder();
            builder.append(this.getClass().getSimpleName());
            if (hasNewLineFlag()) {
                builder.append("[Li]");
            }
            builder.append('\n');
            String nextIndent = indent + "  ";
            builder.append(nextIndent);
            builder.append("new_name: ");
            builder.append(this.new_name.toString(nextIndent));
            builder.append(nextIndent);
            builder.append("old_name: ");
            builder.append(this.old_name.toString(nextIndent));
            return builder.toString();
        }
    }

    /**
     * Represents an alternation pattern in pattern matching.
     *
     *     foo => bar | baz
     *            ^^^^^^^^^
     */
    public static final class AlternationPatternNode extends Node {
        public final Node left;
        public final Node right;

        public AlternationPatternNode(Node left, Node right, int startOffset, int length) {
            super(startOffset, length);
            this.left = left;
            this.right = right;
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
            this.left.accept(visitor);
            this.right.accept(visitor);
        }

        public Node[] childNodes() {
            return new Node[] { this.left, this.right };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitAlternationPatternNode(this);
        }

        @Override
        protected String toString(String indent) {
            StringBuilder builder = new StringBuilder();
            builder.append(this.getClass().getSimpleName());
            if (hasNewLineFlag()) {
                builder.append("[Li]");
            }
            builder.append('\n');
            String nextIndent = indent + "  ";
            builder.append(nextIndent);
            builder.append("left: ");
            builder.append(this.left.toString(nextIndent));
            builder.append(nextIndent);
            builder.append("right: ");
            builder.append(this.right.toString(nextIndent));
            return builder.toString();
        }
    }

    /**
     * Represents the use of the `&&` operator or the `and` keyword.
     *
     *     left and right
     *     ^^^^^^^^^^^^^^
     */
    public static final class AndNode extends Node {
        public final Node left;
        public final Node right;

        public AndNode(Node left, Node right, int startOffset, int length) {
            super(startOffset, length);
            this.left = left;
            this.right = right;
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
            this.left.accept(visitor);
            this.right.accept(visitor);
        }

        public Node[] childNodes() {
            return new Node[] { this.left, this.right };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitAndNode(this);
        }

        @Override
        protected String toString(String indent) {
            StringBuilder builder = new StringBuilder();
            builder.append(this.getClass().getSimpleName());
            if (hasNewLineFlag()) {
                builder.append("[Li]");
            }
            builder.append('\n');
            String nextIndent = indent + "  ";
            builder.append(nextIndent);
            builder.append("left: ");
            builder.append(this.left.toString(nextIndent));
            builder.append(nextIndent);
            builder.append("right: ");
            builder.append(this.right.toString(nextIndent));
            return builder.toString();
        }
    }

    /**
     * Represents a set of arguments to a method or a keyword.
     *
     *     return foo, bar, baz
     *            ^^^^^^^^^^^^^
     */
    public static final class ArgumentsNode extends Node {
        public final Node[] arguments;
        public final short flags;

        public ArgumentsNode(Node[] arguments, short flags, int startOffset, int length) {
            super(startOffset, length);
            this.arguments = arguments;
            this.flags = flags;
        }
        
        public boolean isContainsKeywordSplat() {
            return ArgumentsNodeFlags.isContainsKeywordSplat(this.flags);
        }
        
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
            for (Nodes.Node child : this.arguments) {
                child.accept(visitor);
            }
        }

        public Node[] childNodes() {
            return this.arguments;
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitArgumentsNode(this);
        }

        @Override
        protected String toString(String indent) {
            StringBuilder builder = new StringBuilder();
            builder.append(this.getClass().getSimpleName());
            if (hasNewLineFlag()) {
                builder.append("[Li]");
            }
            builder.append('\n');
            String nextIndent = indent + "  ";
            String nextNextIndent = nextIndent + "  ";
            builder.append(nextIndent);
            builder.append("arguments: ");
            builder.append('\n');
            for (Node child : this.arguments) {
                builder.append(nextNextIndent).append(child.toString(nextNextIndent));
            }
            builder.append(nextIndent);
            builder.append("flags: ");
            builder.append(this.flags);
            builder.append('\n');
            return builder.toString();
        }
    }

    /**
     * Represents an array literal. This can be a regular array using brackets or
     * a special array using % like %w or %i.
     *
     *     [1, 2, 3]
     *     ^^^^^^^^^
     */
    public static final class ArrayNode extends Node {
        public final Node[] elements;
        public final short flags;

        public ArrayNode(Node[] elements, short flags, int startOffset, int length) {
            super(startOffset, length);
            this.elements = elements;
            this.flags = flags;
        }
        
        public boolean isContainsSplat() {
            return ArrayNodeFlags.isContainsSplat(this.flags);
        }
        
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
            for (Nodes.Node child : this.elements) {
                child.accept(visitor);
            }
        }

        public Node[] childNodes() {
            return this.elements;
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitArrayNode(this);
        }

        @Override
        protected String toString(String indent) {
            StringBuilder builder = new StringBuilder();
            builder.append(this.getClass().getSimpleName());
            if (hasNewLineFlag()) {
                builder.append("[Li]");
            }
            builder.append('\n');
            String nextIndent = indent + "  ";
            String nextNextIndent = nextIndent + "  ";
            builder.append(nextIndent);
            builder.append("elements: ");
            builder.append('\n');
            for (Node child : this.elements) {
                builder.append(nextNextIndent).append(child.toString(nextNextIndent));
            }
            builder.append(nextIndent);
            builder.append("flags: ");
            builder.append(this.flags);
            builder.append('\n');
            return builder.toString();
        }
    }

    /**
     * Represents an array pattern in pattern matching.
     *
     *     foo in 1, 2
     *     ^^^^^^^^^^^
     *
     *     foo in [1, 2]
     *     ^^^^^^^^^^^^^
     *
     *     foo in *1
     *     ^^^^^^^^^
     *
     *     foo in Bar[]
     *     ^^^^^^^^^^^^
     *
     *     foo in Bar[1, 2, 3]
     *     ^^^^^^^^^^^^^^^^^^^
     */
    public static final class ArrayPatternNode extends Node {
        /** optional (can be null) */
        public final Node constant;
        public final Node[] requireds;
        /** optional (can be null) */
        public final Node rest;
        public final Node[] posts;

        public ArrayPatternNode(Node constant, Node[] requireds, Node rest, Node[] posts, int startOffset, int length) {
            super(startOffset, length);
            this.constant = constant;
            this.requireds = requireds;
            this.rest = rest;
            this.posts = posts;
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
            if (this.constant != null) {
                this.constant.accept(visitor);
            }
            for (Nodes.Node child : this.requireds) {
                child.accept(visitor);
            }
            if (this.rest != null) {
                this.rest.accept(visitor);
            }
            for (Nodes.Node child : this.posts) {
                child.accept(visitor);
            }
        }

        public Node[] childNodes() {
            ArrayList<Node> childNodes = new ArrayList<>();
            childNodes.add(this.constant);
            childNodes.addAll(Arrays.asList(this.requireds));
            childNodes.add(this.rest);
            childNodes.addAll(Arrays.asList(this.posts));
            return childNodes.toArray(EMPTY_ARRAY);
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitArrayPatternNode(this);
        }

        @Override
        protected String toString(String indent) {
            StringBuilder builder = new StringBuilder();
            builder.append(this.getClass().getSimpleName());
            if (hasNewLineFlag()) {
                builder.append("[Li]");
            }
            builder.append('\n');
            String nextIndent = indent + "  ";
            String nextNextIndent = nextIndent + "  ";
            builder.append(nextIndent);
            builder.append("constant: ");
            builder.append(this.constant == null ? "null\n" : this.constant.toString(nextIndent));
            builder.append(nextIndent);
            builder.append("requireds: ");
            builder.append('\n');
            for (Node child : this.requireds) {
                builder.append(nextNextIndent).append(child.toString(nextNextIndent));
            }
            builder.append(nextIndent);
            builder.append("rest: ");
            builder.append(this.rest == null ? "null\n" : this.rest.toString(nextIndent));
            builder.append(nextIndent);
            builder.append("posts: ");
            builder.append('\n');
            for (Node child : this.posts) {
                builder.append(nextNextIndent).append(child.toString(nextNextIndent));
            }
            return builder.toString();
        }
    }

    /**
     * Represents a hash key/value pair.
     *
     *     { a => b }
     *       ^^^^^^
     */
    public static final class AssocNode extends Node {
        public final Node key;
        /** optional (can be null) */
        public final Node value;

        public AssocNode(Node key, Node value, int startOffset, int length) {
            super(startOffset, length);
            this.key = key;
            this.value = value;
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
            this.key.accept(visitor);
            if (this.value != null) {
                this.value.accept(visitor);
            }
        }

        public Node[] childNodes() {
            return new Node[] { this.key, this.value };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitAssocNode(this);
        }

        @Override
        protected String toString(String indent) {
            StringBuilder builder = new StringBuilder();
            builder.append(this.getClass().getSimpleName());
            if (hasNewLineFlag()) {
                builder.append("[Li]");
            }
            builder.append('\n');
            String nextIndent = indent + "  ";
            builder.append(nextIndent);
            builder.append("key: ");
            builder.append(this.key.toString(nextIndent));
            builder.append(nextIndent);
            builder.append("value: ");
            builder.append(this.value == null ? "null\n" : this.value.toString(nextIndent));
            return builder.toString();
        }
    }

    /**
     * Represents a splat in a hash literal.
     *
     *     { **foo }
     *       ^^^^^
     */
    public static final class AssocSplatNode extends Node {
        /** optional (can be null) */
        public final Node value;

        public AssocSplatNode(Node value, int startOffset, int length) {
            super(startOffset, length);
            this.value = value;
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
            if (this.value != null) {
                this.value.accept(visitor);
            }
        }

        public Node[] childNodes() {
            return new Node[] { this.value };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitAssocSplatNode(this);
        }

        @Override
        protected String toString(String indent) {
            StringBuilder builder = new StringBuilder();
            builder.append(this.getClass().getSimpleName());
            if (hasNewLineFlag()) {
                builder.append("[Li]");
            }
            builder.append('\n');
            String nextIndent = indent + "  ";
            builder.append(nextIndent);
            builder.append("value: ");
            builder.append(this.value == null ? "null\n" : this.value.toString(nextIndent));
            return builder.toString();
        }
    }

    /**
     * Represents reading a reference to a field in the previous match.
     *
     *     $'
     *     ^^
     */
    public static final class BackReferenceReadNode extends Node {
        public final org.jruby.RubySymbol name;

        public BackReferenceReadNode(org.jruby.RubySymbol name, int startOffset, int length) {
            super(startOffset, length);
            this.name = name;
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
        }

        public Node[] childNodes() {
            return EMPTY_ARRAY;
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitBackReferenceReadNode(this);
        }

        @Override
        protected String toString(String indent) {
            StringBuilder builder = new StringBuilder();
            builder.append(this.getClass().getSimpleName());
            if (hasNewLineFlag()) {
                builder.append("[Li]");
            }
            builder.append('\n');
            String nextIndent = indent + "  ";
            builder.append(nextIndent);
            builder.append("name: ");
            builder.append('"').append(this.name).append('"');
            builder.append('\n');
            return builder.toString();
        }
    }

    /**
     * Represents a begin statement.
     *
     *     begin
     *       foo
     *     end
     *     ^^^^^
     */
    public static final class BeginNode extends Node {
        /** optional (can be null) */
        public final StatementsNode statements;
        /** optional (can be null) */
        public final RescueNode rescue_clause;
        /** optional (can be null) */
        public final ElseNode else_clause;
        /** optional (can be null) */
        public final EnsureNode ensure_clause;

        public BeginNode(StatementsNode statements, RescueNode rescue_clause, ElseNode else_clause, EnsureNode ensure_clause, int startOffset, int length) {
            super(startOffset, length);
            this.statements = statements;
            this.rescue_clause = rescue_clause;
            this.else_clause = else_clause;
            this.ensure_clause = ensure_clause;
        }
                
        @Override
        public void setNewLineFlag(Source source, boolean[] newlineMarked) {
            // Never mark BeginNode with a newline flag, mark children instead
        }

        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
            if (this.statements != null) {
                this.statements.accept(visitor);
            }
            if (this.rescue_clause != null) {
                this.rescue_clause.accept(visitor);
            }
            if (this.else_clause != null) {
                this.else_clause.accept(visitor);
            }
            if (this.ensure_clause != null) {
                this.ensure_clause.accept(visitor);
            }
        }

        public Node[] childNodes() {
            return new Node[] { this.statements, this.rescue_clause, this.else_clause, this.ensure_clause };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitBeginNode(this);
        }

        @Override
        protected String toString(String indent) {
            StringBuilder builder = new StringBuilder();
            builder.append(this.getClass().getSimpleName());
            if (hasNewLineFlag()) {
                builder.append("[Li]");
            }
            builder.append('\n');
            String nextIndent = indent + "  ";
            builder.append(nextIndent);
            builder.append("statements: ");
            builder.append(this.statements == null ? "null\n" : this.statements.toString(nextIndent));
            builder.append(nextIndent);
            builder.append("rescue_clause: ");
            builder.append(this.rescue_clause == null ? "null\n" : this.rescue_clause.toString(nextIndent));
            builder.append(nextIndent);
            builder.append("else_clause: ");
            builder.append(this.else_clause == null ? "null\n" : this.else_clause.toString(nextIndent));
            builder.append(nextIndent);
            builder.append("ensure_clause: ");
            builder.append(this.ensure_clause == null ? "null\n" : this.ensure_clause.toString(nextIndent));
            return builder.toString();
        }
    }

    /**
     * Represents block method arguments.
     *
     *     bar(&args)
     *     ^^^^^^^^^^
     */
    public static final class BlockArgumentNode extends Node {
        /** optional (can be null) */
        public final Node expression;

        public BlockArgumentNode(Node expression, int startOffset, int length) {
            super(startOffset, length);
            this.expression = expression;
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
            if (this.expression != null) {
                this.expression.accept(visitor);
            }
        }

        public Node[] childNodes() {
            return new Node[] { this.expression };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitBlockArgumentNode(this);
        }

        @Override
        protected String toString(String indent) {
            StringBuilder builder = new StringBuilder();
            builder.append(this.getClass().getSimpleName());
            if (hasNewLineFlag()) {
                builder.append("[Li]");
            }
            builder.append('\n');
            String nextIndent = indent + "  ";
            builder.append(nextIndent);
            builder.append("expression: ");
            builder.append(this.expression == null ? "null\n" : this.expression.toString(nextIndent));
            return builder.toString();
        }
    }

    /**
     * Represents a block local variable.
     *
     *     a { |; b| }
     *            ^
     */
    public static final class BlockLocalVariableNode extends Node {
        public final org.jruby.RubySymbol name;

        public BlockLocalVariableNode(org.jruby.RubySymbol name, int startOffset, int length) {
            super(startOffset, length);
            this.name = name;
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
        }

        public Node[] childNodes() {
            return EMPTY_ARRAY;
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitBlockLocalVariableNode(this);
        }

        @Override
        protected String toString(String indent) {
            StringBuilder builder = new StringBuilder();
            builder.append(this.getClass().getSimpleName());
            if (hasNewLineFlag()) {
                builder.append("[Li]");
            }
            builder.append('\n');
            String nextIndent = indent + "  ";
            builder.append(nextIndent);
            builder.append("name: ");
            builder.append('"').append(this.name).append('"');
            builder.append('\n');
            return builder.toString();
        }
    }

    /**
     * Represents a block of ruby code.
     *
     * [1, 2, 3].each { |i| puts x }
     *                ^^^^^^^^^^^^^^
     */
    public static final class BlockNode extends Node {
        public final org.jruby.RubySymbol[] locals;
        /** optional (can be null) */
        public final Node parameters;
        /** optional (can be null) */
        public final Node body;

        public BlockNode(org.jruby.RubySymbol[] locals, Node parameters, Node body, int startOffset, int length) {
            super(startOffset, length);
            this.locals = locals;
            this.parameters = parameters;
            this.body = body;
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
            if (this.parameters != null) {
                this.parameters.accept(visitor);
            }
            if (this.body != null) {
                this.body.accept(visitor);
            }
        }

        public Node[] childNodes() {
            return new Node[] { this.parameters, this.body };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitBlockNode(this);
        }

        @Override
        protected String toString(String indent) {
            StringBuilder builder = new StringBuilder();
            builder.append(this.getClass().getSimpleName());
            if (hasNewLineFlag()) {
                builder.append("[Li]");
            }
            builder.append('\n');
            String nextIndent = indent + "  ";
            String nextNextIndent = nextIndent + "  ";
            builder.append(nextIndent);
            builder.append("locals: ");
            builder.append('\n');
            for (org.jruby.RubySymbol constant : this.locals) {
                builder.append(nextNextIndent).append('"').append(constant).append('"').append('\n');
            }
            builder.append(nextIndent);
            builder.append("parameters: ");
            builder.append(this.parameters == null ? "null\n" : this.parameters.toString(nextIndent));
            builder.append(nextIndent);
            builder.append("body: ");
            builder.append(this.body == null ? "null\n" : this.body.toString(nextIndent));
            return builder.toString();
        }
    }

    /**
     * Represents a block parameter to a method, block, or lambda definition.
     *
     *     def a(&b)
     *           ^^
     *     end
     */
    public static final class BlockParameterNode extends Node {
        /** optional (can be null) */
        public final org.jruby.RubySymbol name;

        public BlockParameterNode(org.jruby.RubySymbol name, int startOffset, int length) {
            super(startOffset, length);
            this.name = name;
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
        }

        public Node[] childNodes() {
            return EMPTY_ARRAY;
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitBlockParameterNode(this);
        }

        @Override
        protected String toString(String indent) {
            StringBuilder builder = new StringBuilder();
            builder.append(this.getClass().getSimpleName());
            if (hasNewLineFlag()) {
                builder.append("[Li]");
            }
            builder.append('\n');
            String nextIndent = indent + "  ";
            builder.append(nextIndent);
            builder.append("name: ");
            builder.append(this.name == null ? "null" : "\"" + this.name + "\"");
            builder.append('\n');
            return builder.toString();
        }
    }

    /**
     * Represents a block's parameters declaration.
     *
     *     -> (a, b = 1; local) { }
     *        ^^^^^^^^^^^^^^^^^
     *
     *     foo do |a, b = 1; local|
     *            ^^^^^^^^^^^^^^^^^
     *     end
     */
    public static final class BlockParametersNode extends Node {
        /** optional (can be null) */
        public final ParametersNode parameters;
        public final Node[] locals;

        public BlockParametersNode(ParametersNode parameters, Node[] locals, int startOffset, int length) {
            super(startOffset, length);
            this.parameters = parameters;
            this.locals = locals;
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
            if (this.parameters != null) {
                this.parameters.accept(visitor);
            }
            for (Nodes.Node child : this.locals) {
                child.accept(visitor);
            }
        }

        public Node[] childNodes() {
            ArrayList<Node> childNodes = new ArrayList<>();
            childNodes.add(this.parameters);
            childNodes.addAll(Arrays.asList(this.locals));
            return childNodes.toArray(EMPTY_ARRAY);
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitBlockParametersNode(this);
        }

        @Override
        protected String toString(String indent) {
            StringBuilder builder = new StringBuilder();
            builder.append(this.getClass().getSimpleName());
            if (hasNewLineFlag()) {
                builder.append("[Li]");
            }
            builder.append('\n');
            String nextIndent = indent + "  ";
            String nextNextIndent = nextIndent + "  ";
            builder.append(nextIndent);
            builder.append("parameters: ");
            builder.append(this.parameters == null ? "null\n" : this.parameters.toString(nextIndent));
            builder.append(nextIndent);
            builder.append("locals: ");
            builder.append('\n');
            for (Node child : this.locals) {
                builder.append(nextNextIndent).append(child.toString(nextNextIndent));
            }
            return builder.toString();
        }
    }

    /**
     * Represents the use of the `break` keyword.
     *
     *     break foo
     *     ^^^^^^^^^
     */
    public static final class BreakNode extends Node {
        /** optional (can be null) */
        public final ArgumentsNode arguments;

        public BreakNode(ArgumentsNode arguments, int startOffset, int length) {
            super(startOffset, length);
            this.arguments = arguments;
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
            if (this.arguments != null) {
                this.arguments.accept(visitor);
            }
        }

        public Node[] childNodes() {
            return new Node[] { this.arguments };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitBreakNode(this);
        }

        @Override
        protected String toString(String indent) {
            StringBuilder builder = new StringBuilder();
            builder.append(this.getClass().getSimpleName());
            if (hasNewLineFlag()) {
                builder.append("[Li]");
            }
            builder.append('\n');
            String nextIndent = indent + "  ";
            builder.append(nextIndent);
            builder.append("arguments: ");
            builder.append(this.arguments == null ? "null\n" : this.arguments.toString(nextIndent));
            return builder.toString();
        }
    }

    /**
     * Represents the use of the `&&=` operator on a call.
     *
     *     foo.bar &&= value
     *     ^^^^^^^^^^^^^^^^^
     */
    public static final class CallAndWriteNode extends Node {
        /** optional (can be null) */
        public final Node receiver;
        public final short flags;
        public final org.jruby.RubySymbol read_name;
        public final org.jruby.RubySymbol write_name;
        public final Node value;

        public CallAndWriteNode(Node receiver, short flags, org.jruby.RubySymbol read_name, org.jruby.RubySymbol write_name, Node value, int startOffset, int length) {
            super(startOffset, length);
            this.receiver = receiver;
            this.flags = flags;
            this.read_name = read_name;
            this.write_name = write_name;
            this.value = value;
        }
        
        public boolean isSafeNavigation() {
            return CallNodeFlags.isSafeNavigation(this.flags);
        }

        public boolean isVariableCall() {
            return CallNodeFlags.isVariableCall(this.flags);
        }
        
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
            if (this.receiver != null) {
                this.receiver.accept(visitor);
            }
            this.value.accept(visitor);
        }

        public Node[] childNodes() {
            return new Node[] { this.receiver, this.value };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitCallAndWriteNode(this);
        }

        @Override
        protected String toString(String indent) {
            StringBuilder builder = new StringBuilder();
            builder.append(this.getClass().getSimpleName());
            if (hasNewLineFlag()) {
                builder.append("[Li]");
            }
            builder.append('\n');
            String nextIndent = indent + "  ";
            builder.append(nextIndent);
            builder.append("receiver: ");
            builder.append(this.receiver == null ? "null\n" : this.receiver.toString(nextIndent));
            builder.append(nextIndent);
            builder.append("flags: ");
            builder.append(this.flags);
            builder.append('\n');
            builder.append(nextIndent);
            builder.append("read_name: ");
            builder.append('"').append(this.read_name).append('"');
            builder.append('\n');
            builder.append(nextIndent);
            builder.append("write_name: ");
            builder.append('"').append(this.write_name).append('"');
            builder.append('\n');
            builder.append(nextIndent);
            builder.append("value: ");
            builder.append(this.value.toString(nextIndent));
            return builder.toString();
        }
    }

    /**
     * Represents a method call, in all of the various forms that can take.
     *
     *     foo
     *     ^^^
     *
     *     foo()
     *     ^^^^^
     *
     *     +foo
     *     ^^^^
     *
     *     foo + bar
     *     ^^^^^^^^^
     *
     *     foo.bar
     *     ^^^^^^^
     *
     *     foo&.bar
     *     ^^^^^^^^
     */
    public static final class CallNode extends Node {
        /** optional (can be null) */
        public final Node receiver;
        public final org.jruby.RubySymbol name;
        /** optional (can be null) */
        public final ArgumentsNode arguments;
        /** optional (can be null) */
        public final Node block;
        public final short flags;

        public CallNode(Node receiver, org.jruby.RubySymbol name, ArgumentsNode arguments, Node block, short flags, int startOffset, int length) {
            super(startOffset, length);
            this.receiver = receiver;
            this.name = name;
            this.arguments = arguments;
            this.block = block;
            this.flags = flags;
        }
        
        public boolean isSafeNavigation() {
            return CallNodeFlags.isSafeNavigation(this.flags);
        }

        public boolean isVariableCall() {
            return CallNodeFlags.isVariableCall(this.flags);
        }
        
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
            if (this.receiver != null) {
                this.receiver.accept(visitor);
            }
            if (this.arguments != null) {
                this.arguments.accept(visitor);
            }
            if (this.block != null) {
                this.block.accept(visitor);
            }
        }

        public Node[] childNodes() {
            return new Node[] { this.receiver, this.arguments, this.block };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitCallNode(this);
        }

        @Override
        protected String toString(String indent) {
            StringBuilder builder = new StringBuilder();
            builder.append(this.getClass().getSimpleName());
            if (hasNewLineFlag()) {
                builder.append("[Li]");
            }
            builder.append('\n');
            String nextIndent = indent + "  ";
            builder.append(nextIndent);
            builder.append("receiver: ");
            builder.append(this.receiver == null ? "null\n" : this.receiver.toString(nextIndent));
            builder.append(nextIndent);
            builder.append("name: ");
            builder.append('"').append(this.name).append('"');
            builder.append('\n');
            builder.append(nextIndent);
            builder.append("arguments: ");
            builder.append(this.arguments == null ? "null\n" : this.arguments.toString(nextIndent));
            builder.append(nextIndent);
            builder.append("block: ");
            builder.append(this.block == null ? "null\n" : this.block.toString(nextIndent));
            builder.append(nextIndent);
            builder.append("flags: ");
            builder.append(this.flags);
            builder.append('\n');
            return builder.toString();
        }
    }

    /**
     * Represents the use of an assignment operator on a call.
     *
     *     foo.bar += baz
     *     ^^^^^^^^^^^^^^
     */
    public static final class CallOperatorWriteNode extends Node {
        /** optional (can be null) */
        public final Node receiver;
        public final short flags;
        public final org.jruby.RubySymbol read_name;
        public final org.jruby.RubySymbol write_name;
        public final org.jruby.RubySymbol operator;
        public final Node value;

        public CallOperatorWriteNode(Node receiver, short flags, org.jruby.RubySymbol read_name, org.jruby.RubySymbol write_name, org.jruby.RubySymbol operator, Node value, int startOffset, int length) {
            super(startOffset, length);
            this.receiver = receiver;
            this.flags = flags;
            this.read_name = read_name;
            this.write_name = write_name;
            this.operator = operator;
            this.value = value;
        }
        
        public boolean isSafeNavigation() {
            return CallNodeFlags.isSafeNavigation(this.flags);
        }

        public boolean isVariableCall() {
            return CallNodeFlags.isVariableCall(this.flags);
        }
        
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
            if (this.receiver != null) {
                this.receiver.accept(visitor);
            }
            this.value.accept(visitor);
        }

        public Node[] childNodes() {
            return new Node[] { this.receiver, this.value };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitCallOperatorWriteNode(this);
        }

        @Override
        protected String toString(String indent) {
            StringBuilder builder = new StringBuilder();
            builder.append(this.getClass().getSimpleName());
            if (hasNewLineFlag()) {
                builder.append("[Li]");
            }
            builder.append('\n');
            String nextIndent = indent + "  ";
            builder.append(nextIndent);
            builder.append("receiver: ");
            builder.append(this.receiver == null ? "null\n" : this.receiver.toString(nextIndent));
            builder.append(nextIndent);
            builder.append("flags: ");
            builder.append(this.flags);
            builder.append('\n');
            builder.append(nextIndent);
            builder.append("read_name: ");
            builder.append('"').append(this.read_name).append('"');
            builder.append('\n');
            builder.append(nextIndent);
            builder.append("write_name: ");
            builder.append('"').append(this.write_name).append('"');
            builder.append('\n');
            builder.append(nextIndent);
            builder.append("operator: ");
            builder.append('"').append(this.operator).append('"');
            builder.append('\n');
            builder.append(nextIndent);
            builder.append("value: ");
            builder.append(this.value.toString(nextIndent));
            return builder.toString();
        }
    }

    /**
     * Represents the use of the `||=` operator on a call.
     *
     *     foo.bar ||= value
     *     ^^^^^^^^^^^^^^^^^
     */
    public static final class CallOrWriteNode extends Node {
        /** optional (can be null) */
        public final Node receiver;
        public final short flags;
        public final org.jruby.RubySymbol read_name;
        public final org.jruby.RubySymbol write_name;
        public final Node value;

        public CallOrWriteNode(Node receiver, short flags, org.jruby.RubySymbol read_name, org.jruby.RubySymbol write_name, Node value, int startOffset, int length) {
            super(startOffset, length);
            this.receiver = receiver;
            this.flags = flags;
            this.read_name = read_name;
            this.write_name = write_name;
            this.value = value;
        }
        
        public boolean isSafeNavigation() {
            return CallNodeFlags.isSafeNavigation(this.flags);
        }

        public boolean isVariableCall() {
            return CallNodeFlags.isVariableCall(this.flags);
        }
        
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
            if (this.receiver != null) {
                this.receiver.accept(visitor);
            }
            this.value.accept(visitor);
        }

        public Node[] childNodes() {
            return new Node[] { this.receiver, this.value };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitCallOrWriteNode(this);
        }

        @Override
        protected String toString(String indent) {
            StringBuilder builder = new StringBuilder();
            builder.append(this.getClass().getSimpleName());
            if (hasNewLineFlag()) {
                builder.append("[Li]");
            }
            builder.append('\n');
            String nextIndent = indent + "  ";
            builder.append(nextIndent);
            builder.append("receiver: ");
            builder.append(this.receiver == null ? "null\n" : this.receiver.toString(nextIndent));
            builder.append(nextIndent);
            builder.append("flags: ");
            builder.append(this.flags);
            builder.append('\n');
            builder.append(nextIndent);
            builder.append("read_name: ");
            builder.append('"').append(this.read_name).append('"');
            builder.append('\n');
            builder.append(nextIndent);
            builder.append("write_name: ");
            builder.append('"').append(this.write_name).append('"');
            builder.append('\n');
            builder.append(nextIndent);
            builder.append("value: ");
            builder.append(this.value.toString(nextIndent));
            return builder.toString();
        }
    }

    /**
     * Represents assigning to a local variable in pattern matching.
     *
     *     foo => [bar => baz]
     *            ^^^^^^^^^^^^
     */
    public static final class CapturePatternNode extends Node {
        public final Node value;
        public final Node target;

        public CapturePatternNode(Node value, Node target, int startOffset, int length) {
            super(startOffset, length);
            this.value = value;
            this.target = target;
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
            this.value.accept(visitor);
            this.target.accept(visitor);
        }

        public Node[] childNodes() {
            return new Node[] { this.value, this.target };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitCapturePatternNode(this);
        }

        @Override
        protected String toString(String indent) {
            StringBuilder builder = new StringBuilder();
            builder.append(this.getClass().getSimpleName());
            if (hasNewLineFlag()) {
                builder.append("[Li]");
            }
            builder.append('\n');
            String nextIndent = indent + "  ";
            builder.append(nextIndent);
            builder.append("value: ");
            builder.append(this.value.toString(nextIndent));
            builder.append(nextIndent);
            builder.append("target: ");
            builder.append(this.target.toString(nextIndent));
            return builder.toString();
        }
    }

    /**
     * Represents the use of a case statement for pattern matching.
     *
     *     case true
     *     in false
     *     end
     *     ^^^^^^^^^
     */
    public static final class CaseMatchNode extends Node {
        /** optional (can be null) */
        public final Node predicate;
        public final Node[] conditions;
        /** optional (can be null) */
        public final ElseNode consequent;

        public CaseMatchNode(Node predicate, Node[] conditions, ElseNode consequent, int startOffset, int length) {
            super(startOffset, length);
            this.predicate = predicate;
            this.conditions = conditions;
            this.consequent = consequent;
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
            if (this.predicate != null) {
                this.predicate.accept(visitor);
            }
            for (Nodes.Node child : this.conditions) {
                child.accept(visitor);
            }
            if (this.consequent != null) {
                this.consequent.accept(visitor);
            }
        }

        public Node[] childNodes() {
            ArrayList<Node> childNodes = new ArrayList<>();
            childNodes.add(this.predicate);
            childNodes.addAll(Arrays.asList(this.conditions));
            childNodes.add(this.consequent);
            return childNodes.toArray(EMPTY_ARRAY);
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitCaseMatchNode(this);
        }

        @Override
        protected String toString(String indent) {
            StringBuilder builder = new StringBuilder();
            builder.append(this.getClass().getSimpleName());
            if (hasNewLineFlag()) {
                builder.append("[Li]");
            }
            builder.append('\n');
            String nextIndent = indent + "  ";
            String nextNextIndent = nextIndent + "  ";
            builder.append(nextIndent);
            builder.append("predicate: ");
            builder.append(this.predicate == null ? "null\n" : this.predicate.toString(nextIndent));
            builder.append(nextIndent);
            builder.append("conditions: ");
            builder.append('\n');
            for (Node child : this.conditions) {
                builder.append(nextNextIndent).append(child.toString(nextNextIndent));
            }
            builder.append(nextIndent);
            builder.append("consequent: ");
            builder.append(this.consequent == null ? "null\n" : this.consequent.toString(nextIndent));
            return builder.toString();
        }
    }

    /**
     * Represents the use of a case statement.
     *
     *     case true
     *     when false
     *     end
     *     ^^^^^^^^^^
     */
    public static final class CaseNode extends Node {
        /** optional (can be null) */
        public final Node predicate;
        public final Node[] conditions;
        /** optional (can be null) */
        public final ElseNode consequent;

        public CaseNode(Node predicate, Node[] conditions, ElseNode consequent, int startOffset, int length) {
            super(startOffset, length);
            this.predicate = predicate;
            this.conditions = conditions;
            this.consequent = consequent;
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
            if (this.predicate != null) {
                this.predicate.accept(visitor);
            }
            for (Nodes.Node child : this.conditions) {
                child.accept(visitor);
            }
            if (this.consequent != null) {
                this.consequent.accept(visitor);
            }
        }

        public Node[] childNodes() {
            ArrayList<Node> childNodes = new ArrayList<>();
            childNodes.add(this.predicate);
            childNodes.addAll(Arrays.asList(this.conditions));
            childNodes.add(this.consequent);
            return childNodes.toArray(EMPTY_ARRAY);
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitCaseNode(this);
        }

        @Override
        protected String toString(String indent) {
            StringBuilder builder = new StringBuilder();
            builder.append(this.getClass().getSimpleName());
            if (hasNewLineFlag()) {
                builder.append("[Li]");
            }
            builder.append('\n');
            String nextIndent = indent + "  ";
            String nextNextIndent = nextIndent + "  ";
            builder.append(nextIndent);
            builder.append("predicate: ");
            builder.append(this.predicate == null ? "null\n" : this.predicate.toString(nextIndent));
            builder.append(nextIndent);
            builder.append("conditions: ");
            builder.append('\n');
            for (Node child : this.conditions) {
                builder.append(nextNextIndent).append(child.toString(nextNextIndent));
            }
            builder.append(nextIndent);
            builder.append("consequent: ");
            builder.append(this.consequent == null ? "null\n" : this.consequent.toString(nextIndent));
            return builder.toString();
        }
    }

    /**
     * Represents a class declaration involving the `class` keyword.
     *
     *     class Foo end
     *     ^^^^^^^^^^^^^
     */
    public static final class ClassNode extends Node {
        public final org.jruby.RubySymbol[] locals;
        public final Node constant_path;
        /** optional (can be null) */
        public final Node superclass;
        /** optional (can be null) */
        public final Node body;
        public final org.jruby.RubySymbol name;

        public ClassNode(org.jruby.RubySymbol[] locals, Node constant_path, Node superclass, Node body, org.jruby.RubySymbol name, int startOffset, int length) {
            super(startOffset, length);
            this.locals = locals;
            this.constant_path = constant_path;
            this.superclass = superclass;
            this.body = body;
            this.name = name;
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
            this.constant_path.accept(visitor);
            if (this.superclass != null) {
                this.superclass.accept(visitor);
            }
            if (this.body != null) {
                this.body.accept(visitor);
            }
        }

        public Node[] childNodes() {
            return new Node[] { this.constant_path, this.superclass, this.body };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitClassNode(this);
        }

        @Override
        protected String toString(String indent) {
            StringBuilder builder = new StringBuilder();
            builder.append(this.getClass().getSimpleName());
            if (hasNewLineFlag()) {
                builder.append("[Li]");
            }
            builder.append('\n');
            String nextIndent = indent + "  ";
            String nextNextIndent = nextIndent + "  ";
            builder.append(nextIndent);
            builder.append("locals: ");
            builder.append('\n');
            for (org.jruby.RubySymbol constant : this.locals) {
                builder.append(nextNextIndent).append('"').append(constant).append('"').append('\n');
            }
            builder.append(nextIndent);
            builder.append("constant_path: ");
            builder.append(this.constant_path.toString(nextIndent));
            builder.append(nextIndent);
            builder.append("superclass: ");
            builder.append(this.superclass == null ? "null\n" : this.superclass.toString(nextIndent));
            builder.append(nextIndent);
            builder.append("body: ");
            builder.append(this.body == null ? "null\n" : this.body.toString(nextIndent));
            builder.append(nextIndent);
            builder.append("name: ");
            builder.append('"').append(this.name).append('"');
            builder.append('\n');
            return builder.toString();
        }
    }

    /**
     * Represents the use of the `&&=` operator for assignment to a class variable.
     *
     *     @@target &&= value
     *     ^^^^^^^^^^^^^^^^^^
     */
    public static final class ClassVariableAndWriteNode extends Node {
        public final org.jruby.RubySymbol name;
        public final Node value;

        public ClassVariableAndWriteNode(org.jruby.RubySymbol name, Node value, int startOffset, int length) {
            super(startOffset, length);
            this.name = name;
            this.value = value;
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
            this.value.accept(visitor);
        }

        public Node[] childNodes() {
            return new Node[] { this.value };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitClassVariableAndWriteNode(this);
        }

        @Override
        protected String toString(String indent) {
            StringBuilder builder = new StringBuilder();
            builder.append(this.getClass().getSimpleName());
            if (hasNewLineFlag()) {
                builder.append("[Li]");
            }
            builder.append('\n');
            String nextIndent = indent + "  ";
            builder.append(nextIndent);
            builder.append("name: ");
            builder.append('"').append(this.name).append('"');
            builder.append('\n');
            builder.append(nextIndent);
            builder.append("value: ");
            builder.append(this.value.toString(nextIndent));
            return builder.toString();
        }
    }

    /**
     * Represents assigning to a class variable using an operator that isn't `=`.
     *
     *     @@target += value
     *     ^^^^^^^^^^^^^^^^^
     */
    public static final class ClassVariableOperatorWriteNode extends Node {
        public final org.jruby.RubySymbol name;
        public final Node value;
        public final org.jruby.RubySymbol operator;

        public ClassVariableOperatorWriteNode(org.jruby.RubySymbol name, Node value, org.jruby.RubySymbol operator, int startOffset, int length) {
            super(startOffset, length);
            this.name = name;
            this.value = value;
            this.operator = operator;
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
            this.value.accept(visitor);
        }

        public Node[] childNodes() {
            return new Node[] { this.value };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitClassVariableOperatorWriteNode(this);
        }

        @Override
        protected String toString(String indent) {
            StringBuilder builder = new StringBuilder();
            builder.append(this.getClass().getSimpleName());
            if (hasNewLineFlag()) {
                builder.append("[Li]");
            }
            builder.append('\n');
            String nextIndent = indent + "  ";
            builder.append(nextIndent);
            builder.append("name: ");
            builder.append('"').append(this.name).append('"');
            builder.append('\n');
            builder.append(nextIndent);
            builder.append("value: ");
            builder.append(this.value.toString(nextIndent));
            builder.append(nextIndent);
            builder.append("operator: ");
            builder.append('"').append(this.operator).append('"');
            builder.append('\n');
            return builder.toString();
        }
    }

    /**
     * Represents the use of the `||=` operator for assignment to a class variable.
     *
     *     @@target ||= value
     *     ^^^^^^^^^^^^^^^^^^
     */
    public static final class ClassVariableOrWriteNode extends Node {
        public final org.jruby.RubySymbol name;
        public final Node value;

        public ClassVariableOrWriteNode(org.jruby.RubySymbol name, Node value, int startOffset, int length) {
            super(startOffset, length);
            this.name = name;
            this.value = value;
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
            this.value.accept(visitor);
        }

        public Node[] childNodes() {
            return new Node[] { this.value };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitClassVariableOrWriteNode(this);
        }

        @Override
        protected String toString(String indent) {
            StringBuilder builder = new StringBuilder();
            builder.append(this.getClass().getSimpleName());
            if (hasNewLineFlag()) {
                builder.append("[Li]");
            }
            builder.append('\n');
            String nextIndent = indent + "  ";
            builder.append(nextIndent);
            builder.append("name: ");
            builder.append('"').append(this.name).append('"');
            builder.append('\n');
            builder.append(nextIndent);
            builder.append("value: ");
            builder.append(this.value.toString(nextIndent));
            return builder.toString();
        }
    }

    /**
     * Represents referencing a class variable.
     *
     *     @@foo
     *     ^^^^^
     */
    public static final class ClassVariableReadNode extends Node {
        public final org.jruby.RubySymbol name;

        public ClassVariableReadNode(org.jruby.RubySymbol name, int startOffset, int length) {
            super(startOffset, length);
            this.name = name;
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
        }

        public Node[] childNodes() {
            return EMPTY_ARRAY;
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitClassVariableReadNode(this);
        }

        @Override
        protected String toString(String indent) {
            StringBuilder builder = new StringBuilder();
            builder.append(this.getClass().getSimpleName());
            if (hasNewLineFlag()) {
                builder.append("[Li]");
            }
            builder.append('\n');
            String nextIndent = indent + "  ";
            builder.append(nextIndent);
            builder.append("name: ");
            builder.append('"').append(this.name).append('"');
            builder.append('\n');
            return builder.toString();
        }
    }

    /**
     * Represents writing to a class variable in a context that doesn't have an explicit value.
     *
     *     @@foo, @@bar = baz
     *     ^^^^^  ^^^^^
     */
    public static final class ClassVariableTargetNode extends Node {
        public final org.jruby.RubySymbol name;

        public ClassVariableTargetNode(org.jruby.RubySymbol name, int startOffset, int length) {
            super(startOffset, length);
            this.name = name;
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
        }

        public Node[] childNodes() {
            return EMPTY_ARRAY;
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitClassVariableTargetNode(this);
        }

        @Override
        protected String toString(String indent) {
            StringBuilder builder = new StringBuilder();
            builder.append(this.getClass().getSimpleName());
            if (hasNewLineFlag()) {
                builder.append("[Li]");
            }
            builder.append('\n');
            String nextIndent = indent + "  ";
            builder.append(nextIndent);
            builder.append("name: ");
            builder.append('"').append(this.name).append('"');
            builder.append('\n');
            return builder.toString();
        }
    }

    /**
     * Represents writing to a class variable.
     *
     *     @@foo = 1
     *     ^^^^^^^^^
     */
    public static final class ClassVariableWriteNode extends Node {
        public final org.jruby.RubySymbol name;
        public final Node value;

        public ClassVariableWriteNode(org.jruby.RubySymbol name, Node value, int startOffset, int length) {
            super(startOffset, length);
            this.name = name;
            this.value = value;
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
            this.value.accept(visitor);
        }

        public Node[] childNodes() {
            return new Node[] { this.value };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitClassVariableWriteNode(this);
        }

        @Override
        protected String toString(String indent) {
            StringBuilder builder = new StringBuilder();
            builder.append(this.getClass().getSimpleName());
            if (hasNewLineFlag()) {
                builder.append("[Li]");
            }
            builder.append('\n');
            String nextIndent = indent + "  ";
            builder.append(nextIndent);
            builder.append("name: ");
            builder.append('"').append(this.name).append('"');
            builder.append('\n');
            builder.append(nextIndent);
            builder.append("value: ");
            builder.append(this.value.toString(nextIndent));
            return builder.toString();
        }
    }

    /**
     * Represents the use of the `&&=` operator for assignment to a constant.
     *
     *     Target &&= value
     *     ^^^^^^^^^^^^^^^^
     */
    public static final class ConstantAndWriteNode extends Node {
        public final org.jruby.RubySymbol name;
        public final Node value;

        public ConstantAndWriteNode(org.jruby.RubySymbol name, Node value, int startOffset, int length) {
            super(startOffset, length);
            this.name = name;
            this.value = value;
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
            this.value.accept(visitor);
        }

        public Node[] childNodes() {
            return new Node[] { this.value };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitConstantAndWriteNode(this);
        }

        @Override
        protected String toString(String indent) {
            StringBuilder builder = new StringBuilder();
            builder.append(this.getClass().getSimpleName());
            if (hasNewLineFlag()) {
                builder.append("[Li]");
            }
            builder.append('\n');
            String nextIndent = indent + "  ";
            builder.append(nextIndent);
            builder.append("name: ");
            builder.append('"').append(this.name).append('"');
            builder.append('\n');
            builder.append(nextIndent);
            builder.append("value: ");
            builder.append(this.value.toString(nextIndent));
            return builder.toString();
        }
    }

    /**
     * Represents assigning to a constant using an operator that isn't `=`.
     *
     *     Target += value
     *     ^^^^^^^^^^^^^^^
     */
    public static final class ConstantOperatorWriteNode extends Node {
        public final org.jruby.RubySymbol name;
        public final Node value;
        public final org.jruby.RubySymbol operator;

        public ConstantOperatorWriteNode(org.jruby.RubySymbol name, Node value, org.jruby.RubySymbol operator, int startOffset, int length) {
            super(startOffset, length);
            this.name = name;
            this.value = value;
            this.operator = operator;
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
            this.value.accept(visitor);
        }

        public Node[] childNodes() {
            return new Node[] { this.value };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitConstantOperatorWriteNode(this);
        }

        @Override
        protected String toString(String indent) {
            StringBuilder builder = new StringBuilder();
            builder.append(this.getClass().getSimpleName());
            if (hasNewLineFlag()) {
                builder.append("[Li]");
            }
            builder.append('\n');
            String nextIndent = indent + "  ";
            builder.append(nextIndent);
            builder.append("name: ");
            builder.append('"').append(this.name).append('"');
            builder.append('\n');
            builder.append(nextIndent);
            builder.append("value: ");
            builder.append(this.value.toString(nextIndent));
            builder.append(nextIndent);
            builder.append("operator: ");
            builder.append('"').append(this.operator).append('"');
            builder.append('\n');
            return builder.toString();
        }
    }

    /**
     * Represents the use of the `||=` operator for assignment to a constant.
     *
     *     Target ||= value
     *     ^^^^^^^^^^^^^^^^
     */
    public static final class ConstantOrWriteNode extends Node {
        public final org.jruby.RubySymbol name;
        public final Node value;

        public ConstantOrWriteNode(org.jruby.RubySymbol name, Node value, int startOffset, int length) {
            super(startOffset, length);
            this.name = name;
            this.value = value;
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
            this.value.accept(visitor);
        }

        public Node[] childNodes() {
            return new Node[] { this.value };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitConstantOrWriteNode(this);
        }

        @Override
        protected String toString(String indent) {
            StringBuilder builder = new StringBuilder();
            builder.append(this.getClass().getSimpleName());
            if (hasNewLineFlag()) {
                builder.append("[Li]");
            }
            builder.append('\n');
            String nextIndent = indent + "  ";
            builder.append(nextIndent);
            builder.append("name: ");
            builder.append('"').append(this.name).append('"');
            builder.append('\n');
            builder.append(nextIndent);
            builder.append("value: ");
            builder.append(this.value.toString(nextIndent));
            return builder.toString();
        }
    }

    /**
     * Represents the use of the `&&=` operator for assignment to a constant path.
     *
     *     Parent::Child &&= value
     *     ^^^^^^^^^^^^^^^^^^^^^^^
     */
    public static final class ConstantPathAndWriteNode extends Node {
        public final ConstantPathNode target;
        public final Node value;

        public ConstantPathAndWriteNode(ConstantPathNode target, Node value, int startOffset, int length) {
            super(startOffset, length);
            this.target = target;
            this.value = value;
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
            this.target.accept(visitor);
            this.value.accept(visitor);
        }

        public Node[] childNodes() {
            return new Node[] { this.target, this.value };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitConstantPathAndWriteNode(this);
        }

        @Override
        protected String toString(String indent) {
            StringBuilder builder = new StringBuilder();
            builder.append(this.getClass().getSimpleName());
            if (hasNewLineFlag()) {
                builder.append("[Li]");
            }
            builder.append('\n');
            String nextIndent = indent + "  ";
            builder.append(nextIndent);
            builder.append("target: ");
            builder.append(this.target.toString(nextIndent));
            builder.append(nextIndent);
            builder.append("value: ");
            builder.append(this.value.toString(nextIndent));
            return builder.toString();
        }
    }

    /**
     * Represents accessing a constant through a path of `::` operators.
     *
     *     Foo::Bar
     *     ^^^^^^^^
     */
    public static final class ConstantPathNode extends Node {
        /** optional (can be null) */
        public final Node parent;
        public final Node child;

        public ConstantPathNode(Node parent, Node child, int startOffset, int length) {
            super(startOffset, length);
            this.parent = parent;
            this.child = child;
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
            if (this.parent != null) {
                this.parent.accept(visitor);
            }
            this.child.accept(visitor);
        }

        public Node[] childNodes() {
            return new Node[] { this.parent, this.child };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitConstantPathNode(this);
        }

        @Override
        protected String toString(String indent) {
            StringBuilder builder = new StringBuilder();
            builder.append(this.getClass().getSimpleName());
            if (hasNewLineFlag()) {
                builder.append("[Li]");
            }
            builder.append('\n');
            String nextIndent = indent + "  ";
            builder.append(nextIndent);
            builder.append("parent: ");
            builder.append(this.parent == null ? "null\n" : this.parent.toString(nextIndent));
            builder.append(nextIndent);
            builder.append("child: ");
            builder.append(this.child.toString(nextIndent));
            return builder.toString();
        }
    }

    /**
     * Represents assigning to a constant path using an operator that isn't `=`.
     *
     *     Parent::Child += value
     *     ^^^^^^^^^^^^^^^^^^^^^^
     */
    public static final class ConstantPathOperatorWriteNode extends Node {
        public final ConstantPathNode target;
        public final Node value;
        public final org.jruby.RubySymbol operator;

        public ConstantPathOperatorWriteNode(ConstantPathNode target, Node value, org.jruby.RubySymbol operator, int startOffset, int length) {
            super(startOffset, length);
            this.target = target;
            this.value = value;
            this.operator = operator;
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
            this.target.accept(visitor);
            this.value.accept(visitor);
        }

        public Node[] childNodes() {
            return new Node[] { this.target, this.value };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitConstantPathOperatorWriteNode(this);
        }

        @Override
        protected String toString(String indent) {
            StringBuilder builder = new StringBuilder();
            builder.append(this.getClass().getSimpleName());
            if (hasNewLineFlag()) {
                builder.append("[Li]");
            }
            builder.append('\n');
            String nextIndent = indent + "  ";
            builder.append(nextIndent);
            builder.append("target: ");
            builder.append(this.target.toString(nextIndent));
            builder.append(nextIndent);
            builder.append("value: ");
            builder.append(this.value.toString(nextIndent));
            builder.append(nextIndent);
            builder.append("operator: ");
            builder.append('"').append(this.operator).append('"');
            builder.append('\n');
            return builder.toString();
        }
    }

    /**
     * Represents the use of the `||=` operator for assignment to a constant path.
     *
     *     Parent::Child ||= value
     *     ^^^^^^^^^^^^^^^^^^^^^^^
     */
    public static final class ConstantPathOrWriteNode extends Node {
        public final ConstantPathNode target;
        public final Node value;

        public ConstantPathOrWriteNode(ConstantPathNode target, Node value, int startOffset, int length) {
            super(startOffset, length);
            this.target = target;
            this.value = value;
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
            this.target.accept(visitor);
            this.value.accept(visitor);
        }

        public Node[] childNodes() {
            return new Node[] { this.target, this.value };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitConstantPathOrWriteNode(this);
        }

        @Override
        protected String toString(String indent) {
            StringBuilder builder = new StringBuilder();
            builder.append(this.getClass().getSimpleName());
            if (hasNewLineFlag()) {
                builder.append("[Li]");
            }
            builder.append('\n');
            String nextIndent = indent + "  ";
            builder.append(nextIndent);
            builder.append("target: ");
            builder.append(this.target.toString(nextIndent));
            builder.append(nextIndent);
            builder.append("value: ");
            builder.append(this.value.toString(nextIndent));
            return builder.toString();
        }
    }

    /**
     * Represents writing to a constant path in a context that doesn't have an explicit value.
     *
     *     Foo::Foo, Bar::Bar = baz
     *     ^^^^^^^^  ^^^^^^^^
     */
    public static final class ConstantPathTargetNode extends Node {
        /** optional (can be null) */
        public final Node parent;
        public final Node child;

        public ConstantPathTargetNode(Node parent, Node child, int startOffset, int length) {
            super(startOffset, length);
            this.parent = parent;
            this.child = child;
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
            if (this.parent != null) {
                this.parent.accept(visitor);
            }
            this.child.accept(visitor);
        }

        public Node[] childNodes() {
            return new Node[] { this.parent, this.child };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitConstantPathTargetNode(this);
        }

        @Override
        protected String toString(String indent) {
            StringBuilder builder = new StringBuilder();
            builder.append(this.getClass().getSimpleName());
            if (hasNewLineFlag()) {
                builder.append("[Li]");
            }
            builder.append('\n');
            String nextIndent = indent + "  ";
            builder.append(nextIndent);
            builder.append("parent: ");
            builder.append(this.parent == null ? "null\n" : this.parent.toString(nextIndent));
            builder.append(nextIndent);
            builder.append("child: ");
            builder.append(this.child.toString(nextIndent));
            return builder.toString();
        }
    }

    /**
     * Represents writing to a constant path.
     *
     *     ::Foo = 1
     *     ^^^^^^^^^
     *
     *     Foo::Bar = 1
     *     ^^^^^^^^^^^^
     *
     *     ::Foo::Bar = 1
     *     ^^^^^^^^^^^^^^
     */
    public static final class ConstantPathWriteNode extends Node {
        public final ConstantPathNode target;
        public final Node value;

        public ConstantPathWriteNode(ConstantPathNode target, Node value, int startOffset, int length) {
            super(startOffset, length);
            this.target = target;
            this.value = value;
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
            this.target.accept(visitor);
            this.value.accept(visitor);
        }

        public Node[] childNodes() {
            return new Node[] { this.target, this.value };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitConstantPathWriteNode(this);
        }

        @Override
        protected String toString(String indent) {
            StringBuilder builder = new StringBuilder();
            builder.append(this.getClass().getSimpleName());
            if (hasNewLineFlag()) {
                builder.append("[Li]");
            }
            builder.append('\n');
            String nextIndent = indent + "  ";
            builder.append(nextIndent);
            builder.append("target: ");
            builder.append(this.target.toString(nextIndent));
            builder.append(nextIndent);
            builder.append("value: ");
            builder.append(this.value.toString(nextIndent));
            return builder.toString();
        }
    }

    /**
     * Represents referencing a constant.
     *
     *     Foo
     *     ^^^
     */
    public static final class ConstantReadNode extends Node {
        public final org.jruby.RubySymbol name;

        public ConstantReadNode(org.jruby.RubySymbol name, int startOffset, int length) {
            super(startOffset, length);
            this.name = name;
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
        }

        public Node[] childNodes() {
            return EMPTY_ARRAY;
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitConstantReadNode(this);
        }

        @Override
        protected String toString(String indent) {
            StringBuilder builder = new StringBuilder();
            builder.append(this.getClass().getSimpleName());
            if (hasNewLineFlag()) {
                builder.append("[Li]");
            }
            builder.append('\n');
            String nextIndent = indent + "  ";
            builder.append(nextIndent);
            builder.append("name: ");
            builder.append('"').append(this.name).append('"');
            builder.append('\n');
            return builder.toString();
        }
    }

    /**
     * Represents writing to a constant in a context that doesn't have an explicit value.
     *
     *     Foo, Bar = baz
     *     ^^^  ^^^
     */
    public static final class ConstantTargetNode extends Node {
        public final org.jruby.RubySymbol name;

        public ConstantTargetNode(org.jruby.RubySymbol name, int startOffset, int length) {
            super(startOffset, length);
            this.name = name;
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
        }

        public Node[] childNodes() {
            return EMPTY_ARRAY;
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitConstantTargetNode(this);
        }

        @Override
        protected String toString(String indent) {
            StringBuilder builder = new StringBuilder();
            builder.append(this.getClass().getSimpleName());
            if (hasNewLineFlag()) {
                builder.append("[Li]");
            }
            builder.append('\n');
            String nextIndent = indent + "  ";
            builder.append(nextIndent);
            builder.append("name: ");
            builder.append('"').append(this.name).append('"');
            builder.append('\n');
            return builder.toString();
        }
    }

    /**
     * Represents writing to a constant.
     *
     *     Foo = 1
     *     ^^^^^^^
     */
    public static final class ConstantWriteNode extends Node {
        public final org.jruby.RubySymbol name;
        public final Node value;

        public ConstantWriteNode(org.jruby.RubySymbol name, Node value, int startOffset, int length) {
            super(startOffset, length);
            this.name = name;
            this.value = value;
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
            this.value.accept(visitor);
        }

        public Node[] childNodes() {
            return new Node[] { this.value };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitConstantWriteNode(this);
        }

        @Override
        protected String toString(String indent) {
            StringBuilder builder = new StringBuilder();
            builder.append(this.getClass().getSimpleName());
            if (hasNewLineFlag()) {
                builder.append("[Li]");
            }
            builder.append('\n');
            String nextIndent = indent + "  ";
            builder.append(nextIndent);
            builder.append("name: ");
            builder.append('"').append(this.name).append('"');
            builder.append('\n');
            builder.append(nextIndent);
            builder.append("value: ");
            builder.append(this.value.toString(nextIndent));
            return builder.toString();
        }
    }

    /**
     * Represents a method definition.
     *
     *     def method
     *     end
     *     ^^^^^^^^^^
     */
    public static final class DefNode extends Node {
        public final int serializedLength;
        public final org.jruby.RubySymbol name;
        /** optional (can be null) */
        public final Node receiver;
        /** optional (can be null) */
        public final ParametersNode parameters;
        /** optional (can be null) */
        public final Node body;
        public final org.jruby.RubySymbol[] locals;

        public DefNode(int serializedLength, org.jruby.RubySymbol name, Node receiver, ParametersNode parameters, Node body, org.jruby.RubySymbol[] locals, int startOffset, int length) {
            super(startOffset, length);
            this.serializedLength = serializedLength;
            this.name = name;
            this.receiver = receiver;
            this.parameters = parameters;
            this.body = body;
            this.locals = locals;
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
            if (this.receiver != null) {
                this.receiver.accept(visitor);
            }
            if (this.parameters != null) {
                this.parameters.accept(visitor);
            }
            if (this.body != null) {
                this.body.accept(visitor);
            }
        }

        public Node[] childNodes() {
            return new Node[] { this.receiver, this.parameters, this.body };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitDefNode(this);
        }

        @Override
        protected String toString(String indent) {
            StringBuilder builder = new StringBuilder();
            builder.append(this.getClass().getSimpleName());
            if (hasNewLineFlag()) {
                builder.append("[Li]");
            }
            builder.append('\n');
            String nextIndent = indent + "  ";
            String nextNextIndent = nextIndent + "  ";
            builder.append(nextIndent);
            builder.append("name: ");
            builder.append('"').append(this.name).append('"');
            builder.append('\n');
            builder.append(nextIndent);
            builder.append("receiver: ");
            builder.append(this.receiver == null ? "null\n" : this.receiver.toString(nextIndent));
            builder.append(nextIndent);
            builder.append("parameters: ");
            builder.append(this.parameters == null ? "null\n" : this.parameters.toString(nextIndent));
            builder.append(nextIndent);
            builder.append("body: ");
            builder.append(this.body == null ? "null\n" : this.body.toString(nextIndent));
            builder.append(nextIndent);
            builder.append("locals: ");
            builder.append('\n');
            for (org.jruby.RubySymbol constant : this.locals) {
                builder.append(nextNextIndent).append('"').append(constant).append('"').append('\n');
            }
            return builder.toString();
        }
    }

    /**
     * Represents the use of the `defined?` keyword.
     *
     *     defined?(a)
     *     ^^^^^^^^^^^
     */
    public static final class DefinedNode extends Node {
        public final Node value;

        public DefinedNode(Node value, int startOffset, int length) {
            super(startOffset, length);
            this.value = value;
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
            this.value.accept(visitor);
        }

        public Node[] childNodes() {
            return new Node[] { this.value };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitDefinedNode(this);
        }

        @Override
        protected String toString(String indent) {
            StringBuilder builder = new StringBuilder();
            builder.append(this.getClass().getSimpleName());
            if (hasNewLineFlag()) {
                builder.append("[Li]");
            }
            builder.append('\n');
            String nextIndent = indent + "  ";
            builder.append(nextIndent);
            builder.append("value: ");
            builder.append(this.value.toString(nextIndent));
            return builder.toString();
        }
    }

    /**
     * Represents an `else` clause in a `case`, `if`, or `unless` statement.
     *
     *     if a then b else c end
     *                 ^^^^^^^^^^
     */
    public static final class ElseNode extends Node {
        /** optional (can be null) */
        public final StatementsNode statements;

        public ElseNode(StatementsNode statements, int startOffset, int length) {
            super(startOffset, length);
            this.statements = statements;
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
            if (this.statements != null) {
                this.statements.accept(visitor);
            }
        }

        public Node[] childNodes() {
            return new Node[] { this.statements };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitElseNode(this);
        }

        @Override
        protected String toString(String indent) {
            StringBuilder builder = new StringBuilder();
            builder.append(this.getClass().getSimpleName());
            if (hasNewLineFlag()) {
                builder.append("[Li]");
            }
            builder.append('\n');
            String nextIndent = indent + "  ";
            builder.append(nextIndent);
            builder.append("statements: ");
            builder.append(this.statements == null ? "null\n" : this.statements.toString(nextIndent));
            return builder.toString();
        }
    }

    /**
     * Represents an interpolated set of statements.
     *
     *     "foo #{bar}"
     *          ^^^^^^
     */
    public static final class EmbeddedStatementsNode extends Node {
        /** optional (can be null) */
        public final StatementsNode statements;

        public EmbeddedStatementsNode(StatementsNode statements, int startOffset, int length) {
            super(startOffset, length);
            this.statements = statements;
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
            if (this.statements != null) {
                this.statements.accept(visitor);
            }
        }

        public Node[] childNodes() {
            return new Node[] { this.statements };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitEmbeddedStatementsNode(this);
        }

        @Override
        protected String toString(String indent) {
            StringBuilder builder = new StringBuilder();
            builder.append(this.getClass().getSimpleName());
            if (hasNewLineFlag()) {
                builder.append("[Li]");
            }
            builder.append('\n');
            String nextIndent = indent + "  ";
            builder.append(nextIndent);
            builder.append("statements: ");
            builder.append(this.statements == null ? "null\n" : this.statements.toString(nextIndent));
            return builder.toString();
        }
    }

    /**
     * Represents an interpolated variable.
     *
     *     "foo #@bar"
     *          ^^^^^
     */
    public static final class EmbeddedVariableNode extends Node {
        public final Node variable;

        public EmbeddedVariableNode(Node variable, int startOffset, int length) {
            super(startOffset, length);
            this.variable = variable;
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
            this.variable.accept(visitor);
        }

        public Node[] childNodes() {
            return new Node[] { this.variable };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitEmbeddedVariableNode(this);
        }

        @Override
        protected String toString(String indent) {
            StringBuilder builder = new StringBuilder();
            builder.append(this.getClass().getSimpleName());
            if (hasNewLineFlag()) {
                builder.append("[Li]");
            }
            builder.append('\n');
            String nextIndent = indent + "  ";
            builder.append(nextIndent);
            builder.append("variable: ");
            builder.append(this.variable.toString(nextIndent));
            return builder.toString();
        }
    }

    /**
     * Represents an `ensure` clause in a `begin` statement.
     *
     *     begin
     *       foo
     *     ensure
     *     ^^^^^^
     *       bar
     *     end
     */
    public static final class EnsureNode extends Node {
        /** optional (can be null) */
        public final StatementsNode statements;

        public EnsureNode(StatementsNode statements, int startOffset, int length) {
            super(startOffset, length);
            this.statements = statements;
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
            if (this.statements != null) {
                this.statements.accept(visitor);
            }
        }

        public Node[] childNodes() {
            return new Node[] { this.statements };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitEnsureNode(this);
        }

        @Override
        protected String toString(String indent) {
            StringBuilder builder = new StringBuilder();
            builder.append(this.getClass().getSimpleName());
            if (hasNewLineFlag()) {
                builder.append("[Li]");
            }
            builder.append('\n');
            String nextIndent = indent + "  ";
            builder.append(nextIndent);
            builder.append("statements: ");
            builder.append(this.statements == null ? "null\n" : this.statements.toString(nextIndent));
            return builder.toString();
        }
    }

    /**
     * Represents the use of the literal `false` keyword.
     *
     *     false
     *     ^^^^^
     */
    public static final class FalseNode extends Node {

        public FalseNode(int startOffset, int length) {
            super(startOffset, length);
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
        }

        public Node[] childNodes() {
            return EMPTY_ARRAY;
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitFalseNode(this);
        }

        @Override
        protected String toString(String indent) {
            StringBuilder builder = new StringBuilder();
            builder.append(this.getClass().getSimpleName());
            if (hasNewLineFlag()) {
                builder.append("[Li]");
            }
            builder.append('\n');
            String nextIndent = indent + "  ";
            return builder.toString();
        }
    }

    /**
     * Represents a find pattern in pattern matching.
     *
     *     foo in *bar, baz, *qux
     *            ^^^^^^^^^^^^^^^
     *
     *     foo in [*bar, baz, *qux]
     *            ^^^^^^^^^^^^^^^^^
     *
     *     foo in Foo(*bar, baz, *qux)
     *            ^^^^^^^^^^^^^^^^^^^^
     */
    public static final class FindPatternNode extends Node {
        /** optional (can be null) */
        public final Node constant;
        public final Node left;
        public final Node[] requireds;
        public final Node right;

        public FindPatternNode(Node constant, Node left, Node[] requireds, Node right, int startOffset, int length) {
            super(startOffset, length);
            this.constant = constant;
            this.left = left;
            this.requireds = requireds;
            this.right = right;
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
            if (this.constant != null) {
                this.constant.accept(visitor);
            }
            this.left.accept(visitor);
            for (Nodes.Node child : this.requireds) {
                child.accept(visitor);
            }
            this.right.accept(visitor);
        }

        public Node[] childNodes() {
            ArrayList<Node> childNodes = new ArrayList<>();
            childNodes.add(this.constant);
            childNodes.add(this.left);
            childNodes.addAll(Arrays.asList(this.requireds));
            childNodes.add(this.right);
            return childNodes.toArray(EMPTY_ARRAY);
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitFindPatternNode(this);
        }

        @Override
        protected String toString(String indent) {
            StringBuilder builder = new StringBuilder();
            builder.append(this.getClass().getSimpleName());
            if (hasNewLineFlag()) {
                builder.append("[Li]");
            }
            builder.append('\n');
            String nextIndent = indent + "  ";
            String nextNextIndent = nextIndent + "  ";
            builder.append(nextIndent);
            builder.append("constant: ");
            builder.append(this.constant == null ? "null\n" : this.constant.toString(nextIndent));
            builder.append(nextIndent);
            builder.append("left: ");
            builder.append(this.left.toString(nextIndent));
            builder.append(nextIndent);
            builder.append("requireds: ");
            builder.append('\n');
            for (Node child : this.requireds) {
                builder.append(nextNextIndent).append(child.toString(nextNextIndent));
            }
            builder.append(nextIndent);
            builder.append("right: ");
            builder.append(this.right.toString(nextIndent));
            return builder.toString();
        }
    }

    /**
     * Represents the use of the `..` or `...` operators to create flip flops.
     *
     *     baz if foo .. bar
     *            ^^^^^^^^^^
     */
    public static final class FlipFlopNode extends Node {
        /** optional (can be null) */
        public final Node left;
        /** optional (can be null) */
        public final Node right;
        public final short flags;

        public FlipFlopNode(Node left, Node right, short flags, int startOffset, int length) {
            super(startOffset, length);
            this.left = left;
            this.right = right;
            this.flags = flags;
        }
        
        public boolean isExcludeEnd() {
            return RangeFlags.isExcludeEnd(this.flags);
        }
        
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
            if (this.left != null) {
                this.left.accept(visitor);
            }
            if (this.right != null) {
                this.right.accept(visitor);
            }
        }

        public Node[] childNodes() {
            return new Node[] { this.left, this.right };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitFlipFlopNode(this);
        }

        @Override
        protected String toString(String indent) {
            StringBuilder builder = new StringBuilder();
            builder.append(this.getClass().getSimpleName());
            if (hasNewLineFlag()) {
                builder.append("[Li]");
            }
            builder.append('\n');
            String nextIndent = indent + "  ";
            builder.append(nextIndent);
            builder.append("left: ");
            builder.append(this.left == null ? "null\n" : this.left.toString(nextIndent));
            builder.append(nextIndent);
            builder.append("right: ");
            builder.append(this.right == null ? "null\n" : this.right.toString(nextIndent));
            builder.append(nextIndent);
            builder.append("flags: ");
            builder.append(this.flags);
            builder.append('\n');
            return builder.toString();
        }
    }

    /**
     * Represents a floating point number literal.
     *
     *     1.0
     *     ^^^
     */
    public static final class FloatNode extends Node {

        public FloatNode(int startOffset, int length) {
            super(startOffset, length);
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
        }

        public Node[] childNodes() {
            return EMPTY_ARRAY;
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitFloatNode(this);
        }

        @Override
        protected String toString(String indent) {
            StringBuilder builder = new StringBuilder();
            builder.append(this.getClass().getSimpleName());
            if (hasNewLineFlag()) {
                builder.append("[Li]");
            }
            builder.append('\n');
            String nextIndent = indent + "  ";
            return builder.toString();
        }
    }

    /**
     * Represents the use of the `for` keyword.
     *
     *     for i in a end
     *     ^^^^^^^^^^^^^^
     */
    public static final class ForNode extends Node {
        public final Node index;
        public final Node collection;
        /** optional (can be null) */
        public final StatementsNode statements;

        public ForNode(Node index, Node collection, StatementsNode statements, int startOffset, int length) {
            super(startOffset, length);
            this.index = index;
            this.collection = collection;
            this.statements = statements;
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
            this.index.accept(visitor);
            this.collection.accept(visitor);
            if (this.statements != null) {
                this.statements.accept(visitor);
            }
        }

        public Node[] childNodes() {
            return new Node[] { this.index, this.collection, this.statements };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitForNode(this);
        }

        @Override
        protected String toString(String indent) {
            StringBuilder builder = new StringBuilder();
            builder.append(this.getClass().getSimpleName());
            if (hasNewLineFlag()) {
                builder.append("[Li]");
            }
            builder.append('\n');
            String nextIndent = indent + "  ";
            builder.append(nextIndent);
            builder.append("index: ");
            builder.append(this.index.toString(nextIndent));
            builder.append(nextIndent);
            builder.append("collection: ");
            builder.append(this.collection.toString(nextIndent));
            builder.append(nextIndent);
            builder.append("statements: ");
            builder.append(this.statements == null ? "null\n" : this.statements.toString(nextIndent));
            return builder.toString();
        }
    }

    /**
     * Represents forwarding all arguments to this method to another method.
     *
     *     def foo(...)
     *       bar(...)
     *           ^^^
     *     end
     */
    public static final class ForwardingArgumentsNode extends Node {

        public ForwardingArgumentsNode(int startOffset, int length) {
            super(startOffset, length);
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
        }

        public Node[] childNodes() {
            return EMPTY_ARRAY;
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitForwardingArgumentsNode(this);
        }

        @Override
        protected String toString(String indent) {
            StringBuilder builder = new StringBuilder();
            builder.append(this.getClass().getSimpleName());
            if (hasNewLineFlag()) {
                builder.append("[Li]");
            }
            builder.append('\n');
            String nextIndent = indent + "  ";
            return builder.toString();
        }
    }

    /**
     * Represents the use of the forwarding parameter in a method, block, or lambda declaration.
     *
     *     def foo(...)
     *             ^^^
     *     end
     */
    public static final class ForwardingParameterNode extends Node {

        public ForwardingParameterNode(int startOffset, int length) {
            super(startOffset, length);
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
        }

        public Node[] childNodes() {
            return EMPTY_ARRAY;
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitForwardingParameterNode(this);
        }

        @Override
        protected String toString(String indent) {
            StringBuilder builder = new StringBuilder();
            builder.append(this.getClass().getSimpleName());
            if (hasNewLineFlag()) {
                builder.append("[Li]");
            }
            builder.append('\n');
            String nextIndent = indent + "  ";
            return builder.toString();
        }
    }

    /**
     * Represents the use of the `super` keyword without parentheses or arguments.
     *
     *     super
     *     ^^^^^
     */
    public static final class ForwardingSuperNode extends Node {
        /** optional (can be null) */
        public final BlockNode block;

        public ForwardingSuperNode(BlockNode block, int startOffset, int length) {
            super(startOffset, length);
            this.block = block;
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
            if (this.block != null) {
                this.block.accept(visitor);
            }
        }

        public Node[] childNodes() {
            return new Node[] { this.block };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitForwardingSuperNode(this);
        }

        @Override
        protected String toString(String indent) {
            StringBuilder builder = new StringBuilder();
            builder.append(this.getClass().getSimpleName());
            if (hasNewLineFlag()) {
                builder.append("[Li]");
            }
            builder.append('\n');
            String nextIndent = indent + "  ";
            builder.append(nextIndent);
            builder.append("block: ");
            builder.append(this.block == null ? "null\n" : this.block.toString(nextIndent));
            return builder.toString();
        }
    }

    /**
     * Represents the use of the `&&=` operator for assignment to a global variable.
     *
     *     $target &&= value
     *     ^^^^^^^^^^^^^^^^^
     */
    public static final class GlobalVariableAndWriteNode extends Node {
        public final org.jruby.RubySymbol name;
        public final Node value;

        public GlobalVariableAndWriteNode(org.jruby.RubySymbol name, Node value, int startOffset, int length) {
            super(startOffset, length);
            this.name = name;
            this.value = value;
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
            this.value.accept(visitor);
        }

        public Node[] childNodes() {
            return new Node[] { this.value };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitGlobalVariableAndWriteNode(this);
        }

        @Override
        protected String toString(String indent) {
            StringBuilder builder = new StringBuilder();
            builder.append(this.getClass().getSimpleName());
            if (hasNewLineFlag()) {
                builder.append("[Li]");
            }
            builder.append('\n');
            String nextIndent = indent + "  ";
            builder.append(nextIndent);
            builder.append("name: ");
            builder.append('"').append(this.name).append('"');
            builder.append('\n');
            builder.append(nextIndent);
            builder.append("value: ");
            builder.append(this.value.toString(nextIndent));
            return builder.toString();
        }
    }

    /**
     * Represents assigning to a global variable using an operator that isn't `=`.
     *
     *     $target += value
     *     ^^^^^^^^^^^^^^^^
     */
    public static final class GlobalVariableOperatorWriteNode extends Node {
        public final org.jruby.RubySymbol name;
        public final Node value;
        public final org.jruby.RubySymbol operator;

        public GlobalVariableOperatorWriteNode(org.jruby.RubySymbol name, Node value, org.jruby.RubySymbol operator, int startOffset, int length) {
            super(startOffset, length);
            this.name = name;
            this.value = value;
            this.operator = operator;
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
            this.value.accept(visitor);
        }

        public Node[] childNodes() {
            return new Node[] { this.value };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitGlobalVariableOperatorWriteNode(this);
        }

        @Override
        protected String toString(String indent) {
            StringBuilder builder = new StringBuilder();
            builder.append(this.getClass().getSimpleName());
            if (hasNewLineFlag()) {
                builder.append("[Li]");
            }
            builder.append('\n');
            String nextIndent = indent + "  ";
            builder.append(nextIndent);
            builder.append("name: ");
            builder.append('"').append(this.name).append('"');
            builder.append('\n');
            builder.append(nextIndent);
            builder.append("value: ");
            builder.append(this.value.toString(nextIndent));
            builder.append(nextIndent);
            builder.append("operator: ");
            builder.append('"').append(this.operator).append('"');
            builder.append('\n');
            return builder.toString();
        }
    }

    /**
     * Represents the use of the `||=` operator for assignment to a global variable.
     *
     *     $target ||= value
     *     ^^^^^^^^^^^^^^^^^
     */
    public static final class GlobalVariableOrWriteNode extends Node {
        public final org.jruby.RubySymbol name;
        public final Node value;

        public GlobalVariableOrWriteNode(org.jruby.RubySymbol name, Node value, int startOffset, int length) {
            super(startOffset, length);
            this.name = name;
            this.value = value;
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
            this.value.accept(visitor);
        }

        public Node[] childNodes() {
            return new Node[] { this.value };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitGlobalVariableOrWriteNode(this);
        }

        @Override
        protected String toString(String indent) {
            StringBuilder builder = new StringBuilder();
            builder.append(this.getClass().getSimpleName());
            if (hasNewLineFlag()) {
                builder.append("[Li]");
            }
            builder.append('\n');
            String nextIndent = indent + "  ";
            builder.append(nextIndent);
            builder.append("name: ");
            builder.append('"').append(this.name).append('"');
            builder.append('\n');
            builder.append(nextIndent);
            builder.append("value: ");
            builder.append(this.value.toString(nextIndent));
            return builder.toString();
        }
    }

    /**
     * Represents referencing a global variable.
     *
     *     $foo
     *     ^^^^
     */
    public static final class GlobalVariableReadNode extends Node {
        public final org.jruby.RubySymbol name;

        public GlobalVariableReadNode(org.jruby.RubySymbol name, int startOffset, int length) {
            super(startOffset, length);
            this.name = name;
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
        }

        public Node[] childNodes() {
            return EMPTY_ARRAY;
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitGlobalVariableReadNode(this);
        }

        @Override
        protected String toString(String indent) {
            StringBuilder builder = new StringBuilder();
            builder.append(this.getClass().getSimpleName());
            if (hasNewLineFlag()) {
                builder.append("[Li]");
            }
            builder.append('\n');
            String nextIndent = indent + "  ";
            builder.append(nextIndent);
            builder.append("name: ");
            builder.append('"').append(this.name).append('"');
            builder.append('\n');
            return builder.toString();
        }
    }

    /**
     * Represents writing to a global variable in a context that doesn't have an explicit value.
     *
     *     $foo, $bar = baz
     *     ^^^^  ^^^^
     */
    public static final class GlobalVariableTargetNode extends Node {
        public final org.jruby.RubySymbol name;

        public GlobalVariableTargetNode(org.jruby.RubySymbol name, int startOffset, int length) {
            super(startOffset, length);
            this.name = name;
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
        }

        public Node[] childNodes() {
            return EMPTY_ARRAY;
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitGlobalVariableTargetNode(this);
        }

        @Override
        protected String toString(String indent) {
            StringBuilder builder = new StringBuilder();
            builder.append(this.getClass().getSimpleName());
            if (hasNewLineFlag()) {
                builder.append("[Li]");
            }
            builder.append('\n');
            String nextIndent = indent + "  ";
            builder.append(nextIndent);
            builder.append("name: ");
            builder.append('"').append(this.name).append('"');
            builder.append('\n');
            return builder.toString();
        }
    }

    /**
     * Represents writing to a global variable.
     *
     *     $foo = 1
     *     ^^^^^^^^
     */
    public static final class GlobalVariableWriteNode extends Node {
        public final org.jruby.RubySymbol name;
        public final Node value;

        public GlobalVariableWriteNode(org.jruby.RubySymbol name, Node value, int startOffset, int length) {
            super(startOffset, length);
            this.name = name;
            this.value = value;
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
            this.value.accept(visitor);
        }

        public Node[] childNodes() {
            return new Node[] { this.value };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitGlobalVariableWriteNode(this);
        }

        @Override
        protected String toString(String indent) {
            StringBuilder builder = new StringBuilder();
            builder.append(this.getClass().getSimpleName());
            if (hasNewLineFlag()) {
                builder.append("[Li]");
            }
            builder.append('\n');
            String nextIndent = indent + "  ";
            builder.append(nextIndent);
            builder.append("name: ");
            builder.append('"').append(this.name).append('"');
            builder.append('\n');
            builder.append(nextIndent);
            builder.append("value: ");
            builder.append(this.value.toString(nextIndent));
            return builder.toString();
        }
    }

    /**
     * Represents a hash literal.
     *
     *     { a => b }
     *     ^^^^^^^^^^
     */
    public static final class HashNode extends Node {
        public final Node[] elements;

        public HashNode(Node[] elements, int startOffset, int length) {
            super(startOffset, length);
            this.elements = elements;
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
            for (Nodes.Node child : this.elements) {
                child.accept(visitor);
            }
        }

        public Node[] childNodes() {
            return this.elements;
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitHashNode(this);
        }

        @Override
        protected String toString(String indent) {
            StringBuilder builder = new StringBuilder();
            builder.append(this.getClass().getSimpleName());
            if (hasNewLineFlag()) {
                builder.append("[Li]");
            }
            builder.append('\n');
            String nextIndent = indent + "  ";
            String nextNextIndent = nextIndent + "  ";
            builder.append(nextIndent);
            builder.append("elements: ");
            builder.append('\n');
            for (Node child : this.elements) {
                builder.append(nextNextIndent).append(child.toString(nextNextIndent));
            }
            return builder.toString();
        }
    }

    /**
     * Represents a hash pattern in pattern matching.
     *
     *     foo => { a: 1, b: 2 }
     *            ^^^^^^^^^^^^^^
     *
     *     foo => { a: 1, b: 2, **c }
     *            ^^^^^^^^^^^^^^^^^^^
     */
    public static final class HashPatternNode extends Node {
        /** optional (can be null) */
        public final Node constant;
        public final Node[] elements;
        /** optional (can be null) */
        public final Node rest;

        public HashPatternNode(Node constant, Node[] elements, Node rest, int startOffset, int length) {
            super(startOffset, length);
            this.constant = constant;
            this.elements = elements;
            this.rest = rest;
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
            if (this.constant != null) {
                this.constant.accept(visitor);
            }
            for (Nodes.Node child : this.elements) {
                child.accept(visitor);
            }
            if (this.rest != null) {
                this.rest.accept(visitor);
            }
        }

        public Node[] childNodes() {
            ArrayList<Node> childNodes = new ArrayList<>();
            childNodes.add(this.constant);
            childNodes.addAll(Arrays.asList(this.elements));
            childNodes.add(this.rest);
            return childNodes.toArray(EMPTY_ARRAY);
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitHashPatternNode(this);
        }

        @Override
        protected String toString(String indent) {
            StringBuilder builder = new StringBuilder();
            builder.append(this.getClass().getSimpleName());
            if (hasNewLineFlag()) {
                builder.append("[Li]");
            }
            builder.append('\n');
            String nextIndent = indent + "  ";
            String nextNextIndent = nextIndent + "  ";
            builder.append(nextIndent);
            builder.append("constant: ");
            builder.append(this.constant == null ? "null\n" : this.constant.toString(nextIndent));
            builder.append(nextIndent);
            builder.append("elements: ");
            builder.append('\n');
            for (Node child : this.elements) {
                builder.append(nextNextIndent).append(child.toString(nextNextIndent));
            }
            builder.append(nextIndent);
            builder.append("rest: ");
            builder.append(this.rest == null ? "null\n" : this.rest.toString(nextIndent));
            return builder.toString();
        }
    }

    /**
     * Represents the use of the `if` keyword, either in the block form or the modifier form.
     *
     *     bar if foo
     *     ^^^^^^^^^^
     *
     *     if foo then bar end
     *     ^^^^^^^^^^^^^^^^^^^
     */
    public static final class IfNode extends Node {
        public final Node predicate;
        /** optional (can be null) */
        public final StatementsNode statements;
        /** optional (can be null) */
        public final Node consequent;

        public IfNode(Node predicate, StatementsNode statements, Node consequent, int startOffset, int length) {
            super(startOffset, length);
            this.predicate = predicate;
            this.statements = statements;
            this.consequent = consequent;
        }
                
        @Override
        public void setNewLineFlag(Source source, boolean[] newlineMarked) {
            this.predicate.setNewLineFlag(source, newlineMarked);
        }

        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
            this.predicate.accept(visitor);
            if (this.statements != null) {
                this.statements.accept(visitor);
            }
            if (this.consequent != null) {
                this.consequent.accept(visitor);
            }
        }

        public Node[] childNodes() {
            return new Node[] { this.predicate, this.statements, this.consequent };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitIfNode(this);
        }

        @Override
        protected String toString(String indent) {
            StringBuilder builder = new StringBuilder();
            builder.append(this.getClass().getSimpleName());
            if (hasNewLineFlag()) {
                builder.append("[Li]");
            }
            builder.append('\n');
            String nextIndent = indent + "  ";
            builder.append(nextIndent);
            builder.append("predicate: ");
            builder.append(this.predicate.toString(nextIndent));
            builder.append(nextIndent);
            builder.append("statements: ");
            builder.append(this.statements == null ? "null\n" : this.statements.toString(nextIndent));
            builder.append(nextIndent);
            builder.append("consequent: ");
            builder.append(this.consequent == null ? "null\n" : this.consequent.toString(nextIndent));
            return builder.toString();
        }
    }

    /**
     * Represents an imaginary number literal.
     *
     *     1.0i
     *     ^^^^
     */
    public static final class ImaginaryNode extends Node {
        public final Node numeric;

        public ImaginaryNode(Node numeric, int startOffset, int length) {
            super(startOffset, length);
            this.numeric = numeric;
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
            this.numeric.accept(visitor);
        }

        public Node[] childNodes() {
            return new Node[] { this.numeric };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitImaginaryNode(this);
        }

        @Override
        protected String toString(String indent) {
            StringBuilder builder = new StringBuilder();
            builder.append(this.getClass().getSimpleName());
            if (hasNewLineFlag()) {
                builder.append("[Li]");
            }
            builder.append('\n');
            String nextIndent = indent + "  ";
            builder.append(nextIndent);
            builder.append("numeric: ");
            builder.append(this.numeric.toString(nextIndent));
            return builder.toString();
        }
    }

    /**
     * Represents a node that is implicitly being added to the tree but doesn't
     * correspond directly to a node in the source.
     *
     *     { foo: }
     *       ^^^^
     *
     *     { Foo: }
     *       ^^^^
     */
    public static final class ImplicitNode extends Node {
        public final Node value;

        public ImplicitNode(Node value, int startOffset, int length) {
            super(startOffset, length);
            this.value = value;
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
            this.value.accept(visitor);
        }

        public Node[] childNodes() {
            return new Node[] { this.value };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitImplicitNode(this);
        }

        @Override
        protected String toString(String indent) {
            StringBuilder builder = new StringBuilder();
            builder.append(this.getClass().getSimpleName());
            if (hasNewLineFlag()) {
                builder.append("[Li]");
            }
            builder.append('\n');
            String nextIndent = indent + "  ";
            builder.append(nextIndent);
            builder.append("value: ");
            builder.append(this.value.toString(nextIndent));
            return builder.toString();
        }
    }

    /**
     * Represents using a trailing comma to indicate an implicit rest parameter.
     *
     *     foo { |bar,| }
     *               ^
     *
     *     foo in [bar,]
     *                ^
     *
     *     for foo, in bar do end
     *            ^
     *
     *     foo, = bar
     *        ^
     */
    public static final class ImplicitRestNode extends Node {

        public ImplicitRestNode(int startOffset, int length) {
            super(startOffset, length);
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
        }

        public Node[] childNodes() {
            return EMPTY_ARRAY;
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitImplicitRestNode(this);
        }

        @Override
        protected String toString(String indent) {
            StringBuilder builder = new StringBuilder();
            builder.append(this.getClass().getSimpleName());
            if (hasNewLineFlag()) {
                builder.append("[Li]");
            }
            builder.append('\n');
            String nextIndent = indent + "  ";
            return builder.toString();
        }
    }

    /**
     * Represents the use of the `in` keyword in a case statement.
     *
     *     case a; in b then c end
     *             ^^^^^^^^^^^
     */
    public static final class InNode extends Node {
        public final Node pattern;
        /** optional (can be null) */
        public final StatementsNode statements;

        public InNode(Node pattern, StatementsNode statements, int startOffset, int length) {
            super(startOffset, length);
            this.pattern = pattern;
            this.statements = statements;
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
            this.pattern.accept(visitor);
            if (this.statements != null) {
                this.statements.accept(visitor);
            }
        }

        public Node[] childNodes() {
            return new Node[] { this.pattern, this.statements };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitInNode(this);
        }

        @Override
        protected String toString(String indent) {
            StringBuilder builder = new StringBuilder();
            builder.append(this.getClass().getSimpleName());
            if (hasNewLineFlag()) {
                builder.append("[Li]");
            }
            builder.append('\n');
            String nextIndent = indent + "  ";
            builder.append(nextIndent);
            builder.append("pattern: ");
            builder.append(this.pattern.toString(nextIndent));
            builder.append(nextIndent);
            builder.append("statements: ");
            builder.append(this.statements == null ? "null\n" : this.statements.toString(nextIndent));
            return builder.toString();
        }
    }

    /**
     * Represents the use of the `&&=` operator on a call to the `[]` method.
     *
     *     foo.bar[baz] &&= value
     *     ^^^^^^^^^^^^^^^^^^^^^^
     */
    public static final class IndexAndWriteNode extends Node {
        /** optional (can be null) */
        public final Node receiver;
        /** optional (can be null) */
        public final ArgumentsNode arguments;
        /** optional (can be null) */
        public final Node block;
        public final short flags;
        public final Node value;

        public IndexAndWriteNode(Node receiver, ArgumentsNode arguments, Node block, short flags, Node value, int startOffset, int length) {
            super(startOffset, length);
            this.receiver = receiver;
            this.arguments = arguments;
            this.block = block;
            this.flags = flags;
            this.value = value;
        }
        
        public boolean isSafeNavigation() {
            return CallNodeFlags.isSafeNavigation(this.flags);
        }

        public boolean isVariableCall() {
            return CallNodeFlags.isVariableCall(this.flags);
        }
        
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
            if (this.receiver != null) {
                this.receiver.accept(visitor);
            }
            if (this.arguments != null) {
                this.arguments.accept(visitor);
            }
            if (this.block != null) {
                this.block.accept(visitor);
            }
            this.value.accept(visitor);
        }

        public Node[] childNodes() {
            return new Node[] { this.receiver, this.arguments, this.block, this.value };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitIndexAndWriteNode(this);
        }

        @Override
        protected String toString(String indent) {
            StringBuilder builder = new StringBuilder();
            builder.append(this.getClass().getSimpleName());
            if (hasNewLineFlag()) {
                builder.append("[Li]");
            }
            builder.append('\n');
            String nextIndent = indent + "  ";
            builder.append(nextIndent);
            builder.append("receiver: ");
            builder.append(this.receiver == null ? "null\n" : this.receiver.toString(nextIndent));
            builder.append(nextIndent);
            builder.append("arguments: ");
            builder.append(this.arguments == null ? "null\n" : this.arguments.toString(nextIndent));
            builder.append(nextIndent);
            builder.append("block: ");
            builder.append(this.block == null ? "null\n" : this.block.toString(nextIndent));
            builder.append(nextIndent);
            builder.append("flags: ");
            builder.append(this.flags);
            builder.append('\n');
            builder.append(nextIndent);
            builder.append("value: ");
            builder.append(this.value.toString(nextIndent));
            return builder.toString();
        }
    }

    /**
     * Represents the use of an assignment operator on a call to `[]`.
     *
     *     foo.bar[baz] += value
     *     ^^^^^^^^^^^^^^^^^^^^^
     */
    public static final class IndexOperatorWriteNode extends Node {
        /** optional (can be null) */
        public final Node receiver;
        /** optional (can be null) */
        public final ArgumentsNode arguments;
        /** optional (can be null) */
        public final Node block;
        public final short flags;
        public final org.jruby.RubySymbol operator;
        public final Node value;

        public IndexOperatorWriteNode(Node receiver, ArgumentsNode arguments, Node block, short flags, org.jruby.RubySymbol operator, Node value, int startOffset, int length) {
            super(startOffset, length);
            this.receiver = receiver;
            this.arguments = arguments;
            this.block = block;
            this.flags = flags;
            this.operator = operator;
            this.value = value;
        }
        
        public boolean isSafeNavigation() {
            return CallNodeFlags.isSafeNavigation(this.flags);
        }

        public boolean isVariableCall() {
            return CallNodeFlags.isVariableCall(this.flags);
        }
        
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
            if (this.receiver != null) {
                this.receiver.accept(visitor);
            }
            if (this.arguments != null) {
                this.arguments.accept(visitor);
            }
            if (this.block != null) {
                this.block.accept(visitor);
            }
            this.value.accept(visitor);
        }

        public Node[] childNodes() {
            return new Node[] { this.receiver, this.arguments, this.block, this.value };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitIndexOperatorWriteNode(this);
        }

        @Override
        protected String toString(String indent) {
            StringBuilder builder = new StringBuilder();
            builder.append(this.getClass().getSimpleName());
            if (hasNewLineFlag()) {
                builder.append("[Li]");
            }
            builder.append('\n');
            String nextIndent = indent + "  ";
            builder.append(nextIndent);
            builder.append("receiver: ");
            builder.append(this.receiver == null ? "null\n" : this.receiver.toString(nextIndent));
            builder.append(nextIndent);
            builder.append("arguments: ");
            builder.append(this.arguments == null ? "null\n" : this.arguments.toString(nextIndent));
            builder.append(nextIndent);
            builder.append("block: ");
            builder.append(this.block == null ? "null\n" : this.block.toString(nextIndent));
            builder.append(nextIndent);
            builder.append("flags: ");
            builder.append(this.flags);
            builder.append('\n');
            builder.append(nextIndent);
            builder.append("operator: ");
            builder.append('"').append(this.operator).append('"');
            builder.append('\n');
            builder.append(nextIndent);
            builder.append("value: ");
            builder.append(this.value.toString(nextIndent));
            return builder.toString();
        }
    }

    /**
     * Represents the use of the `||=` operator on a call to `[]`.
     *
     *     foo.bar[baz] ||= value
     *     ^^^^^^^^^^^^^^^^^^^^^^
     */
    public static final class IndexOrWriteNode extends Node {
        /** optional (can be null) */
        public final Node receiver;
        /** optional (can be null) */
        public final ArgumentsNode arguments;
        /** optional (can be null) */
        public final Node block;
        public final short flags;
        public final Node value;

        public IndexOrWriteNode(Node receiver, ArgumentsNode arguments, Node block, short flags, Node value, int startOffset, int length) {
            super(startOffset, length);
            this.receiver = receiver;
            this.arguments = arguments;
            this.block = block;
            this.flags = flags;
            this.value = value;
        }
        
        public boolean isSafeNavigation() {
            return CallNodeFlags.isSafeNavigation(this.flags);
        }

        public boolean isVariableCall() {
            return CallNodeFlags.isVariableCall(this.flags);
        }
        
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
            if (this.receiver != null) {
                this.receiver.accept(visitor);
            }
            if (this.arguments != null) {
                this.arguments.accept(visitor);
            }
            if (this.block != null) {
                this.block.accept(visitor);
            }
            this.value.accept(visitor);
        }

        public Node[] childNodes() {
            return new Node[] { this.receiver, this.arguments, this.block, this.value };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitIndexOrWriteNode(this);
        }

        @Override
        protected String toString(String indent) {
            StringBuilder builder = new StringBuilder();
            builder.append(this.getClass().getSimpleName());
            if (hasNewLineFlag()) {
                builder.append("[Li]");
            }
            builder.append('\n');
            String nextIndent = indent + "  ";
            builder.append(nextIndent);
            builder.append("receiver: ");
            builder.append(this.receiver == null ? "null\n" : this.receiver.toString(nextIndent));
            builder.append(nextIndent);
            builder.append("arguments: ");
            builder.append(this.arguments == null ? "null\n" : this.arguments.toString(nextIndent));
            builder.append(nextIndent);
            builder.append("block: ");
            builder.append(this.block == null ? "null\n" : this.block.toString(nextIndent));
            builder.append(nextIndent);
            builder.append("flags: ");
            builder.append(this.flags);
            builder.append('\n');
            builder.append(nextIndent);
            builder.append("value: ");
            builder.append(this.value.toString(nextIndent));
            return builder.toString();
        }
    }

    /**
     * Represents the use of the `&&=` operator for assignment to an instance variable.
     *
     *     @target &&= value
     *     ^^^^^^^^^^^^^^^^^
     */
    public static final class InstanceVariableAndWriteNode extends Node {
        public final org.jruby.RubySymbol name;
        public final Node value;

        public InstanceVariableAndWriteNode(org.jruby.RubySymbol name, Node value, int startOffset, int length) {
            super(startOffset, length);
            this.name = name;
            this.value = value;
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
            this.value.accept(visitor);
        }

        public Node[] childNodes() {
            return new Node[] { this.value };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitInstanceVariableAndWriteNode(this);
        }

        @Override
        protected String toString(String indent) {
            StringBuilder builder = new StringBuilder();
            builder.append(this.getClass().getSimpleName());
            if (hasNewLineFlag()) {
                builder.append("[Li]");
            }
            builder.append('\n');
            String nextIndent = indent + "  ";
            builder.append(nextIndent);
            builder.append("name: ");
            builder.append('"').append(this.name).append('"');
            builder.append('\n');
            builder.append(nextIndent);
            builder.append("value: ");
            builder.append(this.value.toString(nextIndent));
            return builder.toString();
        }
    }

    /**
     * Represents assigning to an instance variable using an operator that isn't `=`.
     *
     *     @target += value
     *     ^^^^^^^^^^^^^^^^
     */
    public static final class InstanceVariableOperatorWriteNode extends Node {
        public final org.jruby.RubySymbol name;
        public final Node value;
        public final org.jruby.RubySymbol operator;

        public InstanceVariableOperatorWriteNode(org.jruby.RubySymbol name, Node value, org.jruby.RubySymbol operator, int startOffset, int length) {
            super(startOffset, length);
            this.name = name;
            this.value = value;
            this.operator = operator;
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
            this.value.accept(visitor);
        }

        public Node[] childNodes() {
            return new Node[] { this.value };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitInstanceVariableOperatorWriteNode(this);
        }

        @Override
        protected String toString(String indent) {
            StringBuilder builder = new StringBuilder();
            builder.append(this.getClass().getSimpleName());
            if (hasNewLineFlag()) {
                builder.append("[Li]");
            }
            builder.append('\n');
            String nextIndent = indent + "  ";
            builder.append(nextIndent);
            builder.append("name: ");
            builder.append('"').append(this.name).append('"');
            builder.append('\n');
            builder.append(nextIndent);
            builder.append("value: ");
            builder.append(this.value.toString(nextIndent));
            builder.append(nextIndent);
            builder.append("operator: ");
            builder.append('"').append(this.operator).append('"');
            builder.append('\n');
            return builder.toString();
        }
    }

    /**
     * Represents the use of the `||=` operator for assignment to an instance variable.
     *
     *     @target ||= value
     *     ^^^^^^^^^^^^^^^^^
     */
    public static final class InstanceVariableOrWriteNode extends Node {
        public final org.jruby.RubySymbol name;
        public final Node value;

        public InstanceVariableOrWriteNode(org.jruby.RubySymbol name, Node value, int startOffset, int length) {
            super(startOffset, length);
            this.name = name;
            this.value = value;
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
            this.value.accept(visitor);
        }

        public Node[] childNodes() {
            return new Node[] { this.value };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitInstanceVariableOrWriteNode(this);
        }

        @Override
        protected String toString(String indent) {
            StringBuilder builder = new StringBuilder();
            builder.append(this.getClass().getSimpleName());
            if (hasNewLineFlag()) {
                builder.append("[Li]");
            }
            builder.append('\n');
            String nextIndent = indent + "  ";
            builder.append(nextIndent);
            builder.append("name: ");
            builder.append('"').append(this.name).append('"');
            builder.append('\n');
            builder.append(nextIndent);
            builder.append("value: ");
            builder.append(this.value.toString(nextIndent));
            return builder.toString();
        }
    }

    /**
     * Represents referencing an instance variable.
     *
     *     @foo
     *     ^^^^
     */
    public static final class InstanceVariableReadNode extends Node {
        public final org.jruby.RubySymbol name;

        public InstanceVariableReadNode(org.jruby.RubySymbol name, int startOffset, int length) {
            super(startOffset, length);
            this.name = name;
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
        }

        public Node[] childNodes() {
            return EMPTY_ARRAY;
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitInstanceVariableReadNode(this);
        }

        @Override
        protected String toString(String indent) {
            StringBuilder builder = new StringBuilder();
            builder.append(this.getClass().getSimpleName());
            if (hasNewLineFlag()) {
                builder.append("[Li]");
            }
            builder.append('\n');
            String nextIndent = indent + "  ";
            builder.append(nextIndent);
            builder.append("name: ");
            builder.append('"').append(this.name).append('"');
            builder.append('\n');
            return builder.toString();
        }
    }

    /**
     * Represents writing to an instance variable in a context that doesn't have an explicit value.
     *
     *     @foo, @bar = baz
     *     ^^^^  ^^^^
     */
    public static final class InstanceVariableTargetNode extends Node {
        public final org.jruby.RubySymbol name;

        public InstanceVariableTargetNode(org.jruby.RubySymbol name, int startOffset, int length) {
            super(startOffset, length);
            this.name = name;
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
        }

        public Node[] childNodes() {
            return EMPTY_ARRAY;
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitInstanceVariableTargetNode(this);
        }

        @Override
        protected String toString(String indent) {
            StringBuilder builder = new StringBuilder();
            builder.append(this.getClass().getSimpleName());
            if (hasNewLineFlag()) {
                builder.append("[Li]");
            }
            builder.append('\n');
            String nextIndent = indent + "  ";
            builder.append(nextIndent);
            builder.append("name: ");
            builder.append('"').append(this.name).append('"');
            builder.append('\n');
            return builder.toString();
        }
    }

    /**
     * Represents writing to an instance variable.
     *
     *     @foo = 1
     *     ^^^^^^^^
     */
    public static final class InstanceVariableWriteNode extends Node {
        public final org.jruby.RubySymbol name;
        public final Node value;

        public InstanceVariableWriteNode(org.jruby.RubySymbol name, Node value, int startOffset, int length) {
            super(startOffset, length);
            this.name = name;
            this.value = value;
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
            this.value.accept(visitor);
        }

        public Node[] childNodes() {
            return new Node[] { this.value };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitInstanceVariableWriteNode(this);
        }

        @Override
        protected String toString(String indent) {
            StringBuilder builder = new StringBuilder();
            builder.append(this.getClass().getSimpleName());
            if (hasNewLineFlag()) {
                builder.append("[Li]");
            }
            builder.append('\n');
            String nextIndent = indent + "  ";
            builder.append(nextIndent);
            builder.append("name: ");
            builder.append('"').append(this.name).append('"');
            builder.append('\n');
            builder.append(nextIndent);
            builder.append("value: ");
            builder.append(this.value.toString(nextIndent));
            return builder.toString();
        }
    }

    /**
     * Represents an integer number literal.
     *
     *     1
     *     ^
     */
    public static final class IntegerNode extends Node {
        public final short flags;

        public IntegerNode(short flags, int startOffset, int length) {
            super(startOffset, length);
            this.flags = flags;
        }
        
        public boolean isBinary() {
            return IntegerBaseFlags.isBinary(this.flags);
        }

        public boolean isOctal() {
            return IntegerBaseFlags.isOctal(this.flags);
        }

        public boolean isDecimal() {
            return IntegerBaseFlags.isDecimal(this.flags);
        }

        public boolean isHexadecimal() {
            return IntegerBaseFlags.isHexadecimal(this.flags);
        }
        
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
        }

        public Node[] childNodes() {
            return EMPTY_ARRAY;
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitIntegerNode(this);
        }

        @Override
        protected String toString(String indent) {
            StringBuilder builder = new StringBuilder();
            builder.append(this.getClass().getSimpleName());
            if (hasNewLineFlag()) {
                builder.append("[Li]");
            }
            builder.append('\n');
            String nextIndent = indent + "  ";
            builder.append(nextIndent);
            builder.append("flags: ");
            builder.append(this.flags);
            builder.append('\n');
            return builder.toString();
        }
    }

    /**
     * Represents a regular expression literal that contains interpolation that
     * is being used in the predicate of a conditional to implicitly match
     * against the last line read by an IO object.
     *
     *     if /foo #{bar} baz/ then end
     *        ^^^^^^^^^^^^^^^^
     */
    public static final class InterpolatedMatchLastLineNode extends Node {
        public final Node[] parts;
        public final short flags;

        public InterpolatedMatchLastLineNode(Node[] parts, short flags, int startOffset, int length) {
            super(startOffset, length);
            this.parts = parts;
            this.flags = flags;
        }
        
        public boolean isIgnoreCase() {
            return RegularExpressionFlags.isIgnoreCase(this.flags);
        }

        public boolean isExtended() {
            return RegularExpressionFlags.isExtended(this.flags);
        }

        public boolean isMultiLine() {
            return RegularExpressionFlags.isMultiLine(this.flags);
        }

        public boolean isOnce() {
            return RegularExpressionFlags.isOnce(this.flags);
        }

        public boolean isEucJp() {
            return RegularExpressionFlags.isEucJp(this.flags);
        }

        public boolean isAscii8bit() {
            return RegularExpressionFlags.isAscii8bit(this.flags);
        }

        public boolean isWindows31j() {
            return RegularExpressionFlags.isWindows31j(this.flags);
        }

        public boolean isUtf8() {
            return RegularExpressionFlags.isUtf8(this.flags);
        }
        
        @Override
        public void setNewLineFlag(Source source, boolean[] newlineMarked) {
            Node first = this.parts.length > 0 ? this.parts[0] : null;
            if (first != null) {
                first.setNewLineFlag(source, newlineMarked);
            }
        }

        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
            for (Nodes.Node child : this.parts) {
                child.accept(visitor);
            }
        }

        public Node[] childNodes() {
            return this.parts;
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitInterpolatedMatchLastLineNode(this);
        }

        @Override
        protected String toString(String indent) {
            StringBuilder builder = new StringBuilder();
            builder.append(this.getClass().getSimpleName());
            if (hasNewLineFlag()) {
                builder.append("[Li]");
            }
            builder.append('\n');
            String nextIndent = indent + "  ";
            String nextNextIndent = nextIndent + "  ";
            builder.append(nextIndent);
            builder.append("parts: ");
            builder.append('\n');
            for (Node child : this.parts) {
                builder.append(nextNextIndent).append(child.toString(nextNextIndent));
            }
            builder.append(nextIndent);
            builder.append("flags: ");
            builder.append(this.flags);
            builder.append('\n');
            return builder.toString();
        }
    }

    /**
     * Represents a regular expression literal that contains interpolation.
     *
     *     /foo #{bar} baz/
     *     ^^^^^^^^^^^^^^^^
     */
    public static final class InterpolatedRegularExpressionNode extends Node {
        public final Node[] parts;
        public final short flags;

        public InterpolatedRegularExpressionNode(Node[] parts, short flags, int startOffset, int length) {
            super(startOffset, length);
            this.parts = parts;
            this.flags = flags;
        }
        
        public boolean isIgnoreCase() {
            return RegularExpressionFlags.isIgnoreCase(this.flags);
        }

        public boolean isExtended() {
            return RegularExpressionFlags.isExtended(this.flags);
        }

        public boolean isMultiLine() {
            return RegularExpressionFlags.isMultiLine(this.flags);
        }

        public boolean isOnce() {
            return RegularExpressionFlags.isOnce(this.flags);
        }

        public boolean isEucJp() {
            return RegularExpressionFlags.isEucJp(this.flags);
        }

        public boolean isAscii8bit() {
            return RegularExpressionFlags.isAscii8bit(this.flags);
        }

        public boolean isWindows31j() {
            return RegularExpressionFlags.isWindows31j(this.flags);
        }

        public boolean isUtf8() {
            return RegularExpressionFlags.isUtf8(this.flags);
        }
        
        @Override
        public void setNewLineFlag(Source source, boolean[] newlineMarked) {
            Node first = this.parts.length > 0 ? this.parts[0] : null;
            if (first != null) {
                first.setNewLineFlag(source, newlineMarked);
            }
        }

        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
            for (Nodes.Node child : this.parts) {
                child.accept(visitor);
            }
        }

        public Node[] childNodes() {
            return this.parts;
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitInterpolatedRegularExpressionNode(this);
        }

        @Override
        protected String toString(String indent) {
            StringBuilder builder = new StringBuilder();
            builder.append(this.getClass().getSimpleName());
            if (hasNewLineFlag()) {
                builder.append("[Li]");
            }
            builder.append('\n');
            String nextIndent = indent + "  ";
            String nextNextIndent = nextIndent + "  ";
            builder.append(nextIndent);
            builder.append("parts: ");
            builder.append('\n');
            for (Node child : this.parts) {
                builder.append(nextNextIndent).append(child.toString(nextNextIndent));
            }
            builder.append(nextIndent);
            builder.append("flags: ");
            builder.append(this.flags);
            builder.append('\n');
            return builder.toString();
        }
    }

    /**
     * Represents a string literal that contains interpolation.
     *
     *     "foo #{bar} baz"
     *     ^^^^^^^^^^^^^^^^
     */
    public static final class InterpolatedStringNode extends Node {
        public final Node[] parts;

        public InterpolatedStringNode(Node[] parts, int startOffset, int length) {
            super(startOffset, length);
            this.parts = parts;
        }
                
        @Override
        public void setNewLineFlag(Source source, boolean[] newlineMarked) {
            Node first = this.parts.length > 0 ? this.parts[0] : null;
            if (first != null) {
                first.setNewLineFlag(source, newlineMarked);
            }
        }

        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
            for (Nodes.Node child : this.parts) {
                child.accept(visitor);
            }
        }

        public Node[] childNodes() {
            return this.parts;
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitInterpolatedStringNode(this);
        }

        @Override
        protected String toString(String indent) {
            StringBuilder builder = new StringBuilder();
            builder.append(this.getClass().getSimpleName());
            if (hasNewLineFlag()) {
                builder.append("[Li]");
            }
            builder.append('\n');
            String nextIndent = indent + "  ";
            String nextNextIndent = nextIndent + "  ";
            builder.append(nextIndent);
            builder.append("parts: ");
            builder.append('\n');
            for (Node child : this.parts) {
                builder.append(nextNextIndent).append(child.toString(nextNextIndent));
            }
            return builder.toString();
        }
    }

    /**
     * Represents a symbol literal that contains interpolation.
     *
     *     :"foo #{bar} baz"
     *     ^^^^^^^^^^^^^^^^^
     */
    public static final class InterpolatedSymbolNode extends Node {
        public final Node[] parts;

        public InterpolatedSymbolNode(Node[] parts, int startOffset, int length) {
            super(startOffset, length);
            this.parts = parts;
        }
                
        @Override
        public void setNewLineFlag(Source source, boolean[] newlineMarked) {
            Node first = this.parts.length > 0 ? this.parts[0] : null;
            if (first != null) {
                first.setNewLineFlag(source, newlineMarked);
            }
        }

        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
            for (Nodes.Node child : this.parts) {
                child.accept(visitor);
            }
        }

        public Node[] childNodes() {
            return this.parts;
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitInterpolatedSymbolNode(this);
        }

        @Override
        protected String toString(String indent) {
            StringBuilder builder = new StringBuilder();
            builder.append(this.getClass().getSimpleName());
            if (hasNewLineFlag()) {
                builder.append("[Li]");
            }
            builder.append('\n');
            String nextIndent = indent + "  ";
            String nextNextIndent = nextIndent + "  ";
            builder.append(nextIndent);
            builder.append("parts: ");
            builder.append('\n');
            for (Node child : this.parts) {
                builder.append(nextNextIndent).append(child.toString(nextNextIndent));
            }
            return builder.toString();
        }
    }

    /**
     * Represents an xstring literal that contains interpolation.
     *
     *     `foo #{bar} baz`
     *     ^^^^^^^^^^^^^^^^
     */
    public static final class InterpolatedXStringNode extends Node {
        public final Node[] parts;

        public InterpolatedXStringNode(Node[] parts, int startOffset, int length) {
            super(startOffset, length);
            this.parts = parts;
        }
                
        @Override
        public void setNewLineFlag(Source source, boolean[] newlineMarked) {
            Node first = this.parts.length > 0 ? this.parts[0] : null;
            if (first != null) {
                first.setNewLineFlag(source, newlineMarked);
            }
        }

        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
            for (Nodes.Node child : this.parts) {
                child.accept(visitor);
            }
        }

        public Node[] childNodes() {
            return this.parts;
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitInterpolatedXStringNode(this);
        }

        @Override
        protected String toString(String indent) {
            StringBuilder builder = new StringBuilder();
            builder.append(this.getClass().getSimpleName());
            if (hasNewLineFlag()) {
                builder.append("[Li]");
            }
            builder.append('\n');
            String nextIndent = indent + "  ";
            String nextNextIndent = nextIndent + "  ";
            builder.append(nextIndent);
            builder.append("parts: ");
            builder.append('\n');
            for (Node child : this.parts) {
                builder.append(nextNextIndent).append(child.toString(nextNextIndent));
            }
            return builder.toString();
        }
    }

    /**
     * Represents a hash literal without opening and closing braces.
     *
     *     foo(a: b)
     *         ^^^^
     */
    public static final class KeywordHashNode extends Node {
        public final Node[] elements;

        public KeywordHashNode(Node[] elements, int startOffset, int length) {
            super(startOffset, length);
            this.elements = elements;
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
            for (Nodes.Node child : this.elements) {
                child.accept(visitor);
            }
        }

        public Node[] childNodes() {
            return this.elements;
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitKeywordHashNode(this);
        }

        @Override
        protected String toString(String indent) {
            StringBuilder builder = new StringBuilder();
            builder.append(this.getClass().getSimpleName());
            if (hasNewLineFlag()) {
                builder.append("[Li]");
            }
            builder.append('\n');
            String nextIndent = indent + "  ";
            String nextNextIndent = nextIndent + "  ";
            builder.append(nextIndent);
            builder.append("elements: ");
            builder.append('\n');
            for (Node child : this.elements) {
                builder.append(nextNextIndent).append(child.toString(nextNextIndent));
            }
            return builder.toString();
        }
    }

    /**
     * Represents a keyword rest parameter to a method, block, or lambda definition.
     *
     *     def a(**b)
     *           ^^^
     *     end
     */
    public static final class KeywordRestParameterNode extends Node {
        /** optional (can be null) */
        public final org.jruby.RubySymbol name;

        public KeywordRestParameterNode(org.jruby.RubySymbol name, int startOffset, int length) {
            super(startOffset, length);
            this.name = name;
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
        }

        public Node[] childNodes() {
            return EMPTY_ARRAY;
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitKeywordRestParameterNode(this);
        }

        @Override
        protected String toString(String indent) {
            StringBuilder builder = new StringBuilder();
            builder.append(this.getClass().getSimpleName());
            if (hasNewLineFlag()) {
                builder.append("[Li]");
            }
            builder.append('\n');
            String nextIndent = indent + "  ";
            builder.append(nextIndent);
            builder.append("name: ");
            builder.append(this.name == null ? "null" : "\"" + this.name + "\"");
            builder.append('\n');
            return builder.toString();
        }
    }

    /**
     * Represents using a lambda literal (not the lambda method call).
     *
     *     ->(value) { value * 2 }
     *     ^^^^^^^^^^^^^^^^^^^^^^^
     */
    public static final class LambdaNode extends Node {
        public final org.jruby.RubySymbol[] locals;
        /** optional (can be null) */
        public final Node parameters;
        /** optional (can be null) */
        public final Node body;

        public LambdaNode(org.jruby.RubySymbol[] locals, Node parameters, Node body, int startOffset, int length) {
            super(startOffset, length);
            this.locals = locals;
            this.parameters = parameters;
            this.body = body;
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
            if (this.parameters != null) {
                this.parameters.accept(visitor);
            }
            if (this.body != null) {
                this.body.accept(visitor);
            }
        }

        public Node[] childNodes() {
            return new Node[] { this.parameters, this.body };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitLambdaNode(this);
        }

        @Override
        protected String toString(String indent) {
            StringBuilder builder = new StringBuilder();
            builder.append(this.getClass().getSimpleName());
            if (hasNewLineFlag()) {
                builder.append("[Li]");
            }
            builder.append('\n');
            String nextIndent = indent + "  ";
            String nextNextIndent = nextIndent + "  ";
            builder.append(nextIndent);
            builder.append("locals: ");
            builder.append('\n');
            for (org.jruby.RubySymbol constant : this.locals) {
                builder.append(nextNextIndent).append('"').append(constant).append('"').append('\n');
            }
            builder.append(nextIndent);
            builder.append("parameters: ");
            builder.append(this.parameters == null ? "null\n" : this.parameters.toString(nextIndent));
            builder.append(nextIndent);
            builder.append("body: ");
            builder.append(this.body == null ? "null\n" : this.body.toString(nextIndent));
            return builder.toString();
        }
    }

    /**
     * Represents the use of the `&&=` operator for assignment to a local variable.
     *
     *     target &&= value
     *     ^^^^^^^^^^^^^^^^
     */
    public static final class LocalVariableAndWriteNode extends Node {
        public final Node value;
        public final org.jruby.RubySymbol name;
        public final int depth;

        public LocalVariableAndWriteNode(Node value, org.jruby.RubySymbol name, int depth, int startOffset, int length) {
            super(startOffset, length);
            this.value = value;
            this.name = name;
            this.depth = depth;
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
            this.value.accept(visitor);
        }

        public Node[] childNodes() {
            return new Node[] { this.value };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitLocalVariableAndWriteNode(this);
        }

        @Override
        protected String toString(String indent) {
            StringBuilder builder = new StringBuilder();
            builder.append(this.getClass().getSimpleName());
            if (hasNewLineFlag()) {
                builder.append("[Li]");
            }
            builder.append('\n');
            String nextIndent = indent + "  ";
            builder.append(nextIndent);
            builder.append("value: ");
            builder.append(this.value.toString(nextIndent));
            builder.append(nextIndent);
            builder.append("name: ");
            builder.append('"').append(this.name).append('"');
            builder.append('\n');
            builder.append(nextIndent);
            builder.append("depth: ");
            builder.append(this.depth);
            builder.append('\n');
            return builder.toString();
        }
    }

    /**
     * Represents assigning to a local variable using an operator that isn't `=`.
     *
     *     target += value
     *     ^^^^^^^^^^^^^^^
     */
    public static final class LocalVariableOperatorWriteNode extends Node {
        public final Node value;
        public final org.jruby.RubySymbol name;
        public final org.jruby.RubySymbol operator;
        public final int depth;

        public LocalVariableOperatorWriteNode(Node value, org.jruby.RubySymbol name, org.jruby.RubySymbol operator, int depth, int startOffset, int length) {
            super(startOffset, length);
            this.value = value;
            this.name = name;
            this.operator = operator;
            this.depth = depth;
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
            this.value.accept(visitor);
        }

        public Node[] childNodes() {
            return new Node[] { this.value };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitLocalVariableOperatorWriteNode(this);
        }

        @Override
        protected String toString(String indent) {
            StringBuilder builder = new StringBuilder();
            builder.append(this.getClass().getSimpleName());
            if (hasNewLineFlag()) {
                builder.append("[Li]");
            }
            builder.append('\n');
            String nextIndent = indent + "  ";
            builder.append(nextIndent);
            builder.append("value: ");
            builder.append(this.value.toString(nextIndent));
            builder.append(nextIndent);
            builder.append("name: ");
            builder.append('"').append(this.name).append('"');
            builder.append('\n');
            builder.append(nextIndent);
            builder.append("operator: ");
            builder.append('"').append(this.operator).append('"');
            builder.append('\n');
            builder.append(nextIndent);
            builder.append("depth: ");
            builder.append(this.depth);
            builder.append('\n');
            return builder.toString();
        }
    }

    /**
     * Represents the use of the `||=` operator for assignment to a local variable.
     *
     *     target ||= value
     *     ^^^^^^^^^^^^^^^^
     */
    public static final class LocalVariableOrWriteNode extends Node {
        public final Node value;
        public final org.jruby.RubySymbol name;
        public final int depth;

        public LocalVariableOrWriteNode(Node value, org.jruby.RubySymbol name, int depth, int startOffset, int length) {
            super(startOffset, length);
            this.value = value;
            this.name = name;
            this.depth = depth;
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
            this.value.accept(visitor);
        }

        public Node[] childNodes() {
            return new Node[] { this.value };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitLocalVariableOrWriteNode(this);
        }

        @Override
        protected String toString(String indent) {
            StringBuilder builder = new StringBuilder();
            builder.append(this.getClass().getSimpleName());
            if (hasNewLineFlag()) {
                builder.append("[Li]");
            }
            builder.append('\n');
            String nextIndent = indent + "  ";
            builder.append(nextIndent);
            builder.append("value: ");
            builder.append(this.value.toString(nextIndent));
            builder.append(nextIndent);
            builder.append("name: ");
            builder.append('"').append(this.name).append('"');
            builder.append('\n');
            builder.append(nextIndent);
            builder.append("depth: ");
            builder.append(this.depth);
            builder.append('\n');
            return builder.toString();
        }
    }

    /**
     * Represents reading a local variable. Note that this requires that a local
     * variable of the same name has already been written to in the same scope,
     * otherwise it is parsed as a method call.
     *
     *     foo
     *     ^^^
     */
    public static final class LocalVariableReadNode extends Node {
        public final org.jruby.RubySymbol name;
        public final int depth;

        public LocalVariableReadNode(org.jruby.RubySymbol name, int depth, int startOffset, int length) {
            super(startOffset, length);
            this.name = name;
            this.depth = depth;
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
        }

        public Node[] childNodes() {
            return EMPTY_ARRAY;
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitLocalVariableReadNode(this);
        }

        @Override
        protected String toString(String indent) {
            StringBuilder builder = new StringBuilder();
            builder.append(this.getClass().getSimpleName());
            if (hasNewLineFlag()) {
                builder.append("[Li]");
            }
            builder.append('\n');
            String nextIndent = indent + "  ";
            builder.append(nextIndent);
            builder.append("name: ");
            builder.append('"').append(this.name).append('"');
            builder.append('\n');
            builder.append(nextIndent);
            builder.append("depth: ");
            builder.append(this.depth);
            builder.append('\n');
            return builder.toString();
        }
    }

    /**
     * Represents writing to a local variable in a context that doesn't have an explicit value.
     *
     *     foo, bar = baz
     *     ^^^  ^^^
     */
    public static final class LocalVariableTargetNode extends Node {
        public final org.jruby.RubySymbol name;
        public final int depth;

        public LocalVariableTargetNode(org.jruby.RubySymbol name, int depth, int startOffset, int length) {
            super(startOffset, length);
            this.name = name;
            this.depth = depth;
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
        }

        public Node[] childNodes() {
            return EMPTY_ARRAY;
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitLocalVariableTargetNode(this);
        }

        @Override
        protected String toString(String indent) {
            StringBuilder builder = new StringBuilder();
            builder.append(this.getClass().getSimpleName());
            if (hasNewLineFlag()) {
                builder.append("[Li]");
            }
            builder.append('\n');
            String nextIndent = indent + "  ";
            builder.append(nextIndent);
            builder.append("name: ");
            builder.append('"').append(this.name).append('"');
            builder.append('\n');
            builder.append(nextIndent);
            builder.append("depth: ");
            builder.append(this.depth);
            builder.append('\n');
            return builder.toString();
        }
    }

    /**
     * Represents writing to a local variable.
     *
     *     foo = 1
     *     ^^^^^^^
     */
    public static final class LocalVariableWriteNode extends Node {
        public final org.jruby.RubySymbol name;
        public final int depth;
        public final Node value;

        public LocalVariableWriteNode(org.jruby.RubySymbol name, int depth, Node value, int startOffset, int length) {
            super(startOffset, length);
            this.name = name;
            this.depth = depth;
            this.value = value;
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
            this.value.accept(visitor);
        }

        public Node[] childNodes() {
            return new Node[] { this.value };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitLocalVariableWriteNode(this);
        }

        @Override
        protected String toString(String indent) {
            StringBuilder builder = new StringBuilder();
            builder.append(this.getClass().getSimpleName());
            if (hasNewLineFlag()) {
                builder.append("[Li]");
            }
            builder.append('\n');
            String nextIndent = indent + "  ";
            builder.append(nextIndent);
            builder.append("name: ");
            builder.append('"').append(this.name).append('"');
            builder.append('\n');
            builder.append(nextIndent);
            builder.append("depth: ");
            builder.append(this.depth);
            builder.append('\n');
            builder.append(nextIndent);
            builder.append("value: ");
            builder.append(this.value.toString(nextIndent));
            return builder.toString();
        }
    }

    /**
     * Represents a regular expression literal used in the predicate of a
     * conditional to implicitly match against the last line read by an IO
     * object.
     *
     *     if /foo/i then end
     *        ^^^^^^
     */
    public static final class MatchLastLineNode extends Node {
        public final byte[] unescaped;
        public final short flags;

        public MatchLastLineNode(byte[] unescaped, short flags, int startOffset, int length) {
            super(startOffset, length);
            this.unescaped = unescaped;
            this.flags = flags;
        }
        
        public boolean isIgnoreCase() {
            return RegularExpressionFlags.isIgnoreCase(this.flags);
        }

        public boolean isExtended() {
            return RegularExpressionFlags.isExtended(this.flags);
        }

        public boolean isMultiLine() {
            return RegularExpressionFlags.isMultiLine(this.flags);
        }

        public boolean isOnce() {
            return RegularExpressionFlags.isOnce(this.flags);
        }

        public boolean isEucJp() {
            return RegularExpressionFlags.isEucJp(this.flags);
        }

        public boolean isAscii8bit() {
            return RegularExpressionFlags.isAscii8bit(this.flags);
        }

        public boolean isWindows31j() {
            return RegularExpressionFlags.isWindows31j(this.flags);
        }

        public boolean isUtf8() {
            return RegularExpressionFlags.isUtf8(this.flags);
        }
        
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
        }

        public Node[] childNodes() {
            return EMPTY_ARRAY;
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitMatchLastLineNode(this);
        }

        @Override
        protected String toString(String indent) {
            StringBuilder builder = new StringBuilder();
            builder.append(this.getClass().getSimpleName());
            if (hasNewLineFlag()) {
                builder.append("[Li]");
            }
            builder.append('\n');
            String nextIndent = indent + "  ";
            builder.append(nextIndent);
            builder.append("unescaped: ");
            builder.append('"' + new String(this.unescaped, StandardCharsets.UTF_8) + '"');
            builder.append('\n');
            builder.append(nextIndent);
            builder.append("flags: ");
            builder.append(this.flags);
            builder.append('\n');
            return builder.toString();
        }
    }

    /**
     * Represents the use of the modifier `in` operator.
     *
     *     foo in bar
     *     ^^^^^^^^^^
     */
    public static final class MatchPredicateNode extends Node {
        public final Node value;
        public final Node pattern;

        public MatchPredicateNode(Node value, Node pattern, int startOffset, int length) {
            super(startOffset, length);
            this.value = value;
            this.pattern = pattern;
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
            this.value.accept(visitor);
            this.pattern.accept(visitor);
        }

        public Node[] childNodes() {
            return new Node[] { this.value, this.pattern };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitMatchPredicateNode(this);
        }

        @Override
        protected String toString(String indent) {
            StringBuilder builder = new StringBuilder();
            builder.append(this.getClass().getSimpleName());
            if (hasNewLineFlag()) {
                builder.append("[Li]");
            }
            builder.append('\n');
            String nextIndent = indent + "  ";
            builder.append(nextIndent);
            builder.append("value: ");
            builder.append(this.value.toString(nextIndent));
            builder.append(nextIndent);
            builder.append("pattern: ");
            builder.append(this.pattern.toString(nextIndent));
            return builder.toString();
        }
    }

    /**
     * Represents the use of the `=>` operator.
     *
     *     foo => bar
     *     ^^^^^^^^^^
     */
    public static final class MatchRequiredNode extends Node {
        public final Node value;
        public final Node pattern;

        public MatchRequiredNode(Node value, Node pattern, int startOffset, int length) {
            super(startOffset, length);
            this.value = value;
            this.pattern = pattern;
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
            this.value.accept(visitor);
            this.pattern.accept(visitor);
        }

        public Node[] childNodes() {
            return new Node[] { this.value, this.pattern };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitMatchRequiredNode(this);
        }

        @Override
        protected String toString(String indent) {
            StringBuilder builder = new StringBuilder();
            builder.append(this.getClass().getSimpleName());
            if (hasNewLineFlag()) {
                builder.append("[Li]");
            }
            builder.append('\n');
            String nextIndent = indent + "  ";
            builder.append(nextIndent);
            builder.append("value: ");
            builder.append(this.value.toString(nextIndent));
            builder.append(nextIndent);
            builder.append("pattern: ");
            builder.append(this.pattern.toString(nextIndent));
            return builder.toString();
        }
    }

    /**
     * Represents writing local variables using a regular expression match with
     * named capture groups.
     *
     *     /(?<foo>bar)/ =~ baz
     *     ^^^^^^^^^^^^^^^^^^^^
     */
    public static final class MatchWriteNode extends Node {
        public final CallNode call;
        public final Node[] targets;

        public MatchWriteNode(CallNode call, Node[] targets, int startOffset, int length) {
            super(startOffset, length);
            this.call = call;
            this.targets = targets;
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
            this.call.accept(visitor);
            for (Nodes.Node child : this.targets) {
                child.accept(visitor);
            }
        }

        public Node[] childNodes() {
            ArrayList<Node> childNodes = new ArrayList<>();
            childNodes.add(this.call);
            childNodes.addAll(Arrays.asList(this.targets));
            return childNodes.toArray(EMPTY_ARRAY);
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitMatchWriteNode(this);
        }

        @Override
        protected String toString(String indent) {
            StringBuilder builder = new StringBuilder();
            builder.append(this.getClass().getSimpleName());
            if (hasNewLineFlag()) {
                builder.append("[Li]");
            }
            builder.append('\n');
            String nextIndent = indent + "  ";
            String nextNextIndent = nextIndent + "  ";
            builder.append(nextIndent);
            builder.append("call: ");
            builder.append(this.call.toString(nextIndent));
            builder.append(nextIndent);
            builder.append("targets: ");
            builder.append('\n');
            for (Node child : this.targets) {
                builder.append(nextNextIndent).append(child.toString(nextNextIndent));
            }
            return builder.toString();
        }
    }

    /**
     * Represents a node that is missing from the source and results in a syntax
     * error.
     */
    public static final class MissingNode extends Node {

        public MissingNode(int startOffset, int length) {
            super(startOffset, length);
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
        }

        public Node[] childNodes() {
            return EMPTY_ARRAY;
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitMissingNode(this);
        }

        @Override
        protected String toString(String indent) {
            StringBuilder builder = new StringBuilder();
            builder.append(this.getClass().getSimpleName());
            if (hasNewLineFlag()) {
                builder.append("[Li]");
            }
            builder.append('\n');
            String nextIndent = indent + "  ";
            return builder.toString();
        }
    }

    /**
     * Represents a module declaration involving the `module` keyword.
     *
     *     module Foo end
     *     ^^^^^^^^^^^^^^
     */
    public static final class ModuleNode extends Node {
        public final org.jruby.RubySymbol[] locals;
        public final Node constant_path;
        /** optional (can be null) */
        public final Node body;
        public final org.jruby.RubySymbol name;

        public ModuleNode(org.jruby.RubySymbol[] locals, Node constant_path, Node body, org.jruby.RubySymbol name, int startOffset, int length) {
            super(startOffset, length);
            this.locals = locals;
            this.constant_path = constant_path;
            this.body = body;
            this.name = name;
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
            this.constant_path.accept(visitor);
            if (this.body != null) {
                this.body.accept(visitor);
            }
        }

        public Node[] childNodes() {
            return new Node[] { this.constant_path, this.body };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitModuleNode(this);
        }

        @Override
        protected String toString(String indent) {
            StringBuilder builder = new StringBuilder();
            builder.append(this.getClass().getSimpleName());
            if (hasNewLineFlag()) {
                builder.append("[Li]");
            }
            builder.append('\n');
            String nextIndent = indent + "  ";
            String nextNextIndent = nextIndent + "  ";
            builder.append(nextIndent);
            builder.append("locals: ");
            builder.append('\n');
            for (org.jruby.RubySymbol constant : this.locals) {
                builder.append(nextNextIndent).append('"').append(constant).append('"').append('\n');
            }
            builder.append(nextIndent);
            builder.append("constant_path: ");
            builder.append(this.constant_path.toString(nextIndent));
            builder.append(nextIndent);
            builder.append("body: ");
            builder.append(this.body == null ? "null\n" : this.body.toString(nextIndent));
            builder.append(nextIndent);
            builder.append("name: ");
            builder.append('"').append(this.name).append('"');
            builder.append('\n');
            return builder.toString();
        }
    }

    /**
     * Represents a multi-target expression.
     *
     *     a, (b, c) = 1, 2, 3
     *        ^^^^^^
     */
    public static final class MultiTargetNode extends Node {
        public final Node[] lefts;
        /** optional (can be null) */
        public final Node rest;
        public final Node[] rights;

        public MultiTargetNode(Node[] lefts, Node rest, Node[] rights, int startOffset, int length) {
            super(startOffset, length);
            this.lefts = lefts;
            this.rest = rest;
            this.rights = rights;
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
            for (Nodes.Node child : this.lefts) {
                child.accept(visitor);
            }
            if (this.rest != null) {
                this.rest.accept(visitor);
            }
            for (Nodes.Node child : this.rights) {
                child.accept(visitor);
            }
        }

        public Node[] childNodes() {
            ArrayList<Node> childNodes = new ArrayList<>();
            childNodes.addAll(Arrays.asList(this.lefts));
            childNodes.add(this.rest);
            childNodes.addAll(Arrays.asList(this.rights));
            return childNodes.toArray(EMPTY_ARRAY);
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitMultiTargetNode(this);
        }

        @Override
        protected String toString(String indent) {
            StringBuilder builder = new StringBuilder();
            builder.append(this.getClass().getSimpleName());
            if (hasNewLineFlag()) {
                builder.append("[Li]");
            }
            builder.append('\n');
            String nextIndent = indent + "  ";
            String nextNextIndent = nextIndent + "  ";
            builder.append(nextIndent);
            builder.append("lefts: ");
            builder.append('\n');
            for (Node child : this.lefts) {
                builder.append(nextNextIndent).append(child.toString(nextNextIndent));
            }
            builder.append(nextIndent);
            builder.append("rest: ");
            builder.append(this.rest == null ? "null\n" : this.rest.toString(nextIndent));
            builder.append(nextIndent);
            builder.append("rights: ");
            builder.append('\n');
            for (Node child : this.rights) {
                builder.append(nextNextIndent).append(child.toString(nextNextIndent));
            }
            return builder.toString();
        }
    }

    /**
     * Represents a write to a multi-target expression.
     *
     *     a, b, c = 1, 2, 3
     *     ^^^^^^^^^^^^^^^^^
     */
    public static final class MultiWriteNode extends Node {
        public final Node[] lefts;
        /** optional (can be null) */
        public final Node rest;
        public final Node[] rights;
        public final Node value;

        public MultiWriteNode(Node[] lefts, Node rest, Node[] rights, Node value, int startOffset, int length) {
            super(startOffset, length);
            this.lefts = lefts;
            this.rest = rest;
            this.rights = rights;
            this.value = value;
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
            for (Nodes.Node child : this.lefts) {
                child.accept(visitor);
            }
            if (this.rest != null) {
                this.rest.accept(visitor);
            }
            for (Nodes.Node child : this.rights) {
                child.accept(visitor);
            }
            this.value.accept(visitor);
        }

        public Node[] childNodes() {
            ArrayList<Node> childNodes = new ArrayList<>();
            childNodes.addAll(Arrays.asList(this.lefts));
            childNodes.add(this.rest);
            childNodes.addAll(Arrays.asList(this.rights));
            childNodes.add(this.value);
            return childNodes.toArray(EMPTY_ARRAY);
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitMultiWriteNode(this);
        }

        @Override
        protected String toString(String indent) {
            StringBuilder builder = new StringBuilder();
            builder.append(this.getClass().getSimpleName());
            if (hasNewLineFlag()) {
                builder.append("[Li]");
            }
            builder.append('\n');
            String nextIndent = indent + "  ";
            String nextNextIndent = nextIndent + "  ";
            builder.append(nextIndent);
            builder.append("lefts: ");
            builder.append('\n');
            for (Node child : this.lefts) {
                builder.append(nextNextIndent).append(child.toString(nextNextIndent));
            }
            builder.append(nextIndent);
            builder.append("rest: ");
            builder.append(this.rest == null ? "null\n" : this.rest.toString(nextIndent));
            builder.append(nextIndent);
            builder.append("rights: ");
            builder.append('\n');
            for (Node child : this.rights) {
                builder.append(nextNextIndent).append(child.toString(nextNextIndent));
            }
            builder.append(nextIndent);
            builder.append("value: ");
            builder.append(this.value.toString(nextIndent));
            return builder.toString();
        }
    }

    /**
     * Represents the use of the `next` keyword.
     *
     *     next 1
     *     ^^^^^^
     */
    public static final class NextNode extends Node {
        /** optional (can be null) */
        public final ArgumentsNode arguments;

        public NextNode(ArgumentsNode arguments, int startOffset, int length) {
            super(startOffset, length);
            this.arguments = arguments;
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
            if (this.arguments != null) {
                this.arguments.accept(visitor);
            }
        }

        public Node[] childNodes() {
            return new Node[] { this.arguments };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitNextNode(this);
        }

        @Override
        protected String toString(String indent) {
            StringBuilder builder = new StringBuilder();
            builder.append(this.getClass().getSimpleName());
            if (hasNewLineFlag()) {
                builder.append("[Li]");
            }
            builder.append('\n');
            String nextIndent = indent + "  ";
            builder.append(nextIndent);
            builder.append("arguments: ");
            builder.append(this.arguments == null ? "null\n" : this.arguments.toString(nextIndent));
            return builder.toString();
        }
    }

    /**
     * Represents the use of the `nil` keyword.
     *
     *     nil
     *     ^^^
     */
    public static final class NilNode extends Node {

        public NilNode(int startOffset, int length) {
            super(startOffset, length);
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
        }

        public Node[] childNodes() {
            return EMPTY_ARRAY;
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitNilNode(this);
        }

        @Override
        protected String toString(String indent) {
            StringBuilder builder = new StringBuilder();
            builder.append(this.getClass().getSimpleName());
            if (hasNewLineFlag()) {
                builder.append("[Li]");
            }
            builder.append('\n');
            String nextIndent = indent + "  ";
            return builder.toString();
        }
    }

    /**
     * Represents the use of `**nil` inside method arguments.
     *
     *     def a(**nil)
     *           ^^^^^
     *     end
     */
    public static final class NoKeywordsParameterNode extends Node {

        public NoKeywordsParameterNode(int startOffset, int length) {
            super(startOffset, length);
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
        }

        public Node[] childNodes() {
            return EMPTY_ARRAY;
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitNoKeywordsParameterNode(this);
        }

        @Override
        protected String toString(String indent) {
            StringBuilder builder = new StringBuilder();
            builder.append(this.getClass().getSimpleName());
            if (hasNewLineFlag()) {
                builder.append("[Li]");
            }
            builder.append('\n');
            String nextIndent = indent + "  ";
            return builder.toString();
        }
    }

    /**
     * Represents an implicit set of parameters through the use of numbered
     * parameters within a block or lambda.
     *
     *     -> { _1 + _2 }
     *     ^^^^^^^^^^^^^^
     */
    public static final class NumberedParametersNode extends Node {
        public final int maximum;

        public NumberedParametersNode(int maximum, int startOffset, int length) {
            super(startOffset, length);
            this.maximum = maximum;
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
        }

        public Node[] childNodes() {
            return EMPTY_ARRAY;
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitNumberedParametersNode(this);
        }

        @Override
        protected String toString(String indent) {
            StringBuilder builder = new StringBuilder();
            builder.append(this.getClass().getSimpleName());
            if (hasNewLineFlag()) {
                builder.append("[Li]");
            }
            builder.append('\n');
            String nextIndent = indent + "  ";
            builder.append(nextIndent);
            builder.append("maximum: ");
            builder.append(this.maximum);
            builder.append('\n');
            return builder.toString();
        }
    }

    /**
     * Represents reading a numbered reference to a capture in the previous match.
     *
     *     $1
     *     ^^
     */
    public static final class NumberedReferenceReadNode extends Node {
        public final int number;

        public NumberedReferenceReadNode(int number, int startOffset, int length) {
            super(startOffset, length);
            this.number = number;
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
        }

        public Node[] childNodes() {
            return EMPTY_ARRAY;
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitNumberedReferenceReadNode(this);
        }

        @Override
        protected String toString(String indent) {
            StringBuilder builder = new StringBuilder();
            builder.append(this.getClass().getSimpleName());
            if (hasNewLineFlag()) {
                builder.append("[Li]");
            }
            builder.append('\n');
            String nextIndent = indent + "  ";
            builder.append(nextIndent);
            builder.append("number: ");
            builder.append(this.number);
            builder.append('\n');
            return builder.toString();
        }
    }

    /**
     * Represents an optional keyword parameter to a method, block, or lambda definition.
     *
     *     def a(b: 1)
     *           ^^^^
     *     end
     */
    public static final class OptionalKeywordParameterNode extends Node {
        public final org.jruby.RubySymbol name;
        public final Node value;

        public OptionalKeywordParameterNode(org.jruby.RubySymbol name, Node value, int startOffset, int length) {
            super(startOffset, length);
            this.name = name;
            this.value = value;
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
            this.value.accept(visitor);
        }

        public Node[] childNodes() {
            return new Node[] { this.value };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitOptionalKeywordParameterNode(this);
        }

        @Override
        protected String toString(String indent) {
            StringBuilder builder = new StringBuilder();
            builder.append(this.getClass().getSimpleName());
            if (hasNewLineFlag()) {
                builder.append("[Li]");
            }
            builder.append('\n');
            String nextIndent = indent + "  ";
            builder.append(nextIndent);
            builder.append("name: ");
            builder.append('"').append(this.name).append('"');
            builder.append('\n');
            builder.append(nextIndent);
            builder.append("value: ");
            builder.append(this.value.toString(nextIndent));
            return builder.toString();
        }
    }

    /**
     * Represents an optional parameter to a method, block, or lambda definition.
     *
     *     def a(b = 1)
     *           ^^^^^
     *     end
     */
    public static final class OptionalParameterNode extends Node {
        public final org.jruby.RubySymbol name;
        public final Node value;

        public OptionalParameterNode(org.jruby.RubySymbol name, Node value, int startOffset, int length) {
            super(startOffset, length);
            this.name = name;
            this.value = value;
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
            this.value.accept(visitor);
        }

        public Node[] childNodes() {
            return new Node[] { this.value };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitOptionalParameterNode(this);
        }

        @Override
        protected String toString(String indent) {
            StringBuilder builder = new StringBuilder();
            builder.append(this.getClass().getSimpleName());
            if (hasNewLineFlag()) {
                builder.append("[Li]");
            }
            builder.append('\n');
            String nextIndent = indent + "  ";
            builder.append(nextIndent);
            builder.append("name: ");
            builder.append('"').append(this.name).append('"');
            builder.append('\n');
            builder.append(nextIndent);
            builder.append("value: ");
            builder.append(this.value.toString(nextIndent));
            return builder.toString();
        }
    }

    /**
     * Represents the use of the `||` operator or the `or` keyword.
     *
     *     left or right
     *     ^^^^^^^^^^^^^
     */
    public static final class OrNode extends Node {
        public final Node left;
        public final Node right;

        public OrNode(Node left, Node right, int startOffset, int length) {
            super(startOffset, length);
            this.left = left;
            this.right = right;
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
            this.left.accept(visitor);
            this.right.accept(visitor);
        }

        public Node[] childNodes() {
            return new Node[] { this.left, this.right };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitOrNode(this);
        }

        @Override
        protected String toString(String indent) {
            StringBuilder builder = new StringBuilder();
            builder.append(this.getClass().getSimpleName());
            if (hasNewLineFlag()) {
                builder.append("[Li]");
            }
            builder.append('\n');
            String nextIndent = indent + "  ";
            builder.append(nextIndent);
            builder.append("left: ");
            builder.append(this.left.toString(nextIndent));
            builder.append(nextIndent);
            builder.append("right: ");
            builder.append(this.right.toString(nextIndent));
            return builder.toString();
        }
    }

    /**
     * Represents the list of parameters on a method, block, or lambda definition.
     *
     *     def a(b, c, d)
     *           ^^^^^^^
     *     end
     */
    public static final class ParametersNode extends Node {
        public final Node[] requireds;
        public final Node[] optionals;
        /** optional (can be null) */
        public final Node rest;
        public final Node[] posts;
        public final Node[] keywords;
        /** optional (can be null) */
        public final Node keyword_rest;
        /** optional (can be null) */
        public final BlockParameterNode block;

        public ParametersNode(Node[] requireds, Node[] optionals, Node rest, Node[] posts, Node[] keywords, Node keyword_rest, BlockParameterNode block, int startOffset, int length) {
            super(startOffset, length);
            this.requireds = requireds;
            this.optionals = optionals;
            this.rest = rest;
            this.posts = posts;
            this.keywords = keywords;
            this.keyword_rest = keyword_rest;
            this.block = block;
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
            for (Nodes.Node child : this.requireds) {
                child.accept(visitor);
            }
            for (Nodes.Node child : this.optionals) {
                child.accept(visitor);
            }
            if (this.rest != null) {
                this.rest.accept(visitor);
            }
            for (Nodes.Node child : this.posts) {
                child.accept(visitor);
            }
            for (Nodes.Node child : this.keywords) {
                child.accept(visitor);
            }
            if (this.keyword_rest != null) {
                this.keyword_rest.accept(visitor);
            }
            if (this.block != null) {
                this.block.accept(visitor);
            }
        }

        public Node[] childNodes() {
            ArrayList<Node> childNodes = new ArrayList<>();
            childNodes.addAll(Arrays.asList(this.requireds));
            childNodes.addAll(Arrays.asList(this.optionals));
            childNodes.add(this.rest);
            childNodes.addAll(Arrays.asList(this.posts));
            childNodes.addAll(Arrays.asList(this.keywords));
            childNodes.add(this.keyword_rest);
            childNodes.add(this.block);
            return childNodes.toArray(EMPTY_ARRAY);
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitParametersNode(this);
        }

        @Override
        protected String toString(String indent) {
            StringBuilder builder = new StringBuilder();
            builder.append(this.getClass().getSimpleName());
            if (hasNewLineFlag()) {
                builder.append("[Li]");
            }
            builder.append('\n');
            String nextIndent = indent + "  ";
            String nextNextIndent = nextIndent + "  ";
            builder.append(nextIndent);
            builder.append("requireds: ");
            builder.append('\n');
            for (Node child : this.requireds) {
                builder.append(nextNextIndent).append(child.toString(nextNextIndent));
            }
            builder.append(nextIndent);
            builder.append("optionals: ");
            builder.append('\n');
            for (Node child : this.optionals) {
                builder.append(nextNextIndent).append(child.toString(nextNextIndent));
            }
            builder.append(nextIndent);
            builder.append("rest: ");
            builder.append(this.rest == null ? "null\n" : this.rest.toString(nextIndent));
            builder.append(nextIndent);
            builder.append("posts: ");
            builder.append('\n');
            for (Node child : this.posts) {
                builder.append(nextNextIndent).append(child.toString(nextNextIndent));
            }
            builder.append(nextIndent);
            builder.append("keywords: ");
            builder.append('\n');
            for (Node child : this.keywords) {
                builder.append(nextNextIndent).append(child.toString(nextNextIndent));
            }
            builder.append(nextIndent);
            builder.append("keyword_rest: ");
            builder.append(this.keyword_rest == null ? "null\n" : this.keyword_rest.toString(nextIndent));
            builder.append(nextIndent);
            builder.append("block: ");
            builder.append(this.block == null ? "null\n" : this.block.toString(nextIndent));
            return builder.toString();
        }
    }

    /**
     * Represents a parenthesized expression
     *
     *     (10 + 34)
     *     ^^^^^^^^^
     */
    public static final class ParenthesesNode extends Node {
        /** optional (can be null) */
        public final Node body;

        public ParenthesesNode(Node body, int startOffset, int length) {
            super(startOffset, length);
            this.body = body;
        }
                
        @Override
        public void setNewLineFlag(Source source, boolean[] newlineMarked) {
            // Never mark ParenthesesNode with a newline flag, mark children instead
        }

        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
            if (this.body != null) {
                this.body.accept(visitor);
            }
        }

        public Node[] childNodes() {
            return new Node[] { this.body };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitParenthesesNode(this);
        }

        @Override
        protected String toString(String indent) {
            StringBuilder builder = new StringBuilder();
            builder.append(this.getClass().getSimpleName());
            if (hasNewLineFlag()) {
                builder.append("[Li]");
            }
            builder.append('\n');
            String nextIndent = indent + "  ";
            builder.append(nextIndent);
            builder.append("body: ");
            builder.append(this.body == null ? "null\n" : this.body.toString(nextIndent));
            return builder.toString();
        }
    }

    /**
     * Represents the use of the `^` operator for pinning an expression in a
     * pattern matching expression.
     *
     *     foo in ^(bar)
     *            ^^^^^^
     */
    public static final class PinnedExpressionNode extends Node {
        public final Node expression;

        public PinnedExpressionNode(Node expression, int startOffset, int length) {
            super(startOffset, length);
            this.expression = expression;
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
            this.expression.accept(visitor);
        }

        public Node[] childNodes() {
            return new Node[] { this.expression };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitPinnedExpressionNode(this);
        }

        @Override
        protected String toString(String indent) {
            StringBuilder builder = new StringBuilder();
            builder.append(this.getClass().getSimpleName());
            if (hasNewLineFlag()) {
                builder.append("[Li]");
            }
            builder.append('\n');
            String nextIndent = indent + "  ";
            builder.append(nextIndent);
            builder.append("expression: ");
            builder.append(this.expression.toString(nextIndent));
            return builder.toString();
        }
    }

    /**
     * Represents the use of the `^` operator for pinning a variable in a pattern
     * matching expression.
     *
     *     foo in ^bar
     *            ^^^^
     */
    public static final class PinnedVariableNode extends Node {
        public final Node variable;

        public PinnedVariableNode(Node variable, int startOffset, int length) {
            super(startOffset, length);
            this.variable = variable;
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
            this.variable.accept(visitor);
        }

        public Node[] childNodes() {
            return new Node[] { this.variable };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitPinnedVariableNode(this);
        }

        @Override
        protected String toString(String indent) {
            StringBuilder builder = new StringBuilder();
            builder.append(this.getClass().getSimpleName());
            if (hasNewLineFlag()) {
                builder.append("[Li]");
            }
            builder.append('\n');
            String nextIndent = indent + "  ";
            builder.append(nextIndent);
            builder.append("variable: ");
            builder.append(this.variable.toString(nextIndent));
            return builder.toString();
        }
    }

    /**
     * Represents the use of the `END` keyword.
     *
     *     END { foo }
     *     ^^^^^^^^^^^
     */
    public static final class PostExecutionNode extends Node {
        /** optional (can be null) */
        public final StatementsNode statements;

        public PostExecutionNode(StatementsNode statements, int startOffset, int length) {
            super(startOffset, length);
            this.statements = statements;
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
            if (this.statements != null) {
                this.statements.accept(visitor);
            }
        }

        public Node[] childNodes() {
            return new Node[] { this.statements };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitPostExecutionNode(this);
        }

        @Override
        protected String toString(String indent) {
            StringBuilder builder = new StringBuilder();
            builder.append(this.getClass().getSimpleName());
            if (hasNewLineFlag()) {
                builder.append("[Li]");
            }
            builder.append('\n');
            String nextIndent = indent + "  ";
            builder.append(nextIndent);
            builder.append("statements: ");
            builder.append(this.statements == null ? "null\n" : this.statements.toString(nextIndent));
            return builder.toString();
        }
    }

    /**
     * Represents the use of the `BEGIN` keyword.
     *
     *     BEGIN { foo }
     *     ^^^^^^^^^^^^^
     */
    public static final class PreExecutionNode extends Node {
        /** optional (can be null) */
        public final StatementsNode statements;

        public PreExecutionNode(StatementsNode statements, int startOffset, int length) {
            super(startOffset, length);
            this.statements = statements;
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
            if (this.statements != null) {
                this.statements.accept(visitor);
            }
        }

        public Node[] childNodes() {
            return new Node[] { this.statements };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitPreExecutionNode(this);
        }

        @Override
        protected String toString(String indent) {
            StringBuilder builder = new StringBuilder();
            builder.append(this.getClass().getSimpleName());
            if (hasNewLineFlag()) {
                builder.append("[Li]");
            }
            builder.append('\n');
            String nextIndent = indent + "  ";
            builder.append(nextIndent);
            builder.append("statements: ");
            builder.append(this.statements == null ? "null\n" : this.statements.toString(nextIndent));
            return builder.toString();
        }
    }

    /**
     * The top level node of any parse tree.
     */
    public static final class ProgramNode extends Node {
        public final org.jruby.RubySymbol[] locals;
        public final StatementsNode statements;

        public ProgramNode(org.jruby.RubySymbol[] locals, StatementsNode statements, int startOffset, int length) {
            super(startOffset, length);
            this.locals = locals;
            this.statements = statements;
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
            this.statements.accept(visitor);
        }

        public Node[] childNodes() {
            return new Node[] { this.statements };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitProgramNode(this);
        }

        @Override
        protected String toString(String indent) {
            StringBuilder builder = new StringBuilder();
            builder.append(this.getClass().getSimpleName());
            if (hasNewLineFlag()) {
                builder.append("[Li]");
            }
            builder.append('\n');
            String nextIndent = indent + "  ";
            String nextNextIndent = nextIndent + "  ";
            builder.append(nextIndent);
            builder.append("locals: ");
            builder.append('\n');
            for (org.jruby.RubySymbol constant : this.locals) {
                builder.append(nextNextIndent).append('"').append(constant).append('"').append('\n');
            }
            builder.append(nextIndent);
            builder.append("statements: ");
            builder.append(this.statements.toString(nextIndent));
            return builder.toString();
        }
    }

    /**
     * Represents the use of the `..` or `...` operators.
     *
     *     1..2
     *     ^^^^
     *
     *     c if a =~ /left/ ... b =~ /right/
     *          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
     */
    public static final class RangeNode extends Node {
        /** optional (can be null) */
        public final Node left;
        /** optional (can be null) */
        public final Node right;
        public final short flags;

        public RangeNode(Node left, Node right, short flags, int startOffset, int length) {
            super(startOffset, length);
            this.left = left;
            this.right = right;
            this.flags = flags;
        }
        
        public boolean isExcludeEnd() {
            return RangeFlags.isExcludeEnd(this.flags);
        }
        
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
            if (this.left != null) {
                this.left.accept(visitor);
            }
            if (this.right != null) {
                this.right.accept(visitor);
            }
        }

        public Node[] childNodes() {
            return new Node[] { this.left, this.right };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitRangeNode(this);
        }

        @Override
        protected String toString(String indent) {
            StringBuilder builder = new StringBuilder();
            builder.append(this.getClass().getSimpleName());
            if (hasNewLineFlag()) {
                builder.append("[Li]");
            }
            builder.append('\n');
            String nextIndent = indent + "  ";
            builder.append(nextIndent);
            builder.append("left: ");
            builder.append(this.left == null ? "null\n" : this.left.toString(nextIndent));
            builder.append(nextIndent);
            builder.append("right: ");
            builder.append(this.right == null ? "null\n" : this.right.toString(nextIndent));
            builder.append(nextIndent);
            builder.append("flags: ");
            builder.append(this.flags);
            builder.append('\n');
            return builder.toString();
        }
    }

    /**
     * Represents a rational number literal.
     *
     *     1.0r
     *     ^^^^
     */
    public static final class RationalNode extends Node {
        public final Node numeric;

        public RationalNode(Node numeric, int startOffset, int length) {
            super(startOffset, length);
            this.numeric = numeric;
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
            this.numeric.accept(visitor);
        }

        public Node[] childNodes() {
            return new Node[] { this.numeric };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitRationalNode(this);
        }

        @Override
        protected String toString(String indent) {
            StringBuilder builder = new StringBuilder();
            builder.append(this.getClass().getSimpleName());
            if (hasNewLineFlag()) {
                builder.append("[Li]");
            }
            builder.append('\n');
            String nextIndent = indent + "  ";
            builder.append(nextIndent);
            builder.append("numeric: ");
            builder.append(this.numeric.toString(nextIndent));
            return builder.toString();
        }
    }

    /**
     * Represents the use of the `redo` keyword.
     *
     *     redo
     *     ^^^^
     */
    public static final class RedoNode extends Node {

        public RedoNode(int startOffset, int length) {
            super(startOffset, length);
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
        }

        public Node[] childNodes() {
            return EMPTY_ARRAY;
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitRedoNode(this);
        }

        @Override
        protected String toString(String indent) {
            StringBuilder builder = new StringBuilder();
            builder.append(this.getClass().getSimpleName());
            if (hasNewLineFlag()) {
                builder.append("[Li]");
            }
            builder.append('\n');
            String nextIndent = indent + "  ";
            return builder.toString();
        }
    }

    /**
     * Represents a regular expression literal with no interpolation.
     *
     *     /foo/i
     *     ^^^^^^
     */
    public static final class RegularExpressionNode extends Node {
        public final byte[] unescaped;
        public final short flags;

        public RegularExpressionNode(byte[] unescaped, short flags, int startOffset, int length) {
            super(startOffset, length);
            this.unescaped = unescaped;
            this.flags = flags;
        }
        
        public boolean isIgnoreCase() {
            return RegularExpressionFlags.isIgnoreCase(this.flags);
        }

        public boolean isExtended() {
            return RegularExpressionFlags.isExtended(this.flags);
        }

        public boolean isMultiLine() {
            return RegularExpressionFlags.isMultiLine(this.flags);
        }

        public boolean isOnce() {
            return RegularExpressionFlags.isOnce(this.flags);
        }

        public boolean isEucJp() {
            return RegularExpressionFlags.isEucJp(this.flags);
        }

        public boolean isAscii8bit() {
            return RegularExpressionFlags.isAscii8bit(this.flags);
        }

        public boolean isWindows31j() {
            return RegularExpressionFlags.isWindows31j(this.flags);
        }

        public boolean isUtf8() {
            return RegularExpressionFlags.isUtf8(this.flags);
        }
        
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
        }

        public Node[] childNodes() {
            return EMPTY_ARRAY;
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitRegularExpressionNode(this);
        }

        @Override
        protected String toString(String indent) {
            StringBuilder builder = new StringBuilder();
            builder.append(this.getClass().getSimpleName());
            if (hasNewLineFlag()) {
                builder.append("[Li]");
            }
            builder.append('\n');
            String nextIndent = indent + "  ";
            builder.append(nextIndent);
            builder.append("unescaped: ");
            builder.append('"' + new String(this.unescaped, StandardCharsets.UTF_8) + '"');
            builder.append('\n');
            builder.append(nextIndent);
            builder.append("flags: ");
            builder.append(this.flags);
            builder.append('\n');
            return builder.toString();
        }
    }

    /**
     * Represents a required keyword parameter to a method, block, or lambda definition.
     *
     *     def a(b: )
     *           ^^
     *     end
     */
    public static final class RequiredKeywordParameterNode extends Node {
        public final org.jruby.RubySymbol name;

        public RequiredKeywordParameterNode(org.jruby.RubySymbol name, int startOffset, int length) {
            super(startOffset, length);
            this.name = name;
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
        }

        public Node[] childNodes() {
            return EMPTY_ARRAY;
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitRequiredKeywordParameterNode(this);
        }

        @Override
        protected String toString(String indent) {
            StringBuilder builder = new StringBuilder();
            builder.append(this.getClass().getSimpleName());
            if (hasNewLineFlag()) {
                builder.append("[Li]");
            }
            builder.append('\n');
            String nextIndent = indent + "  ";
            builder.append(nextIndent);
            builder.append("name: ");
            builder.append('"').append(this.name).append('"');
            builder.append('\n');
            return builder.toString();
        }
    }

    /**
     * Represents a required parameter to a method, block, or lambda definition.
     *
     *     def a(b)
     *           ^
     *     end
     */
    public static final class RequiredParameterNode extends Node {
        public final org.jruby.RubySymbol name;

        public RequiredParameterNode(org.jruby.RubySymbol name, int startOffset, int length) {
            super(startOffset, length);
            this.name = name;
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
        }

        public Node[] childNodes() {
            return EMPTY_ARRAY;
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitRequiredParameterNode(this);
        }

        @Override
        protected String toString(String indent) {
            StringBuilder builder = new StringBuilder();
            builder.append(this.getClass().getSimpleName());
            if (hasNewLineFlag()) {
                builder.append("[Li]");
            }
            builder.append('\n');
            String nextIndent = indent + "  ";
            builder.append(nextIndent);
            builder.append("name: ");
            builder.append('"').append(this.name).append('"');
            builder.append('\n');
            return builder.toString();
        }
    }

    /**
     * Represents an expression modified with a rescue.
     *
     *     foo rescue nil
     *     ^^^^^^^^^^^^^^
     */
    public static final class RescueModifierNode extends Node {
        public final Node expression;
        public final Node rescue_expression;

        public RescueModifierNode(Node expression, Node rescue_expression, int startOffset, int length) {
            super(startOffset, length);
            this.expression = expression;
            this.rescue_expression = rescue_expression;
        }
                
        @Override
        public void setNewLineFlag(Source source, boolean[] newlineMarked) {
            this.expression.setNewLineFlag(source, newlineMarked);
        }

        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
            this.expression.accept(visitor);
            this.rescue_expression.accept(visitor);
        }

        public Node[] childNodes() {
            return new Node[] { this.expression, this.rescue_expression };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitRescueModifierNode(this);
        }

        @Override
        protected String toString(String indent) {
            StringBuilder builder = new StringBuilder();
            builder.append(this.getClass().getSimpleName());
            if (hasNewLineFlag()) {
                builder.append("[Li]");
            }
            builder.append('\n');
            String nextIndent = indent + "  ";
            builder.append(nextIndent);
            builder.append("expression: ");
            builder.append(this.expression.toString(nextIndent));
            builder.append(nextIndent);
            builder.append("rescue_expression: ");
            builder.append(this.rescue_expression.toString(nextIndent));
            return builder.toString();
        }
    }

    /**
     * Represents a rescue statement.
     *
     *     begin
     *     rescue Foo, *splat, Bar => ex
     *       foo
     *     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
     *     end
     *
     * `Foo, *splat, Bar` are in the `exceptions` field.
     * `ex` is in the `exception` field.
     */
    public static final class RescueNode extends Node {
        public final Node[] exceptions;
        /** optional (can be null) */
        public final Node reference;
        /** optional (can be null) */
        public final StatementsNode statements;
        /** optional (can be null) */
        public final RescueNode consequent;

        public RescueNode(Node[] exceptions, Node reference, StatementsNode statements, RescueNode consequent, int startOffset, int length) {
            super(startOffset, length);
            this.exceptions = exceptions;
            this.reference = reference;
            this.statements = statements;
            this.consequent = consequent;
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
            for (Nodes.Node child : this.exceptions) {
                child.accept(visitor);
            }
            if (this.reference != null) {
                this.reference.accept(visitor);
            }
            if (this.statements != null) {
                this.statements.accept(visitor);
            }
            if (this.consequent != null) {
                this.consequent.accept(visitor);
            }
        }

        public Node[] childNodes() {
            ArrayList<Node> childNodes = new ArrayList<>();
            childNodes.addAll(Arrays.asList(this.exceptions));
            childNodes.add(this.reference);
            childNodes.add(this.statements);
            childNodes.add(this.consequent);
            return childNodes.toArray(EMPTY_ARRAY);
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitRescueNode(this);
        }

        @Override
        protected String toString(String indent) {
            StringBuilder builder = new StringBuilder();
            builder.append(this.getClass().getSimpleName());
            if (hasNewLineFlag()) {
                builder.append("[Li]");
            }
            builder.append('\n');
            String nextIndent = indent + "  ";
            String nextNextIndent = nextIndent + "  ";
            builder.append(nextIndent);
            builder.append("exceptions: ");
            builder.append('\n');
            for (Node child : this.exceptions) {
                builder.append(nextNextIndent).append(child.toString(nextNextIndent));
            }
            builder.append(nextIndent);
            builder.append("reference: ");
            builder.append(this.reference == null ? "null\n" : this.reference.toString(nextIndent));
            builder.append(nextIndent);
            builder.append("statements: ");
            builder.append(this.statements == null ? "null\n" : this.statements.toString(nextIndent));
            builder.append(nextIndent);
            builder.append("consequent: ");
            builder.append(this.consequent == null ? "null\n" : this.consequent.toString(nextIndent));
            return builder.toString();
        }
    }

    /**
     * Represents a rest parameter to a method, block, or lambda definition.
     *
     *     def a(*b)
     *           ^^
     *     end
     */
    public static final class RestParameterNode extends Node {
        /** optional (can be null) */
        public final org.jruby.RubySymbol name;

        public RestParameterNode(org.jruby.RubySymbol name, int startOffset, int length) {
            super(startOffset, length);
            this.name = name;
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
        }

        public Node[] childNodes() {
            return EMPTY_ARRAY;
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitRestParameterNode(this);
        }

        @Override
        protected String toString(String indent) {
            StringBuilder builder = new StringBuilder();
            builder.append(this.getClass().getSimpleName());
            if (hasNewLineFlag()) {
                builder.append("[Li]");
            }
            builder.append('\n');
            String nextIndent = indent + "  ";
            builder.append(nextIndent);
            builder.append("name: ");
            builder.append(this.name == null ? "null" : "\"" + this.name + "\"");
            builder.append('\n');
            return builder.toString();
        }
    }

    /**
     * Represents the use of the `retry` keyword.
     *
     *     retry
     *     ^^^^^
     */
    public static final class RetryNode extends Node {

        public RetryNode(int startOffset, int length) {
            super(startOffset, length);
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
        }

        public Node[] childNodes() {
            return EMPTY_ARRAY;
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitRetryNode(this);
        }

        @Override
        protected String toString(String indent) {
            StringBuilder builder = new StringBuilder();
            builder.append(this.getClass().getSimpleName());
            if (hasNewLineFlag()) {
                builder.append("[Li]");
            }
            builder.append('\n');
            String nextIndent = indent + "  ";
            return builder.toString();
        }
    }

    /**
     * Represents the use of the `return` keyword.
     *
     *     return 1
     *     ^^^^^^^^
     */
    public static final class ReturnNode extends Node {
        /** optional (can be null) */
        public final ArgumentsNode arguments;

        public ReturnNode(ArgumentsNode arguments, int startOffset, int length) {
            super(startOffset, length);
            this.arguments = arguments;
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
            if (this.arguments != null) {
                this.arguments.accept(visitor);
            }
        }

        public Node[] childNodes() {
            return new Node[] { this.arguments };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitReturnNode(this);
        }

        @Override
        protected String toString(String indent) {
            StringBuilder builder = new StringBuilder();
            builder.append(this.getClass().getSimpleName());
            if (hasNewLineFlag()) {
                builder.append("[Li]");
            }
            builder.append('\n');
            String nextIndent = indent + "  ";
            builder.append(nextIndent);
            builder.append("arguments: ");
            builder.append(this.arguments == null ? "null\n" : this.arguments.toString(nextIndent));
            return builder.toString();
        }
    }

    /**
     * Represents the `self` keyword.
     *
     *     self
     *     ^^^^
     */
    public static final class SelfNode extends Node {

        public SelfNode(int startOffset, int length) {
            super(startOffset, length);
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
        }

        public Node[] childNodes() {
            return EMPTY_ARRAY;
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitSelfNode(this);
        }

        @Override
        protected String toString(String indent) {
            StringBuilder builder = new StringBuilder();
            builder.append(this.getClass().getSimpleName());
            if (hasNewLineFlag()) {
                builder.append("[Li]");
            }
            builder.append('\n');
            String nextIndent = indent + "  ";
            return builder.toString();
        }
    }

    /**
     * Represents a singleton class declaration involving the `class` keyword.
     *
     *     class << self end
     *     ^^^^^^^^^^^^^^^^^
     */
    public static final class SingletonClassNode extends Node {
        public final org.jruby.RubySymbol[] locals;
        public final Node expression;
        /** optional (can be null) */
        public final Node body;

        public SingletonClassNode(org.jruby.RubySymbol[] locals, Node expression, Node body, int startOffset, int length) {
            super(startOffset, length);
            this.locals = locals;
            this.expression = expression;
            this.body = body;
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
            this.expression.accept(visitor);
            if (this.body != null) {
                this.body.accept(visitor);
            }
        }

        public Node[] childNodes() {
            return new Node[] { this.expression, this.body };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitSingletonClassNode(this);
        }

        @Override
        protected String toString(String indent) {
            StringBuilder builder = new StringBuilder();
            builder.append(this.getClass().getSimpleName());
            if (hasNewLineFlag()) {
                builder.append("[Li]");
            }
            builder.append('\n');
            String nextIndent = indent + "  ";
            String nextNextIndent = nextIndent + "  ";
            builder.append(nextIndent);
            builder.append("locals: ");
            builder.append('\n');
            for (org.jruby.RubySymbol constant : this.locals) {
                builder.append(nextNextIndent).append('"').append(constant).append('"').append('\n');
            }
            builder.append(nextIndent);
            builder.append("expression: ");
            builder.append(this.expression.toString(nextIndent));
            builder.append(nextIndent);
            builder.append("body: ");
            builder.append(this.body == null ? "null\n" : this.body.toString(nextIndent));
            return builder.toString();
        }
    }

    /**
     * Represents the use of the `__ENCODING__` keyword.
     *
     *     __ENCODING__
     *     ^^^^^^^^^^^^
     */
    public static final class SourceEncodingNode extends Node {

        public SourceEncodingNode(int startOffset, int length) {
            super(startOffset, length);
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
        }

        public Node[] childNodes() {
            return EMPTY_ARRAY;
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitSourceEncodingNode(this);
        }

        @Override
        protected String toString(String indent) {
            StringBuilder builder = new StringBuilder();
            builder.append(this.getClass().getSimpleName());
            if (hasNewLineFlag()) {
                builder.append("[Li]");
            }
            builder.append('\n');
            String nextIndent = indent + "  ";
            return builder.toString();
        }
    }

    /**
     * Represents the use of the `__FILE__` keyword.
     *
     *     __FILE__
     *     ^^^^^^^^
     */
    public static final class SourceFileNode extends Node {
        public final byte[] filepath;

        public SourceFileNode(byte[] filepath, int startOffset, int length) {
            super(startOffset, length);
            this.filepath = filepath;
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
        }

        public Node[] childNodes() {
            return EMPTY_ARRAY;
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitSourceFileNode(this);
        }

        @Override
        protected String toString(String indent) {
            StringBuilder builder = new StringBuilder();
            builder.append(this.getClass().getSimpleName());
            if (hasNewLineFlag()) {
                builder.append("[Li]");
            }
            builder.append('\n');
            String nextIndent = indent + "  ";
            builder.append(nextIndent);
            builder.append("filepath: ");
            builder.append('"' + new String(this.filepath, StandardCharsets.UTF_8) + '"');
            builder.append('\n');
            return builder.toString();
        }
    }

    /**
     * Represents the use of the `__LINE__` keyword.
     *
     *     __LINE__
     *     ^^^^^^^^
     */
    public static final class SourceLineNode extends Node {

        public SourceLineNode(int startOffset, int length) {
            super(startOffset, length);
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
        }

        public Node[] childNodes() {
            return EMPTY_ARRAY;
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitSourceLineNode(this);
        }

        @Override
        protected String toString(String indent) {
            StringBuilder builder = new StringBuilder();
            builder.append(this.getClass().getSimpleName());
            if (hasNewLineFlag()) {
                builder.append("[Li]");
            }
            builder.append('\n');
            String nextIndent = indent + "  ";
            return builder.toString();
        }
    }

    /**
     * Represents the use of the splat operator.
     *
     *     [*a]
     *      ^^
     */
    public static final class SplatNode extends Node {
        /** optional (can be null) */
        public final Node expression;

        public SplatNode(Node expression, int startOffset, int length) {
            super(startOffset, length);
            this.expression = expression;
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
            if (this.expression != null) {
                this.expression.accept(visitor);
            }
        }

        public Node[] childNodes() {
            return new Node[] { this.expression };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitSplatNode(this);
        }

        @Override
        protected String toString(String indent) {
            StringBuilder builder = new StringBuilder();
            builder.append(this.getClass().getSimpleName());
            if (hasNewLineFlag()) {
                builder.append("[Li]");
            }
            builder.append('\n');
            String nextIndent = indent + "  ";
            builder.append(nextIndent);
            builder.append("expression: ");
            builder.append(this.expression == null ? "null\n" : this.expression.toString(nextIndent));
            return builder.toString();
        }
    }

    /**
     * Represents a set of statements contained within some scope.
     *
     *     foo; bar; baz
     *     ^^^^^^^^^^^^^
     */
    public static final class StatementsNode extends Node {
        public final Node[] body;

        public StatementsNode(Node[] body, int startOffset, int length) {
            super(startOffset, length);
            this.body = body;
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
            for (Nodes.Node child : this.body) {
                child.accept(visitor);
            }
        }

        public Node[] childNodes() {
            return this.body;
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitStatementsNode(this);
        }

        @Override
        protected String toString(String indent) {
            StringBuilder builder = new StringBuilder();
            builder.append(this.getClass().getSimpleName());
            if (hasNewLineFlag()) {
                builder.append("[Li]");
            }
            builder.append('\n');
            String nextIndent = indent + "  ";
            String nextNextIndent = nextIndent + "  ";
            builder.append(nextIndent);
            builder.append("body: ");
            builder.append('\n');
            for (Node child : this.body) {
                builder.append(nextNextIndent).append(child.toString(nextNextIndent));
            }
            return builder.toString();
        }
    }

    /**
     * Represents a string literal, a string contained within a `%w` list, or
     * plain string content within an interpolated string.
     *
     *     "foo"
     *     ^^^^^
     *
     *     %w[foo]
     *        ^^^
     *
     *     "foo #{bar} baz"
     *      ^^^^      ^^^^
     */
    public static final class StringNode extends Node {
        public final short flags;
        public final byte[] unescaped;

        public StringNode(short flags, byte[] unescaped, int startOffset, int length) {
            super(startOffset, length);
            this.flags = flags;
            this.unescaped = unescaped;
        }
        
        public boolean isFrozen() {
            return StringFlags.isFrozen(this.flags);
        }
        
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
        }

        public Node[] childNodes() {
            return EMPTY_ARRAY;
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitStringNode(this);
        }

        @Override
        protected String toString(String indent) {
            StringBuilder builder = new StringBuilder();
            builder.append(this.getClass().getSimpleName());
            if (hasNewLineFlag()) {
                builder.append("[Li]");
            }
            builder.append('\n');
            String nextIndent = indent + "  ";
            builder.append(nextIndent);
            builder.append("flags: ");
            builder.append(this.flags);
            builder.append('\n');
            builder.append(nextIndent);
            builder.append("unescaped: ");
            builder.append('"' + new String(this.unescaped, StandardCharsets.UTF_8) + '"');
            builder.append('\n');
            return builder.toString();
        }
    }

    /**
     * Represents the use of the `super` keyword with parentheses or arguments.
     *
     *     super()
     *     ^^^^^^^
     *
     *     super foo, bar
     *     ^^^^^^^^^^^^^^
     */
    public static final class SuperNode extends Node {
        /** optional (can be null) */
        public final ArgumentsNode arguments;
        /** optional (can be null) */
        public final Node block;

        public SuperNode(ArgumentsNode arguments, Node block, int startOffset, int length) {
            super(startOffset, length);
            this.arguments = arguments;
            this.block = block;
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
            if (this.arguments != null) {
                this.arguments.accept(visitor);
            }
            if (this.block != null) {
                this.block.accept(visitor);
            }
        }

        public Node[] childNodes() {
            return new Node[] { this.arguments, this.block };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitSuperNode(this);
        }

        @Override
        protected String toString(String indent) {
            StringBuilder builder = new StringBuilder();
            builder.append(this.getClass().getSimpleName());
            if (hasNewLineFlag()) {
                builder.append("[Li]");
            }
            builder.append('\n');
            String nextIndent = indent + "  ";
            builder.append(nextIndent);
            builder.append("arguments: ");
            builder.append(this.arguments == null ? "null\n" : this.arguments.toString(nextIndent));
            builder.append(nextIndent);
            builder.append("block: ");
            builder.append(this.block == null ? "null\n" : this.block.toString(nextIndent));
            return builder.toString();
        }
    }

    /**
     * Represents a symbol literal or a symbol contained within a `%i` list.
     *
     *     :foo
     *     ^^^^
     *
     *     %i[foo]
     *        ^^^
     */
    public static final class SymbolNode extends Node {
        public final byte[] unescaped;

        public SymbolNode(byte[] unescaped, int startOffset, int length) {
            super(startOffset, length);
            this.unescaped = unescaped;
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
        }

        public Node[] childNodes() {
            return EMPTY_ARRAY;
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitSymbolNode(this);
        }

        @Override
        protected String toString(String indent) {
            StringBuilder builder = new StringBuilder();
            builder.append(this.getClass().getSimpleName());
            if (hasNewLineFlag()) {
                builder.append("[Li]");
            }
            builder.append('\n');
            String nextIndent = indent + "  ";
            builder.append(nextIndent);
            builder.append("unescaped: ");
            builder.append('"' + new String(this.unescaped, StandardCharsets.UTF_8) + '"');
            builder.append('\n');
            return builder.toString();
        }
    }

    /**
     * Represents the use of the literal `true` keyword.
     *
     *     true
     *     ^^^^
     */
    public static final class TrueNode extends Node {

        public TrueNode(int startOffset, int length) {
            super(startOffset, length);
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
        }

        public Node[] childNodes() {
            return EMPTY_ARRAY;
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitTrueNode(this);
        }

        @Override
        protected String toString(String indent) {
            StringBuilder builder = new StringBuilder();
            builder.append(this.getClass().getSimpleName());
            if (hasNewLineFlag()) {
                builder.append("[Li]");
            }
            builder.append('\n');
            String nextIndent = indent + "  ";
            return builder.toString();
        }
    }

    /**
     * Represents the use of the `undef` keyword.
     *
     *     undef :foo, :bar, :baz
     *     ^^^^^^^^^^^^^^^^^^^^^^
     */
    public static final class UndefNode extends Node {
        public final Node[] names;

        public UndefNode(Node[] names, int startOffset, int length) {
            super(startOffset, length);
            this.names = names;
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
            for (Nodes.Node child : this.names) {
                child.accept(visitor);
            }
        }

        public Node[] childNodes() {
            return this.names;
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitUndefNode(this);
        }

        @Override
        protected String toString(String indent) {
            StringBuilder builder = new StringBuilder();
            builder.append(this.getClass().getSimpleName());
            if (hasNewLineFlag()) {
                builder.append("[Li]");
            }
            builder.append('\n');
            String nextIndent = indent + "  ";
            String nextNextIndent = nextIndent + "  ";
            builder.append(nextIndent);
            builder.append("names: ");
            builder.append('\n');
            for (Node child : this.names) {
                builder.append(nextNextIndent).append(child.toString(nextNextIndent));
            }
            return builder.toString();
        }
    }

    /**
     * Represents the use of the `unless` keyword, either in the block form or the modifier form.
     *
     *     bar unless foo
     *     ^^^^^^^^^^^^^^
     *
     *     unless foo then bar end
     *     ^^^^^^^^^^^^^^^^^^^^^^^
     */
    public static final class UnlessNode extends Node {
        public final Node predicate;
        /** optional (can be null) */
        public final StatementsNode statements;
        /** optional (can be null) */
        public final ElseNode consequent;

        public UnlessNode(Node predicate, StatementsNode statements, ElseNode consequent, int startOffset, int length) {
            super(startOffset, length);
            this.predicate = predicate;
            this.statements = statements;
            this.consequent = consequent;
        }
                
        @Override
        public void setNewLineFlag(Source source, boolean[] newlineMarked) {
            this.predicate.setNewLineFlag(source, newlineMarked);
        }

        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
            this.predicate.accept(visitor);
            if (this.statements != null) {
                this.statements.accept(visitor);
            }
            if (this.consequent != null) {
                this.consequent.accept(visitor);
            }
        }

        public Node[] childNodes() {
            return new Node[] { this.predicate, this.statements, this.consequent };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitUnlessNode(this);
        }

        @Override
        protected String toString(String indent) {
            StringBuilder builder = new StringBuilder();
            builder.append(this.getClass().getSimpleName());
            if (hasNewLineFlag()) {
                builder.append("[Li]");
            }
            builder.append('\n');
            String nextIndent = indent + "  ";
            builder.append(nextIndent);
            builder.append("predicate: ");
            builder.append(this.predicate.toString(nextIndent));
            builder.append(nextIndent);
            builder.append("statements: ");
            builder.append(this.statements == null ? "null\n" : this.statements.toString(nextIndent));
            builder.append(nextIndent);
            builder.append("consequent: ");
            builder.append(this.consequent == null ? "null\n" : this.consequent.toString(nextIndent));
            return builder.toString();
        }
    }

    /**
     * Represents the use of the `until` keyword, either in the block form or the modifier form.
     *
     *     bar until foo
     *     ^^^^^^^^^^^^^
     *
     *     until foo do bar end
     *     ^^^^^^^^^^^^^^^^^^^^
     */
    public static final class UntilNode extends Node {
        public final Node predicate;
        /** optional (can be null) */
        public final StatementsNode statements;
        public final short flags;

        public UntilNode(Node predicate, StatementsNode statements, short flags, int startOffset, int length) {
            super(startOffset, length);
            this.predicate = predicate;
            this.statements = statements;
            this.flags = flags;
        }
        
        public boolean isBeginModifier() {
            return LoopFlags.isBeginModifier(this.flags);
        }
        
        @Override
        public void setNewLineFlag(Source source, boolean[] newlineMarked) {
            this.predicate.setNewLineFlag(source, newlineMarked);
        }

        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
            this.predicate.accept(visitor);
            if (this.statements != null) {
                this.statements.accept(visitor);
            }
        }

        public Node[] childNodes() {
            return new Node[] { this.predicate, this.statements };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitUntilNode(this);
        }

        @Override
        protected String toString(String indent) {
            StringBuilder builder = new StringBuilder();
            builder.append(this.getClass().getSimpleName());
            if (hasNewLineFlag()) {
                builder.append("[Li]");
            }
            builder.append('\n');
            String nextIndent = indent + "  ";
            builder.append(nextIndent);
            builder.append("predicate: ");
            builder.append(this.predicate.toString(nextIndent));
            builder.append(nextIndent);
            builder.append("statements: ");
            builder.append(this.statements == null ? "null\n" : this.statements.toString(nextIndent));
            builder.append(nextIndent);
            builder.append("flags: ");
            builder.append(this.flags);
            builder.append('\n');
            return builder.toString();
        }
    }

    /**
     * Represents the use of the `when` keyword within a case statement.
     *
     *     case true
     *     when true
     *     ^^^^^^^^^
     *     end
     */
    public static final class WhenNode extends Node {
        public final Node[] conditions;
        /** optional (can be null) */
        public final StatementsNode statements;

        public WhenNode(Node[] conditions, StatementsNode statements, int startOffset, int length) {
            super(startOffset, length);
            this.conditions = conditions;
            this.statements = statements;
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
            for (Nodes.Node child : this.conditions) {
                child.accept(visitor);
            }
            if (this.statements != null) {
                this.statements.accept(visitor);
            }
        }

        public Node[] childNodes() {
            ArrayList<Node> childNodes = new ArrayList<>();
            childNodes.addAll(Arrays.asList(this.conditions));
            childNodes.add(this.statements);
            return childNodes.toArray(EMPTY_ARRAY);
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitWhenNode(this);
        }

        @Override
        protected String toString(String indent) {
            StringBuilder builder = new StringBuilder();
            builder.append(this.getClass().getSimpleName());
            if (hasNewLineFlag()) {
                builder.append("[Li]");
            }
            builder.append('\n');
            String nextIndent = indent + "  ";
            String nextNextIndent = nextIndent + "  ";
            builder.append(nextIndent);
            builder.append("conditions: ");
            builder.append('\n');
            for (Node child : this.conditions) {
                builder.append(nextNextIndent).append(child.toString(nextNextIndent));
            }
            builder.append(nextIndent);
            builder.append("statements: ");
            builder.append(this.statements == null ? "null\n" : this.statements.toString(nextIndent));
            return builder.toString();
        }
    }

    /**
     * Represents the use of the `while` keyword, either in the block form or the modifier form.
     *
     *     bar while foo
     *     ^^^^^^^^^^^^^
     *
     *     while foo do bar end
     *     ^^^^^^^^^^^^^^^^^^^^
     */
    public static final class WhileNode extends Node {
        public final Node predicate;
        /** optional (can be null) */
        public final StatementsNode statements;
        public final short flags;

        public WhileNode(Node predicate, StatementsNode statements, short flags, int startOffset, int length) {
            super(startOffset, length);
            this.predicate = predicate;
            this.statements = statements;
            this.flags = flags;
        }
        
        public boolean isBeginModifier() {
            return LoopFlags.isBeginModifier(this.flags);
        }
        
        @Override
        public void setNewLineFlag(Source source, boolean[] newlineMarked) {
            this.predicate.setNewLineFlag(source, newlineMarked);
        }

        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
            this.predicate.accept(visitor);
            if (this.statements != null) {
                this.statements.accept(visitor);
            }
        }

        public Node[] childNodes() {
            return new Node[] { this.predicate, this.statements };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitWhileNode(this);
        }

        @Override
        protected String toString(String indent) {
            StringBuilder builder = new StringBuilder();
            builder.append(this.getClass().getSimpleName());
            if (hasNewLineFlag()) {
                builder.append("[Li]");
            }
            builder.append('\n');
            String nextIndent = indent + "  ";
            builder.append(nextIndent);
            builder.append("predicate: ");
            builder.append(this.predicate.toString(nextIndent));
            builder.append(nextIndent);
            builder.append("statements: ");
            builder.append(this.statements == null ? "null\n" : this.statements.toString(nextIndent));
            builder.append(nextIndent);
            builder.append("flags: ");
            builder.append(this.flags);
            builder.append('\n');
            return builder.toString();
        }
    }

    /**
     * Represents an xstring literal with no interpolation.
     *
     *     `foo`
     *     ^^^^^
     */
    public static final class XStringNode extends Node {
        public final byte[] unescaped;

        public XStringNode(byte[] unescaped, int startOffset, int length) {
            super(startOffset, length);
            this.unescaped = unescaped;
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
        }

        public Node[] childNodes() {
            return EMPTY_ARRAY;
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitXStringNode(this);
        }

        @Override
        protected String toString(String indent) {
            StringBuilder builder = new StringBuilder();
            builder.append(this.getClass().getSimpleName());
            if (hasNewLineFlag()) {
                builder.append("[Li]");
            }
            builder.append('\n');
            String nextIndent = indent + "  ";
            builder.append(nextIndent);
            builder.append("unescaped: ");
            builder.append('"' + new String(this.unescaped, StandardCharsets.UTF_8) + '"');
            builder.append('\n');
            return builder.toString();
        }
    }

    /**
     * Represents the use of the `yield` keyword.
     *
     *     yield 1
     *     ^^^^^^^
     */
    public static final class YieldNode extends Node {
        /** optional (can be null) */
        public final ArgumentsNode arguments;

        public YieldNode(ArgumentsNode arguments, int startOffset, int length) {
            super(startOffset, length);
            this.arguments = arguments;
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
            if (this.arguments != null) {
                this.arguments.accept(visitor);
            }
        }

        public Node[] childNodes() {
            return new Node[] { this.arguments };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitYieldNode(this);
        }

        @Override
        protected String toString(String indent) {
            StringBuilder builder = new StringBuilder();
            builder.append(this.getClass().getSimpleName());
            if (hasNewLineFlag()) {
                builder.append("[Li]");
            }
            builder.append('\n');
            String nextIndent = indent + "  ";
            builder.append(nextIndent);
            builder.append("arguments: ");
            builder.append(this.arguments == null ? "null\n" : this.arguments.toString(nextIndent));
            return builder.toString();
        }
    }

}
// @formatter:on
